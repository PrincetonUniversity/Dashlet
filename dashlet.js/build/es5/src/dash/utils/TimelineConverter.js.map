{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":["TimelineConverter","context","eventBus","getInstance","settings","instance","dashManifestModel","clientServerTimeShift","isClientServerTimeSyncCompleted","expectedLiveEdge","setup","reset","initialize","resetInitialSettings","on","Events","TIME_SYNCHRONIZATION_COMPLETED","onTimeSyncComplete","isTimeSyncCompleted","setTimeSyncCompleted","value","getClientTimeOffset","setClientTimeOffset","getExpectedLiveEdge","setExpectedLiveEdge","calcAvailabilityTimeFromPresentationTime","presentationTime","mpd","isDynamic","calculateEnd","availabilityTime","NaN","timeShiftBufferDepth","Number","POSITIVE_INFINITY","Date","availabilityStartTime","getTime","availabilityEndTime","calcAvailabilityStartTimeFromPresentationTime","call","calcAvailabilityEndTimeFromPresentationTime","calcPresentationTimeFromWallTime","wallTime","period","calcPresentationTimeFromMediaTime","mediaTime","representation","periodStart","adaptation","start","presentationOffset","presentationTimeOffset","calcMediaTimeFromPresentationTime","calcWallTimeForSegment","segment","suggestedPresentationDelay","displayStartTime","presentationStartTime","calcSegmentAvailabilityRange","voRepresentation","voPeriod","range","end","duration","segmentAvailabilityRange","d","segmentDuration","segments","length","segmentInfoType","DashConstants","SEGMENT_TIMELINE","get","streaming","calcSegmentAvailabilityRangeFromTimeline","now","periodEnd","Math","max","endOffset","availabilityTimeOffset","undefined","manifest","Period_asArray","index","AdaptationSet_asArray","getRepresentationFor","timeline","SegmentTemplate","SegmentTimeline","timescale","S_asArray","repeat","i","len","t","hasOwnProperty","r","getPeriodEnd","min","calcPeriodRelativeTimeFromMpdRelativeTime","mpdRelativeTime","periodStartTime","e","offset","off","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"TimelineConverter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport DashConstants from '../constants/DashConstants';\nimport DashManifestModel from '../models/DashManifestModel';\nimport Settings from '../../core/Settings';\n\nfunction TimelineConverter() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const settings = Settings(context).getInstance();\n\n    let instance,\n        dashManifestModel,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function setup() {\n        dashManifestModel = DashManifestModel(context).getInstance();\n        reset();\n    }\n\n    function initialize() {\n        resetInitialSettings();\n        eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n    }\n\n    function isTimeSyncCompleted() {\n        return isClientServerTimeSyncCompleted;\n    }\n\n    function setTimeSyncCompleted(value) {\n        isClientServerTimeSyncCompleted = value;\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function setClientTimeOffset(value) {\n        clientServerTimeShift = value;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        let availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        let suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        const range = {start: voPeriod.start, end: voPeriod.start + voPeriod.duration};\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n\n        // Specific use case of SegmentTimeline without timeShiftBufferDepth\n        if (voRepresentation.segmentInfoType === DashConstants.SEGMENT_TIMELINE && settings.get().streaming.calcSegmentAvailabilityRangeFromTimeline) {\n            return calcSegmentAvailabilityRangeFromTimeline(voRepresentation);\n        }\n\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n        voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n\n        range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\n\n        return range;\n    }\n\n    function calcSegmentAvailabilityRangeFromTimeline(voRepresentation) {\n        const adaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n        const representation = dashManifestModel.getRepresentationFor(voRepresentation.index, adaptation);\n        const timeline = representation.SegmentTemplate.SegmentTimeline;\n        const timescale = representation.SegmentTemplate.timescale;\n        const segments = timeline.S_asArray;\n        const range = {start: 0, end: 0};\n        let d = 0;\n        let segment,\n            repeat,\n            i,\n            len;\n\n        range.start = calcPresentationTimeFromMediaTime(segments[0].t / timescale, voRepresentation);\n\n        for (i = 0, len = segments.length; i < len; i++) {\n            segment = segments[i];\n            repeat = 0;\n            if (segment.hasOwnProperty('r')) {\n                repeat = segment.r;\n            }\n            d += (segment.d / timescale) * (1 + repeat);\n        }\n\n        range.end = range.start + d;\n\n        return range;\n    }\n\n    function getPeriodEnd(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        if (!isDynamic) {\n            return voPeriod.start + voPeriod.duration;\n        }\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n        voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n\n        return Math.min(now - endOffset, periodEnd);\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    /*\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n    * FYI StreamController's onManifestUpdated entry point to timeSync\n    * */\n    function onTimeSyncComplete(e) {\n\n        if (isClientServerTimeSyncCompleted) return;\n\n        if (e.offset !== undefined) {\n            setClientTimeOffset(e.offset / 1000);\n            isClientServerTimeSyncCompleted = true;\n        }\n    }\n\n    function resetInitialSettings() {\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    function reset() {\n        eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        isTimeSyncCompleted: isTimeSyncCompleted,\n        setTimeSyncCompleted: setTimeSyncCompleted,\n        getClientTimeOffset: getClientTimeOffset,\n        setClientTimeOffset: setClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        getPeriodEnd: getPeriodEnd,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);\n"]}
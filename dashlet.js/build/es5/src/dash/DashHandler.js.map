{"version":3,"sources":["../../../../src/dash/DashHandler.js"],"names":["DashHandler","config","context","eventBus","events","debug","dashConstants","urlUtils","type","streamInfo","timelineConverter","dashMetrics","baseURLController","instance","logger","segmentIndex","lastSegment","requestedTime","isDynamicManifest","dynamicStreamCompleted","selectedMimeType","segmentsController","setup","getLogger","resetInitialSettings","create","on","INITIALIZATION_LOADED","onInitializationLoaded","SEGMENTS_LOADED","onSegmentsLoaded","REPRESENTATION_UPDATE_STARTED","onRepresentationUpdateStarted","DYNAMIC_STREAM_COMPLETED","onDynamicStreamCompleted","initialize","isDynamic","getType","getStreamInfo","setCurrentIndex","value","getCurrentIndex","resetIndex","reset","off","setRequestUrl","request","destination","representation","baseURL","resolve","path","url","serviceLocation","isRelative","generateInitRequest","mediaInfo","mediaType","FragmentRequest","period","adaptation","presentationStartTime","start","HTTPRequest","INIT_SEGMENT_TYPE","range","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","duration","quality","index","representationId","id","initialization","bandwidth","getInitRequest","setMimeType","newMimeType","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","eventObj","sender","processRepresentation","voRepresentation","hasInitialization","hasSegments","trigger","REPRESENTATION_UPDATE_COMPLETED","update","getRequestForSegment","segment","undefined","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","media","replacementNumber","replacementTime","MEDIA_SEGMENT_TYPE","mediaRange","startTime","timescale","wallStartTime","availabilityIdx","adaptationIndex","isMediaFinished","isFinished","availableSegmentsNumber","time","parseFloat","toFixed","endTime","getSegmentRequestForTime","options","segmentInfoType","idx","keepIdx","ignoreIsFinished","getSegmentByTime","finished","action","ACTION_COMPLETE","SEGMENT_TIMELINE","getNextSegmentRequest","indexToRequest","getSegmentByIndex","mediaStartTime","isEndlessMedia","isFinite","e","segments","error","fragments","count","i","len","s","seg","length","push","segmentAvailabilityRange","end","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"DashHandler.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport {HTTPRequest} from '../streaming/vo/metrics/HTTPRequest';\nimport FactoryMaker from '../core/FactoryMaker';\nimport {\n    replaceIDForTemplate,\n    unescapeDollarsInTemplate,\n    replaceTokenForTemplate,\n    getTimeBasedSegment\n} from './utils/SegmentsUtils';\n\nimport SegmentsController from './controllers/SegmentsController';\n\nfunction DashHandler(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const debug = config.debug;\n    const dashConstants = config.dashConstants;\n    const urlUtils = config.urlUtils;\n    const type = config.type;\n    const streamInfo = config.streamInfo;\n\n    const timelineConverter = config.timelineConverter;\n    const dashMetrics = config.dashMetrics;\n    const baseURLController = config.baseURLController;\n\n    let instance,\n        logger,\n        segmentIndex,\n        lastSegment,\n        requestedTime,\n        isDynamicManifest,\n        dynamicStreamCompleted,\n        selectedMimeType,\n        segmentsController;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n\n        segmentsController = SegmentsController(context).create(config);\n\n        eventBus.on(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.on(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.on(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n        eventBus.on(events.DYNAMIC_STREAM_COMPLETED, onDynamicStreamCompleted, instance);\n    }\n\n    function initialize(isDynamic) {\n        isDynamicManifest = isDynamic;\n        dynamicStreamCompleted = false;\n        segmentsController.initialize(isDynamic);\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function setCurrentIndex(value) {\n        segmentIndex = value;\n    }\n\n    function getCurrentIndex() {\n        return segmentIndex;\n    }\n\n    function resetIndex() {\n        segmentIndex = -1;\n        lastSegment = null;\n    }\n\n    function resetInitialSettings() {\n        resetIndex();\n        requestedTime = null;\n        segmentsController = null;\n        selectedMimeType = null;\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.off(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.off(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n        eventBus.off(events.DYNAMIC_STREAM_COMPLETED, onDynamicStreamCompleted, instance);\n    }\n\n    function setRequestUrl(request, destination, representation) {\n        const baseURL = baseURLController.resolve(representation.path);\n        let url,\n            serviceLocation;\n\n        if (!baseURL || (destination === baseURL.url) || (!urlUtils.isRelative(destination))) {\n            url = destination;\n        } else {\n            url = baseURL.url;\n            serviceLocation = baseURL.serviceLocation;\n\n            if (destination) {\n                url = urlUtils.resolve(destination, url);\n            }\n        }\n\n        if (urlUtils.isRelative(url)) {\n            return false;\n        }\n\n        request.url = url;\n        request.serviceLocation = serviceLocation;\n\n        return true;\n    }\n\n    function generateInitRequest(mediaInfo, representation, mediaType) {\n        const request = new FragmentRequest();\n        const period = representation.adaptation.period;\n        const presentationStartTime = period.start;\n\n        request.mediaType = mediaType;\n        request.type = HTTPRequest.INIT_SEGMENT_TYPE;\n        request.range = representation.range;\n        request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\n        request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\n        request.quality = representation.index;\n        request.mediaInfo = mediaInfo;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, representation.initialization, representation)) {\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', representation.bandwidth);\n            return request;\n        }\n    }\n\n    function getInitRequest(mediaInfo, representation) {\n        if (!representation) return null;\n        const request = generateInitRequest(mediaInfo, representation, getType());\n        return request;\n    }\n\n    function setMimeType(newMimeType) {\n        selectedMimeType = newMimeType;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function onRepresentationUpdateStarted(eventObj) {\n        if (eventObj.sender.getType() !== getType()) return;\n\n        processRepresentation(eventObj.representation);\n    }\n\n    function processRepresentation(voRepresentation) {\n        const hasInitialization = voRepresentation.hasInitialization();\n        const hasSegments = voRepresentation.hasSegments();\n\n        //if representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\n        //otherwise, it means that a request has to be made to get initialization and/or segments informations\n        if (hasInitialization && hasSegments) {\n            eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {\n                sender: instance,\n                representation: voRepresentation\n            });\n        } else {\n            segmentsController.update(voRepresentation, getType(), selectedMimeType, hasInitialization, hasSegments);\n        }\n    }\n\n    function getRequestForSegment(mediaInfo, segment) {\n        if (segment === null || segment === undefined) {\n            return null;\n        }\n\n        const request = new FragmentRequest();\n        const representation = segment.representation;\n        const bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\n        let url = segment.media;\n\n        url = replaceTokenForTemplate(url, 'Number', segment.replacementNumber);\n        url = replaceTokenForTemplate(url, 'Time', segment.replacementTime);\n        url = replaceTokenForTemplate(url, 'Bandwidth', bandwidth);\n        url = replaceIDForTemplate(url, representation.id);\n        url = unescapeDollarsInTemplate(url);\n\n        request.mediaType = getType();\n        request.type = HTTPRequest.MEDIA_SEGMENT_TYPE;\n        request.range = segment.mediaRange;\n        request.startTime = segment.presentationStartTime;\n        request.duration = segment.duration;\n        request.timescale = representation.timescale;\n        request.availabilityStartTime = segment.availabilityStartTime;\n        request.availabilityEndTime = segment.availabilityEndTime;\n        request.wallStartTime = segment.wallStartTime;\n        request.quality = representation.index;\n        request.index = segment.availabilityIdx;\n        request.mediaInfo = mediaInfo;\n        request.adaptationIndex = representation.adaptation.index;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, url, representation)) {\n            return request;\n        }\n    }\n\n    function isMediaFinished(representation) {\n        let isFinished = false;\n\n        if (!representation) return isFinished;\n\n        if (!isDynamicManifest) {\n            if (segmentIndex >= representation.availableSegmentsNumber) {\n                isFinished = true;\n            }\n        } else {\n            if (dynamicStreamCompleted) {\n                isFinished = true;\n            } else if (lastSegment) {\n                const time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\n                const endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\n                const duration = representation.adaptation.period.duration;\n\n                isFinished = endTime >= duration;\n            }\n        }\n        return isFinished;\n    }\n\n    function getSegmentRequestForTime(mediaInfo, representation, time, options) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return request;\n        }\n\n        const idx = segmentIndex;\n        const keepIdx = options ? options.keepIdx : false;\n        const ignoreIsFinished = (options && options.ignoreIsFinished) ? true : false;\n\n        if (requestedTime !== time) { // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\n            requestedTime = time;\n            logger.debug('Getting the request for time : ' + time);\n        }\n\n        const segment = segmentsController.getSegmentByTime(representation, time);\n        if (segment) {\n            segmentIndex = segment.availabilityIdx;\n            lastSegment = segment;\n            logger.debug('Index for time ' + time + ' is ' + segmentIndex);\n            request = getRequestForSegment(mediaInfo, segment);\n        } else {\n            const finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = type;\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete in getSegmentRequestForTime');\n            }\n        }\n\n        if (keepIdx && idx >= 0) {\n            segmentIndex = representation.segmentInfoType === dashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\n        }\n\n        return request;\n    }\n\n    function getNextSegmentRequest(mediaInfo, representation) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return null;\n        }\n\n        requestedTime = null;\n\n        let indexToRequest = segmentIndex + 1;\n\n        logger.debug('Getting the next request at index: ' + indexToRequest);\n        // check that there is a segment in this index\n        const segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n        if (!segment && isEndlessMedia(representation) && !dynamicStreamCompleted) {\n            logger.debug(getType() + ' No segment found at index: ' + indexToRequest + '. Wait for next loop');\n            return null;\n        } else {\n            if (segment) {\n                request = getRequestForSegment(mediaInfo, segment);\n                segmentIndex = segment.availabilityIdx;\n            } else {\n                if (isDynamicManifest) {\n                    segmentIndex = indexToRequest - 1;\n                } else {\n                    segmentIndex = indexToRequest;\n                }\n            }\n        }\n\n        if (segment) {\n            lastSegment = segment;\n        } else {\n            const finished = isMediaFinished(representation, segment);\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = getType();\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete');\n            }\n        }\n\n        return request;\n    }\n\n    function isEndlessMedia(representation) {\n        return !isFinite(representation.adaptation.period.duration);\n    }\n\n    function onInitializationLoaded(e) {\n        const representation = e.representation;\n        if (!representation.segments) return;\n\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {sender: this, representation: representation});\n    }\n\n    function onSegmentsLoaded(e) {\n        if (e.error || (getType() !== e.mediaType)) return;\n\n        const fragments = e.segments;\n        const representation = e.representation;\n        const segments = [];\n        let count = 0;\n\n        let i,\n            len,\n            s,\n            seg;\n\n        for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\n            s = fragments[i];\n\n            seg = getTimeBasedSegment(\n                timelineConverter,\n                isDynamicManifest,\n                representation,\n                s.startTime,\n                s.duration,\n                s.timescale,\n                s.media,\n                s.mediaRange,\n                count);\n\n            if (seg) {\n                segments.push(seg);\n                seg = null;\n                count++;\n            }\n        }\n\n        if (segments.length > 0) {\n            representation.segmentAvailabilityRange = {\n                start: segments[0].presentationStartTime,\n                end: segments[segments.length - 1].presentationStartTime\n            };\n            representation.availableSegmentsNumber = segments.length;\n            representation.segments = segments;\n\n            if (isDynamicManifest) {\n                const lastSegment = segments[segments.length - 1];\n                const liveEdge = lastSegment.presentationStartTime - 8;\n                // the last segment is the Expected, not calculated, live edge.\n                setExpectedLiveEdge(liveEdge);\n            }\n        }\n\n        if (!representation.hasInitialization()) {\n            return;\n        }\n\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {sender: this, representation: representation});\n    }\n\n    function onDynamicStreamCompleted() {\n        logger.debug('Dynamic stream complete');\n        dynamicStreamCompleted = true;\n    }\n\n    instance = {\n        initialize: initialize,\n        getType: getType, //need to be public in order to be used by logger\n        getStreamInfo: getStreamInfo,\n        getInitRequest: getInitRequest,\n        getRequestForSegment: getRequestForSegment,\n        getSegmentRequestForTime: getSegmentRequestForTime,\n        getNextSegmentRequest: getNextSegmentRequest,\n        setCurrentIndex: setCurrentIndex,\n        getCurrentIndex: getCurrentIndex,\n        isMediaFinished: isMediaFinished,\n        reset: reset,\n        resetIndex: resetIndex,\n        setMimeType: setMimeType\n    };\n\n    setup();\n\n    return instance;\n}\n\nDashHandler.__dashjs_factory_name = 'DashHandler';\nexport default FactoryMaker.getClassFactory(DashHandler);\n"]}
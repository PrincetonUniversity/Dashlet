{"version":3,"sources":["../../../../../src/dash/controllers/RepresentationController.js"],"names":["RepresentationController","config","eventBus","events","errors","abrController","dashMetrics","playbackController","timelineConverter","type","streamId","dashConstants","instance","realAdaptation","updating","voAvailableRepresentations","currentVoRepresentation","setup","resetInitialSettings","on","QUALITY_CHANGE_REQUESTED","onQualityChanged","REPRESENTATION_UPDATE_COMPLETED","onRepresentationUpdated","WALLCLOCK_TIME_UPDATED","onWallclockTimeUpdated","MANIFEST_VALIDITY_CHANGED","onManifestValidityChanged","checkConfig","Error","Constants","MISSING_CONFIG_ERROR","getData","isUpdating","getCurrentRepresentation","reset","off","getType","getStreamId","updateData","newRealAdaptation","availableRepresentations","quality","startDataUpdate","getRepresentationForQuality","VIDEO","AUDIO","FRAGMENTED_TEXT","endDataUpdate","updateAvailabilityWindow","getIsDynamic","addRepresentationSwitch","now","Date","currentRepresentation","currentVideoTimeMs","getTime","adaptation","id","undefined","length","getQualityForRepresentation","voRepresentation","indexOf","isAllRepresentationsUpdated","i","ln","segmentInfoType","segmentAvailabilityRange","hasInitialization","SEGMENT_BASE","BASE_URL","segments","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","presentationStartTime","updateRepresentation","representation","isDynamic","calcSegmentAvailabilityRange","end","start","error","DashJSError","SEGMENTS_UNAVAILABLE_ERROR_CODE","SEGMENTS_UNAVAILABLE_ERROR_MESSAGE","availabilityDelay","notifyUpdate","trigger","REPRESENTATION_UPDATE_STARTED","sender","resetAvailabilityWindow","forEach","rep","DATA_UPDATE_STARTED","eventArg","data","DATA_UPDATE_COMPLETED","postponeUpdate","postponeTimePeriod","delay","update","AST_IN_FUTURE","setTimeout","e","getStreamInfo","streamInfo","r","manifestUpdateInfo","getCurrentManifestUpdate","alreadyAdded","repInfo","err","repSwitch","period","mpd","manifest","DYNAMIC","ignorePostponeTimePeriod","getStreamController","getStreams","getRepresentationUpdatePostponeTimePeriod","SEGMENTS_UPDATE_FAILED_ERROR_CODE","SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE","representationInfo","index","mediaType","addManifestUpdateRepresentationInfo","setPlaybackQuality","latency","getCurrentRepresentationSwitch","streamController","activeStreamInfo","getActiveStreamInfo","startTimeAnchor","Math","min","segmentAvailabilityTimePeriod","liveDelay","getLiveDelay","newQuality","newDuration","duration","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"RepresentationController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../../streaming/constants/Constants';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction RepresentationController(config) {\n\n    config = config || {};\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const errors = config.errors;\n    const abrController = config.abrController;\n    const dashMetrics = config.dashMetrics;\n    const playbackController = config.playbackController;\n    const timelineConverter = config.timelineConverter;\n    const type = config.type;\n    const streamId = config.streamId;\n    const dashConstants = config.dashConstants;\n\n    let instance,\n        realAdaptation,\n        updating,\n        voAvailableRepresentations,\n        currentVoRepresentation;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.on(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n        eventBus.on(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n        eventBus.on(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n    }\n\n    function checkConfig() {\n        if (!abrController || !dashMetrics || !playbackController || !timelineConverter) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function getData() {\n        return realAdaptation;\n    }\n\n    function isUpdating() {\n        return updating;\n    }\n\n    function getCurrentRepresentation() {\n        return currentVoRepresentation;\n    }\n\n    function resetInitialSettings() {\n        realAdaptation = null;\n        updating = true;\n        voAvailableRepresentations = [];\n    }\n\n    function reset() {\n\n        eventBus.off(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.off(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n        eventBus.off(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n        eventBus.off(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n\n        resetInitialSettings();\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamId() {\n        return streamId;\n    }\n\n    function updateData(newRealAdaptation, availableRepresentations, type, quality) {\n        checkConfig();\n\n        startDataUpdate();\n\n        voAvailableRepresentations = availableRepresentations;\n\n        currentVoRepresentation = getRepresentationForQuality(quality);\n        realAdaptation = newRealAdaptation;\n\n        if (type !== Constants.VIDEO && type !== Constants.AUDIO && type !== Constants.FRAGMENTED_TEXT) {\n            endDataUpdate();\n            return;\n        }\n\n        updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n    }\n\n    function addRepresentationSwitch() {\n        checkConfig();\n        const now = new Date();\n        const currentRepresentation = getCurrentRepresentation();\n        const currentVideoTimeMs = playbackController.getTime() * 1000;\n        if (currentRepresentation) {\n            dashMetrics.addRepresentationSwitch(currentRepresentation.adaptation.type, now, currentVideoTimeMs, currentRepresentation.id);\n        }\n    }\n\n    function getRepresentationForQuality(quality) {\n        return quality === null || quality === undefined || quality >= voAvailableRepresentations.length ? null : voAvailableRepresentations[quality];\n    }\n\n    function getQualityForRepresentation(voRepresentation) {\n        return voAvailableRepresentations.indexOf(voRepresentation);\n    }\n\n    function isAllRepresentationsUpdated() {\n        for (let i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n            let segmentInfoType = voAvailableRepresentations[i].segmentInfoType;\n            if (voAvailableRepresentations[i].segmentAvailabilityRange === null || !voAvailableRepresentations[i].hasInitialization() ||\n                ((segmentInfoType === dashConstants.SEGMENT_BASE || segmentInfoType === dashConstants.BASE_URL) && !voAvailableRepresentations[i].segments)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function updateRepresentation(representation, isDynamic) {\n        representation.segmentAvailabilityRange = timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);\n\n        if (representation.segmentAvailabilityRange.end < representation.segmentAvailabilityRange.start) {\n            let error = new DashJSError(errors.SEGMENTS_UNAVAILABLE_ERROR_CODE, errors.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE, {availabilityDelay: representation.segmentAvailabilityRange.start - representation.segmentAvailabilityRange.end});\n            endDataUpdate(error);\n            return;\n        }\n\n        if (isDynamic) {\n            setExpectedLiveEdge(representation.segmentAvailabilityRange.end);\n        }\n    }\n\n    function updateAvailabilityWindow(isDynamic, notifyUpdate) {\n        checkConfig();\n\n        for (let i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n            updateRepresentation(voAvailableRepresentations[i], isDynamic);\n            if (notifyUpdate) {\n                eventBus.trigger(events.REPRESENTATION_UPDATE_STARTED, {\n                    sender: instance,\n                    representation: voAvailableRepresentations[i]\n                });\n            }\n        }\n    }\n\n    function resetAvailabilityWindow() {\n        voAvailableRepresentations.forEach(rep => {\n            rep.segmentAvailabilityRange = null;\n        });\n    }\n\n    function startDataUpdate() {\n        updating = true;\n        eventBus.trigger(events.DATA_UPDATE_STARTED, {sender: instance});\n    }\n\n    function endDataUpdate(error) {\n        updating = false;\n        let eventArg = {sender: instance, data: realAdaptation, currentRepresentation: currentVoRepresentation};\n        if (error) {\n            eventArg.error = error;\n        }\n        eventBus.trigger(events.DATA_UPDATE_COMPLETED, eventArg);\n    }\n\n    function postponeUpdate(postponeTimePeriod) {\n        let delay = postponeTimePeriod;\n        let update = function () {\n            if (isUpdating()) return;\n\n            startDataUpdate();\n\n            // clear the segmentAvailabilityRange for all reps.\n            // this ensures all are updated before the live edge search starts\n            resetAvailabilityWindow();\n\n            updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n        };\n        eventBus.trigger(events.AST_IN_FUTURE, {delay: delay});\n        setTimeout(update, delay);\n    }\n\n    function onRepresentationUpdated(e) {\n        if (e.sender.getType() !== getType() || e.sender.getStreamInfo().id !== streamId || !isUpdating()) return;\n\n        if (e.error) {\n            endDataUpdate(e.error);\n            return;\n        }\n\n        let streamInfo = e.sender.getStreamInfo();\n        let r = e.representation;\n        let manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate();\n        let alreadyAdded = false;\n        let postponeTimePeriod = 0;\n        let repInfo,\n            err,\n            repSwitch;\n\n        if (r.adaptation.period.mpd.manifest.type === dashConstants.DYNAMIC && !r.adaptation.period.mpd.manifest.ignorePostponeTimePeriod && playbackController.getStreamController().getStreams().length <= 1) {\n            // We must put things to sleep unless till e.g. the startTime calculation in ScheduleController.onLiveEdgeSearchCompleted fall after the segmentAvailabilityRange.start\n            postponeTimePeriod = getRepresentationUpdatePostponeTimePeriod(r, streamInfo);\n        }\n\n        if (postponeTimePeriod > 0) {\n            postponeUpdate(postponeTimePeriod);\n            err = new DashJSError(errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE, errors.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE);\n            endDataUpdate(err);\n            return;\n        }\n\n        if (manifestUpdateInfo) {\n            for (let i = 0; i < manifestUpdateInfo.representationInfo.length; i++) {\n                repInfo = manifestUpdateInfo.representationInfo[i];\n                if (repInfo.index === r.index && repInfo.mediaType === getType()) {\n                    alreadyAdded = true;\n                    break;\n                }\n            }\n\n            if (!alreadyAdded) {\n                dashMetrics.addManifestUpdateRepresentationInfo(r, getType());\n            }\n        }\n\n        if (isAllRepresentationsUpdated()) {\n            abrController.setPlaybackQuality(getType(), streamInfo, getQualityForRepresentation(currentVoRepresentation));\n            dashMetrics.updateManifestUpdateInfo({latency: currentVoRepresentation.segmentAvailabilityRange.end - playbackController.getTime()});\n\n            repSwitch = dashMetrics.getCurrentRepresentationSwitch(getCurrentRepresentation().adaptation.type);\n\n            if (!repSwitch) {\n                addRepresentationSwitch();\n            }\n            endDataUpdate();\n        }\n    }\n\n    function getRepresentationUpdatePostponeTimePeriod(representation, streamInfo) {\n        try {\n            const streamController = playbackController.getStreamController();\n            const activeStreamInfo = streamController.getActiveStreamInfo();\n            let startTimeAnchor = representation.segmentAvailabilityRange.start;\n\n            if (activeStreamInfo && activeStreamInfo.id && activeStreamInfo.id !== streamInfo.id) {\n                // We need to consider the currently playing period if a period switch is performed.\n                startTimeAnchor = Math.min(playbackController.getTime(), startTimeAnchor);\n            }\n\n            let segmentAvailabilityTimePeriod = representation.segmentAvailabilityRange.end - startTimeAnchor;\n            let liveDelay = playbackController.getLiveDelay();\n\n            return (liveDelay - segmentAvailabilityTimePeriod) * 1000;\n        } catch (e) {\n            return 0;\n        }\n    }\n\n    function onWallclockTimeUpdated(e) {\n        if (e.isDynamic) {\n            updateAvailabilityWindow(e.isDynamic);\n        }\n    }\n\n    function onQualityChanged(e) {\n        if (e.mediaType !== getType() || streamId !== e.streamInfo.id) return;\n\n        currentVoRepresentation = getRepresentationForQuality(e.newQuality);\n        addRepresentationSwitch();\n    }\n\n    function onManifestValidityChanged(e) {\n        if (e.newDuration) {\n            const representation = getCurrentRepresentation();\n            if (representation && representation.adaptation.period) {\n                const period = representation.adaptation.period;\n                period.duration = e.newDuration;\n            }\n        }\n    }\n\n    instance = {\n        getData: getData,\n        isUpdating: isUpdating,\n        updateData: updateData,\n        updateRepresentation: updateRepresentation,\n        getCurrentRepresentation: getCurrentRepresentation,\n        getRepresentationForQuality: getRepresentationForQuality,\n        getType: getType,\n        getStreamId: getStreamId,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nRepresentationController.__dashjs_factory_name = 'RepresentationController';\nexport default FactoryMaker.getClassFactory(RepresentationController);\n"]}
{"version":3,"sources":["../../../../../src/offline/controllers/OfflineController.js"],"names":["OfflineController","config","context","errHandler","events","errors","settings","eventBus","debug","manifestLoader","manifestModel","mediaPlayerModel","abrController","playbackController","dashMetrics","timelineConverter","adapter","manifestUpdater","baseURLController","schemeLoaderFactory","constants","dashConstants","urlUtils","instance","downloads","logger","offlineStoreController","offlineUrlUtils","setup","getLogger","create","getInstance","registerUrlRegex","getRegex","registerLoader","OfflineConstants","OFFLINE_SCHEME","IndexDBOfflineLoader","getDownloadFromId","id","download","find","item","getId","createDownloadFromId","push","createDownloadFromStorage","offline","manifestId","status","OFFLINE_STATUS_STARTED","OFFLINE_STATUS_STOPPED","setInitialState","url","progress","originalUrl","originalURL","removeDownloadFromId","Promise","resolve","reject","waitForStatusChanged","isDownloading","downloadStopped","off","OFFLINE_RECORD_STOPPED","deleteDownloadById","then","catch","err","on","deleteDownload","index","indexOf","splice","generateManifestId","timestamp","Date","getTime","loadRecordsFromStorage","getAllManifests","items","manifests","forEach","e","error","getAllRecords","records","record","OfflineRecord","getDownloadProgression","getOfflineUrl","getManifestUrl","getStatus","createRecord","manifestURL","downloadFromUrl","initDownload","startRecord","mediaInfos","startDownload","stopRecord","stopDownload","resumeRecord","resumeDownload","deleteRecord","getRecordProgression","resetRecords","resetDownload","reset","unregisterLoader","__dashjs_factory_name","factory","dashjs","FactoryMaker","getClassFactory","OfflineEvents","OfflineErrors","updateClassFactory"],"mappings":"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","file":"OfflineController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport OfflineConstants from '../constants/OfflineConstants';\nimport OfflineStoreController from './OfflineStoreController';\nimport OfflineDownload from '../OfflineDownload';\nimport IndexDBOfflineLoader from '../net/IndexDBOfflineLoader';\nimport OfflineUrlUtils from '../utils/OfflineUrlUtils';\nimport OfflineEvents from '../events/OfflineEvents';\nimport OfflineErrors from '../errors/OfflineErrors';\nimport OfflineRecord from '../vo/OfflineDownloadVo';\n\n/**\n * @module OfflineController\n * @param {Object} config - dependencies\n * @description Provides access to offline stream recording and playback functionality.\n */\nfunction OfflineController(config) {\n\n    const context = this.context;\n    const errHandler = config.errHandler;\n    const events = config.events;\n    const errors = config.errors;\n    const settings = config.settings;\n    const eventBus = config.eventBus;\n    const debug = config.debug;\n    const manifestLoader = config.manifestLoader;\n    const manifestModel = config.manifestModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const dashMetrics = config.dashMetrics;\n    const timelineConverter = config.timelineConverter;\n    const adapter = config.adapter;\n    const manifestUpdater = config.manifestUpdater;\n    const baseURLController = config.baseURLController;\n    const schemeLoaderFactory = config.schemeLoaderFactory;\n    const constants = config.constants;\n    const dashConstants = config.dashConstants;\n    const urlUtils = config.urlUtils;\n\n    let instance,\n        downloads,\n        logger,\n        offlineStoreController,\n        offlineUrlUtils;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        offlineStoreController = OfflineStoreController(context).create({\n            eventBus: config.eventBus,\n            errHandler: errHandler\n        });\n        offlineUrlUtils = OfflineUrlUtils(context).getInstance();\n        urlUtils.registerUrlRegex(offlineUrlUtils.getRegex(), offlineUrlUtils);\n        schemeLoaderFactory.registerLoader(OfflineConstants.OFFLINE_SCHEME, IndexDBOfflineLoader);\n\n        downloads = [];\n    }\n\n    /*\n    ---------------------------------------------------------------------------\n        DOWNLOAD LIST FUNCTIONS\n    ---------------------------------------------------------------------------\n    */\n    function getDownloadFromId(id) {\n        let download = downloads.find((item) => {\n            return item.getId() === id;\n        });\n        return download;\n    }\n\n    function createDownloadFromId(id) {\n        let download;\n        download = getDownloadFromId(id);\n\n        if (!download) {\n            // create download controller\n            download = OfflineDownload(context).create({\n                id: id,\n                eventBus: eventBus,\n                events: events,\n                errors: errors,\n                settings: settings,\n                manifestLoader: manifestLoader,\n                manifestModel: manifestModel,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestUpdater: manifestUpdater,\n                baseURLController: baseURLController,\n                abrController: abrController,\n                playbackController: playbackController,\n                adapter: adapter,\n                dashMetrics: dashMetrics,\n                timelineConverter: timelineConverter,\n                errHandler: errHandler,\n                offlineStoreController: offlineStoreController,\n                debug: debug,\n                constants: constants,\n                dashConstants: dashConstants,\n                urlUtils: urlUtils\n            });\n\n            downloads.push(download);\n        }\n\n        return download;\n    }\n\n    function createDownloadFromStorage(offline) {\n        let download = getDownloadFromId(offline.manifestId);\n\n        if (!download) {\n            download = createDownloadFromId(offline.manifestId);\n            let status = offline.status;\n            if (status === OfflineConstants.OFFLINE_STATUS_STARTED) {\n                status = OfflineConstants.OFFLINE_STATUS_STOPPED;\n            }\n\n            download.setInitialState({\n                url: offline.url,\n                progress: offline.progress,\n                originalUrl: offline.originalURL,\n                status: status\n            });\n        }\n\n        return download;\n    }\n\n    function removeDownloadFromId(id) {\n        return new Promise(function (resolve, reject) {\n            let download = getDownloadFromId(id);\n            let waitForStatusChanged = false;\n            if (download) {\n                //is download running?\n                if (download.isDownloading()) {\n                    //register status changed event\n                    waitForStatusChanged = true;\n                    const downloadStopped = function () {\n                        eventBus.off(events.OFFLINE_RECORD_STOPPED, downloadStopped, instance);\n                        return offlineStoreController.deleteDownloadById(id).then(function () {\n                            resolve();\n                        }).catch(function (err) {\n                            reject(err);\n                        });\n                    };\n                    eventBus.on(events.OFFLINE_RECORD_STOPPED, downloadStopped, instance);\n                }\n                download.deleteDownload();\n                let index = downloads.indexOf(download);\n                downloads.splice(index, 1);\n            }\n\n            if (!waitForStatusChanged) {\n                resolve();\n            }\n        });\n    }\n\n    function generateManifestId() {\n        let timestamp = new Date().getTime();\n        return timestamp;\n    }\n\n    /*\n    ---------------------------------------------------------------------------\n\n        OFFLINE CONTROLLER API\n\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Loads records from storage\n     * This methods has to be called first, to be sure that all downloads have been loaded\n     *\n     * @return {Promise} asynchronously resolved\n     * @memberof module:OfflineController\n     */\n    function loadRecordsFromStorage() {\n        return new Promise(function (resolve, reject) {\n            offlineStoreController.getAllManifests().then((items) => {\n                items.manifests.forEach((offline) => {\n                    createDownloadFromStorage(offline);\n                });\n\n                resolve();\n            }).catch((e) => {\n                logger.error('Failed to load downloads ' + e);\n                reject(e);\n            });\n        });\n    }\n\n    /**\n     * Get all records from storage\n     *\n     * @return {Promise} asynchronously resolved with records\n     * @memberof module:OfflineController\n     * @instance\n     */\n    function getAllRecords() {\n        let records = [];\n        downloads.forEach((download) => {\n            const record = new OfflineRecord();\n            record.id = download.getId();\n            record.progress = download.getDownloadProgression();\n            record.url = download.getOfflineUrl();\n            record.originalUrl = download.getManifestUrl();\n            record.status = download.getStatus();\n            records.push(record);\n        });\n        return records;\n    }\n\n    /**\n     * Create a new content record in storage and download manifest from url\n     *\n     * @param {string} manifestURL - the content manifest url\n     * @return {Promise} asynchronously resolved with record identifier\n     * @memberof module:OfflineController\n     * @instance\n     */\n    function createRecord(manifestURL) {\n        return new Promise(function (resolve, reject) {\n            let id = generateManifestId();\n\n            // create download controller\n            let download = createDownloadFromId(id);\n\n            download.downloadFromUrl(manifestURL).then(() => {\n                download.initDownload();\n                resolve(id);\n            })\n            .catch((e) => {\n                logger.error('Failed to download ' + e);\n                removeDownloadFromId(id).then(function () {\n                    reject(e);\n                });\n            });\n        });\n    }\n\n    /**\n     * Start downloading the record with selected tracks representations\n     *\n     * @param {string} id - record identifier\n     * @param {MediaInfo[]} mediaInfos - the selected tracks representations\n     * @memberof module:OfflineController\n     * @instance\n     */\n    function startRecord(id, mediaInfos) {\n        let download = getDownloadFromId(id);\n        if (download) {\n            download.startDownload(mediaInfos);\n        }\n    }\n\n    /**\n     * Stop downloading of the record\n     *\n     * @param {string} id - record identifier\n     * @memberof module:OfflineController\n     * @instance\n     */\n    function stopRecord(id) {\n        let download = getDownloadFromId(id);\n        if (download) {\n            download.stopDownload();\n        }\n    }\n\n    /**\n     * Resume downloading of the record\n     *\n     * @param {string} id - record identifier\n     * @memberof module:OfflineController\n     * @instance\n     */\n    function resumeRecord(id) {\n        let download = getDownloadFromId(id);\n        if (download) {\n            download.resumeDownload();\n        }\n    }\n\n    /**\n     * Deletes a record from storage\n     *\n     * @param {string} id - record identifier\n     * @memberof module:OfflineController\n     * @instance\n     */\n    function deleteRecord(id) {\n        return removeDownloadFromId(id).then(function () {\n            return offlineStoreController.deleteDownloadById(id);\n        });\n    }\n\n\n    /**\n     * Get download progression of a record\n     *\n     * @param {string} id - record identifier\n     * @return {number} percentage progression\n     * @memberof module:OfflineController\n     * @instance\n     */\n    function getRecordProgression(id) {\n        let download = getDownloadFromId(id);\n        if (download) {\n            return download.getDownloadProgression();\n        }\n        return 0;\n    }\n\n    /**\n     * Reset all records\n     * @memberof module:OfflineController\n     * @instance\n     */\n    function resetRecords() {\n        downloads.forEach((download) => {\n            download.resetDownload();\n        });\n    }\n\n    /**\n     * Reset\n     * @instance\n     */\n    function reset() {\n        resetRecords();\n        schemeLoaderFactory.unregisterLoader(OfflineConstants.OFFLINE_SCHEME);\n    }\n\n    instance = {\n        loadRecordsFromStorage: loadRecordsFromStorage,\n        createRecord: createRecord,\n        startRecord: startRecord,\n        stopRecord: stopRecord,\n        resumeRecord: resumeRecord,\n        deleteRecord: deleteRecord,\n        getRecordProgression: getRecordProgression,\n        getAllRecords: getAllRecords,\n        resetRecords: resetRecords,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nOfflineController.__dashjs_factory_name = 'OfflineController';\nconst factory = dashjs.FactoryMaker.getClassFactory(OfflineController); /* jshint ignore:line */\nfactory.events = OfflineEvents;\nfactory.errors = OfflineErrors;\ndashjs.FactoryMaker.updateClassFactory(OfflineController.__dashjs_factory_name, factory); /* jshint ignore:line */\nexport default factory;\n"]}
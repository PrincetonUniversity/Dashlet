{"version":3,"sources":["../../../../src/offline/OfflineStreamProcessor.js"],"names":["OfflineStreamProcessor","config","context","eventBus","events","errors","debug","constants","settings","dashConstants","manifestId","id","type","streamInfo","errHandler","mediaPlayerModel","abrController","playbackController","adapter","dashMetrics","baseURLController","timelineConverter","bitrate","offlineStoreController","completedCb","callbacks","completed","progressCb","progression","instance","logger","mediaInfo","indexHandler","representationController","fragmentModel","updating","downloadedSegments","isInitialized","isStopped","setup","resetInitialSettings","getLogger","create","requestModifier","getInstance","urlUtils","streamId","fragmentLoader","on","STREAM_COMPLETED","onStreamCompleted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","initialize","_mediaInfo","updateRepresentation","isInitRequest","request","e","sender","isInit","suffix","index","fragmentName","representationId","storeFragment","response","then","setRepresentationCurrentState","downloaded","error","serviceLocation","executeRequest","download","info","stop","getRepresentationController","getRepresentationId","getCurrentRepresentation","removeExecutedRequestsBeforeTime","time","getInitRequest","getMediaInfo","getNextRequest","getNextSegmentRequest","start","Error","getRepresentationCurrentState","state","setCurrentIndex","catch","isNaN","updateProgression","url","voRepresentations","getVoRepresentations","quality","findIndex","representation","VIDEO","AUDIO","TEXT","FRAGMENTED_TEXT","updateData","isUpdating","getType","getAvailableSegmentsNumber","availableSegmentsNumber","reset","off","__dashjs_factory_name","factory","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineStreamProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashHandler from '../dash/DashHandler';\nimport RepresentationController from '../dash/controllers/RepresentationController';\nimport FragmentModel from '../streaming/models/FragmentModel';\nimport FragmentLoader from '../streaming/FragmentLoader';\nimport URLUtils from '../streaming/utils/URLUtils';\nimport RequestModifier from '../streaming/utils/RequestModifier';\n\n\nfunction OfflineStreamProcessor(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const errors = config.errors;\n    const debug = config.debug;\n    const constants = config.constants;\n    const settings = config.settings;\n    const dashConstants = config.dashConstants;\n    const manifestId = config.id;\n    const type = config.type;\n    const streamInfo = config.streamInfo;\n    const errHandler = config.errHandler;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const baseURLController = config.baseURLController;\n    const timelineConverter = config.timelineConverter;\n    const bitrate = config.bitrate;\n    const offlineStoreController = config.offlineStoreController;\n    const completedCb = config.callbacks && config.callbacks.completed;\n    const progressCb = config.callbacks && config.callbacks.progression;\n\n    let instance,\n        logger,\n        mediaInfo,\n        indexHandler,\n        representationController,\n        fragmentModel,\n        updating,\n        downloadedSegments,\n        isInitialized,\n        isStopped;\n\n    function setup() {\n        resetInitialSettings();\n        logger = debug.getLogger(instance);\n\n        indexHandler = DashHandler(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            timelineConverter: timelineConverter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            baseURLController: baseURLController,\n            errHandler: errHandler,\n            settings: settings,\n            // boxParser: boxParser,\n            eventBus: eventBus,\n            events: events,\n            debug: debug,\n            requestModifier: RequestModifier(context).getInstance(),\n            dashConstants: dashConstants,\n            constants: constants,\n            urlUtils: URLUtils(context).getInstance()\n        });\n\n        representationController = RepresentationController(context).create({\n            streamId: streamInfo.id,\n            type: type,\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            playbackController: playbackController,\n            timelineConverter: timelineConverter,\n            dashConstants: dashConstants,\n            events: events,\n            eventBus: eventBus,\n            errors: errors\n        });\n\n        fragmentModel = FragmentModel(context).create({\n            streamId: streamInfo.id,\n            dashMetrics: dashMetrics,\n            fragmentLoader: FragmentLoader(context).create({\n                dashMetrics: dashMetrics,\n                mediaPlayerModel: mediaPlayerModel,\n                errHandler: errHandler,\n                requestModifier: RequestModifier(context).getInstance(),\n                settings: settings,\n                eventBus: eventBus,\n                events: events,\n                errors: errors,\n                constants: constants,\n                dashConstants: dashConstants,\n                urlUtils: URLUtils(context).getInstance()\n            }),\n            debug: debug,\n            eventBus: eventBus,\n            events: events\n        });\n\n        eventBus.on(events.STREAM_COMPLETED, onStreamCompleted, instance);\n        eventBus.on(events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, instance);\n    }\n\n    function initialize(_mediaInfo) {\n        mediaInfo = _mediaInfo;\n        indexHandler.initialize(false);\n        updateRepresentation(mediaInfo);\n    }\n\n    function isInitRequest(request) {\n        return request.type === 'InitializationSegment';\n    }\n\n    function onFragmentLoadingCompleted(e) {\n        if (e.sender !== fragmentModel) {\n            return;\n        }\n\n        if (e.request !== null) {\n            let isInit = isInitRequest(e.request);\n            let suffix = isInit ? 'init' : e.request.index;\n            let fragmentName = e.request.representationId + '_' + suffix;\n            offlineStoreController.storeFragment(manifestId, fragmentName, e.response)\n            .then(() => {\n                if (!isInit) {\n                    // store current index and downloadedSegments number\n                    offlineStoreController.setRepresentationCurrentState(manifestId, e.request.representationId, {\n                        index: e.request.index,\n                        downloaded: downloadedSegments\n                    } );\n                }\n            });\n        }\n\n        if (e.error && e.request.serviceLocation && !isStopped) {\n            fragmentModel.executeRequest(e.request);\n        } else {\n            downloadedSegments++;\n            download();\n        }\n    }\n\n    function onStreamCompleted(e) {\n        if (e.fragmentModel !== fragmentModel) {\n            return;\n        }\n        logger.info(`[${manifestId}] Stream is complete`);\n        stop();\n        completedCb();\n    }\n\n    function getRepresentationController () {\n        return representationController;\n    }\n\n    function getRepresentationId() {\n        return representationController.getCurrentRepresentation().id;\n    }\n\n    /**\n     * Stops download of fragments\n     * @memberof OfflineStreamProcessor#\n     */\n    function stop() {\n        if (isStopped) {\n            return;\n        }\n        isStopped = true;\n    }\n\n\n    function removeExecutedRequestsBeforeTime(time) {\n        if (fragmentModel) {\n            fragmentModel.removeExecutedRequestsBeforeTime(time);\n        }\n    }\n\n    /**\n     * Execute init request for the represenation\n     * @memberof OfflineStreamProcessor#\n    */\n    function getInitRequest() {\n        if (!representationController.getCurrentRepresentation()) {\n            return null;\n        }\n\n        return indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation());\n    }\n\n    /**\n     * Get next request\n     * @memberof OfflineStreamProcessor#\n    */\n    function getNextRequest() {\n        return indexHandler.getNextSegmentRequest(getMediaInfo(), representationController.getCurrentRepresentation());\n    }\n\n    /**\n     * Start download\n     * @memberof OfflineStreamProcessor#\n    */\n    function start() {\n        if (representationController) {\n            if (!representationController.getCurrentRepresentation()) {\n                throw new Error('Start denied to OfflineStreamProcessor');\n            }\n            isStopped = false;\n\n            offlineStoreController.getRepresentationCurrentState(manifestId, representationController.getCurrentRepresentation().id)\n            .then((state) => {\n                if (state) {\n                    indexHandler.setCurrentIndex(state.index);\n                    downloadedSegments = state.downloaded;\n                }\n                download();\n            }).catch(() => {\n                // start from beginining\n                download();\n            });\n        }\n    }\n\n    /**\n     * Performs download of fragment according to type\n     * @memberof OfflineStreamProcessor#\n    */\n    function download() {\n        if (isStopped) {\n            return;\n        }\n\n        if (isNaN(representationController.getCurrentRepresentation())) {\n            let request = null;\n            if (!isInitialized) {\n                request = getInitRequest();\n                isInitialized = true;\n            } else {\n                request = getNextRequest();\n\n                // update progression : done here because availableSegmentsNumber is done in getNextRequest from dash handler\n                updateProgression();\n            }\n\n            if (request) {\n                logger.info(`[${manifestId}] download request : ${request.url}`);\n                fragmentModel.executeRequest(request);\n            } else {\n                logger.info(`[${manifestId}] no request to be downloaded`);\n            }\n        }\n    }\n\n    /**\n     * Update representation\n     * @param {Object} mediaInfo - mediaInfo\n     * @memberof OfflineStreamProcessor#\n     */\n    function updateRepresentation(mediaInfo) {\n        updating = true;\n\n        let voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n        // get representation VO according to id.\n        let quality = voRepresentations.findIndex((representation) => {\n            return representation.id === bitrate.id;\n        });\n\n        if (type !== constants.VIDEO && type !== constants.AUDIO  && type !== constants.TEXT && type !== constants.FRAGMENTED_TEXT) {\n            updating = false;\n            return;\n        }\n\n        representationController.updateData(null, voRepresentations, type, quality);\n    }\n\n    function isUpdating() {\n        return updating;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getMediaInfo() {\n        return mediaInfo;\n    }\n\n    function getAvailableSegmentsNumber() {\n        return representationController.getCurrentRepresentation().availableSegmentsNumber + 1; // do not forget init segment\n    }\n\n    function updateProgression () {\n        if (progressCb) {\n            progressCb(instance, downloadedSegments, getAvailableSegmentsNumber());\n        }\n    }\n\n    function resetInitialSettings() {\n        isInitialized = false;\n        downloadedSegments = 0;\n        updating = false;\n    }\n\n    /**\n     * Reset\n     * @memberof OfflineStreamProcessor#\n    */\n    function reset() {\n        resetInitialSettings();\n        indexHandler.reset();\n\n        eventBus.off(events.STREAM_COMPLETED, onStreamCompleted, instance);\n        eventBus.off(events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, instance);\n    }\n\n    instance = {\n        initialize: initialize,\n        getMediaInfo: getMediaInfo,\n        getRepresentationController: getRepresentationController,\n        removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime,\n        getType: getType,\n        getRepresentationId: getRepresentationId,\n        isUpdating: isUpdating,\n        start: start,\n        stop: stop,\n        getAvailableSegmentsNumber: getAvailableSegmentsNumber,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\nOfflineStreamProcessor.__dashjs_factory_name = 'OfflineStreamProcessor';\nconst factory = dashjs.FactoryMaker.getClassFactory(OfflineStreamProcessor); /* jshint ignore:line */\nexport default factory;\n"]}
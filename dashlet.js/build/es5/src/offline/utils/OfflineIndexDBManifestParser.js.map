{"version":3,"sources":["../../../../../src/offline/utils/OfflineIndexDBManifestParser.js"],"names":["Entities","require","XmlEntities","OFFLINE_BASE_URL","OfflineIndexDBManifestParser","config","manifestId","allMediaInfos","urlUtils","debug","dashConstants","constants","instance","DOM","logger","setup","getLogger","parse","XMLDoc","representation","Promise","resolve","reject","DOMParser","parseFromString","mpd","getElementsByTagName","MPD","i","length","editBaseURLAttribute","browsePeriods","manifestEncoded","encodeManifest","info","XMLSerializer","serializeToString","encode","currentMPD","basesURL","fragmentId","representationId","url","BASE_URL","element","createElement","innerHTML","appendChild","parent","parentNode","nodeName","REPRESENTATION","adaptationsSet","ADAPTATION_SET","isHTTPS","isHTTPURL","getFragmentId","getBestRepresentationId","periods","PERIOD","j","browseAdaptationsSet","currentPeriod","representationsToUpdate","currentAdaptationSet","currentAdaptationType","representations","findAdaptationType","findRepresentations","findAndKeepOnlySelectedRepresentations","deleteSegmentBase","removeChild","rep","segmentList","getSegmentList","editSegmentListAttributes","segmentTemplate","getSegmentTemplate","editSegmentTemplateAttributes","selectedRep","id","addSegmentTemplateAttributes","getIsMuxed","MUXED","getIsAudio","AUDIO","getIsVideo","VIDEO","getIsFragmentedText","FRAGMENTED_TEXT","getIsImage","IMAGE","TEXT","adaptation","getIsTypeOf","type","Error","isFragmentedTextCodecFound","testMimeType","mimeTypeRegEx","RegExp","mimeType","findMimeType","test","isFragmentedTextCodecFoundInTag","tag","codecs","getAttribute","CODECS","search","STPP","WVTT","MIME_TYPE","SEGMENT_TEMPLATE","SEGMENT_LIST","elements","SEGMENT_BASE","segmentBase","addSegmentTimelineElements","S","segments","segmentTimelineElement","SEGMENT_TIMELINE","changedDuration","getDurationChangeArray","repeatValue","setAttribute","duration","array","push","segmentsTemplates","media","MEDIA","substring","indexOf","START_NUMBER","INITIALIZATION_MINUS","segmentLists","repId","ID","initialisation","INITIALIZATION","sourceURL","SOURCE_URL","segmentURLs","SEGMENT_URL","segmentUrl","adaptationSet","segmentTemplateElement","adaptationType","bestRepresentation","console","log","idxFragId","lastIndexOf","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineIndexDBManifestParser.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst Entities = require('html-entities').XmlEntities;\nconst OFFLINE_BASE_URL = 'offline_indexeddb://';\n\nfunction OfflineIndexDBManifestParser(config) {\n\n    const manifestId = config.manifestId;\n    const allMediaInfos = config.allMediaInfos;\n    const urlUtils = config.urlUtils;\n    const debug = config.debug;\n    const dashConstants = config.dashConstants;\n    const constants = config.constants;\n\n    let instance,\n        DOM,\n        logger;\n\n\n    function setup() {\n        logger = debug.getLogger(instance);\n    }\n\n    /**\n     * Parse XML manifest\n     * @param {string} XMLDoc - xml manifest\n     * @param {object} representation\n     * @returns {Promise} a promise that will be resolved or rejected at the end of encoding process\n     * @instance\n    */\n    function parse(XMLDoc, representation) {\n        return new Promise(function (resolve, reject) {\n\n            DOM = new DOMParser().parseFromString(XMLDoc, 'application/xml');\n            let mpd = DOM.getElementsByTagName(dashConstants.MPD) ? DOM.getElementsByTagName(dashConstants.MPD) : null;\n\n            for (let i = 0; i < mpd.length; i++) {\n                if (mpd[i] !== null) {\n                    editBaseURLAttribute(mpd[i]);\n                    browsePeriods(mpd[i], representation);\n                }\n            }\n\n            let manifestEncoded = encodeManifest(DOM);\n            if (manifestEncoded !== '') {\n                resolve(manifestEncoded);\n            } else {\n                reject('Encoded error');\n            }\n        });\n    }\n\n    /**\n     * URL encode parsed manifest\n     * @param {string} DOM\n     * @returns {string} Url encoded XML\n     * @instance\n    */\n    function encodeManifest(DOM) {\n        logger.info('encodedManifest ' + new XMLSerializer().serializeToString(DOM));\n        return new Entities().encode(new XMLSerializer().serializeToString(DOM));\n    }\n\n    /**\n     * Update baseURL to point to local stored data P\n     * @param {XML} currentMPD\n     * @instance\n    */\n    function editBaseURLAttribute(currentMPD) {\n        let basesURL,\n            fragmentId,\n            representationId;\n\n        let url = `${OFFLINE_BASE_URL}${manifestId}/`;\n\n        basesURL = currentMPD.getElementsByTagName(dashConstants.BASE_URL);\n\n        if (basesURL.length === 0) {\n            // add baseURL\n            let element = DOM.createElement(dashConstants.BASE_URL);\n            element.innerHTML = url;\n            currentMPD.appendChild(element);\n        }\n        basesURL = currentMPD.getElementsByTagName(dashConstants.BASE_URL);\n        for (let i = 0; i < basesURL.length; i++) {\n            let parent = basesURL[i].parentNode;\n\n            if (parent.nodeName === dashConstants.MPD) {\n                basesURL[i].innerHTML = url;\n            } else if (parent.nodeName === dashConstants.REPRESENTATION) {\n                let adaptationsSet = parent.parentNode;\n                if (adaptationsSet.nodeName == dashConstants.ADAPTATION_SET) {\n\n                    if (urlUtils.isHTTPS(basesURL[i].innerHTML) || urlUtils.isHTTPURL(basesURL[i].innerHTML)) {\n                        fragmentId = getFragmentId(basesURL[i].innerHTML);\n                        representationId = getBestRepresentationId(adaptationsSet);\n                        basesURL[i].innerHTML = url + representationId + '_' + fragmentId;\n                    } else if (basesURL[i].innerHTML === './') {\n                        basesURL[i].innerHTML = url;\n                    } else {\n                        fragmentId = getFragmentId(basesURL[i].innerHTML);\n                        representationId = getBestRepresentationId(adaptationsSet);\n                        basesURL[i].innerHTML = representationId + '_' + fragmentId;\n                    }\n                }\n            } else {\n                basesURL[i].innerHTML = url;\n            }\n        }\n    }\n\n    /**\n     * Browse periods\n     * @param {XML} currentMPD\n     * @param {Object} representation\n     * @instance\n    */\n    function browsePeriods(currentMPD, representation) {\n        let periods = currentMPD.getElementsByTagName(dashConstants.PERIOD);\n        for (let j = 0; j < periods.length; j++) {\n            browseAdaptationsSet(periods[j], representation);\n        }\n    }\n\n    /**\n     * Browse adapatation set to update data (delete those taht are not choosen by user ...)\n     * @param {XML} currentPeriod\n     * @param {Array} representationsToUpdate\n     * @instance\n    */\n    function browseAdaptationsSet(currentPeriod, representationsToUpdate) {\n        let adaptationsSet,\n            currentAdaptationSet,\n            currentAdaptationType,\n            representations;\n\n        adaptationsSet = currentPeriod.getElementsByTagName(dashConstants.ADAPTATION_SET);\n\n        for (let i = adaptationsSet.length - 1; i >= 0; i--) {\n            currentAdaptationSet = adaptationsSet[i];\n            if (currentAdaptationSet) {\n                currentAdaptationType = findAdaptationType(currentAdaptationSet);\n                representations = findRepresentations(currentAdaptationSet);\n\n                findAndKeepOnlySelectedRepresentations(currentAdaptationSet, representations, currentAdaptationType);\n\n                representations = findRepresentations(currentAdaptationSet);\n\n                deleteSegmentBase(currentAdaptationSet);\n\n                if (representations.length === 0) {\n                    currentPeriod.removeChild(currentAdaptationSet);\n                } else {\n                    //detect Segment list use case\n                    for (let i = 0; i < representations.length; i++) {\n                        let rep = representations[i];\n                        let segmentList = getSegmentList(rep);\n                        if (segmentList.length >= 1) {\n                            editSegmentListAttributes(segmentList, rep);\n                        }\n                    }\n\n                    let segmentTemplate = getSegmentTemplate(currentAdaptationSet);\n                    // segmentTemplate is defined, update attributes in order to be correctly played offline\n                    if (segmentTemplate.length >= 1) {\n                        editSegmentTemplateAttributes(segmentTemplate);\n                    }\n\n                    // detect SegmentBase use case => transfrom manifest to SegmentList in SegmentTemplate\n                    if (representationsToUpdate && representationsToUpdate.length > 0 ) {\n                        let selectedRep;\n                        for (let i = 0; i < representations.length; i++) {\n                            let rep = representations[i];\n                            for (let j = 0; representationsToUpdate && j < representationsToUpdate.length; j++) {\n                                if (representationsToUpdate[j].id === rep.id) {\n                                    selectedRep = representationsToUpdate[j];\n                                    break;\n                                }\n                            }\n                        }\n                        addSegmentTemplateAttributes(currentAdaptationSet, selectedRep);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns type of adapation set\n     * @param {XML} currentAdaptationSet\n     * @returns {string|null} type\n     * @instance\n    */\n    function findAdaptationType(currentAdaptationSet) {\n        if (getIsMuxed(currentAdaptationSet)) {\n            return constants.MUXED;\n        } else if (getIsAudio(currentAdaptationSet)) {\n            return constants.AUDIO;\n        } else if (getIsVideo(currentAdaptationSet)) {\n            return constants.VIDEO;\n        } else if (getIsFragmentedText(currentAdaptationSet)) {\n            return constants.FRAGMENTED_TEXT;\n        } else if (getIsImage(currentAdaptationSet)) {\n            return constants.IMAGE;\n        }\n\n        return constants.TEXT;\n    }\n\n    function getIsAudio(adaptation) {\n        return getIsTypeOf(adaptation, constants.AUDIO);\n    }\n\n    function getIsVideo(adaptation) {\n        return getIsTypeOf(adaptation, constants.VIDEO);\n    }\n\n    function getIsFragmentedText(adaptation) {\n        return getIsTypeOf(adaptation, constants.FRAGMENTED_TEXT);\n    }\n\n    function getIsMuxed(adaptation) {\n        return getIsTypeOf(adaptation, constants.MUXED);\n    }\n\n    function getIsImage(adaptation) {\n        return getIsTypeOf(adaptation, constants.IMAGE);\n    }\n\n    // based upon DashManifestModel, but using DomParser\n    function getIsTypeOf(adaptation, type) {\n\n        if (!adaptation) {\n            throw new Error('adaptation is not defined');\n        }\n\n        if (!type) {\n            throw new Error('type is not defined');\n        }\n\n        // 1. check codecs for fragmented text\n        if (isFragmentedTextCodecFound(adaptation)) {\n            // fragmented text codec has been found for adaptation, let's check if tested type is fragmented text\n            return type === constants.FRAGMENTED_TEXT;\n        }\n\n        // 2. test mime type\n        return testMimeType(adaptation, type);\n    }\n\n    function testMimeType(adaptation, type) {\n        let mimeTypeRegEx = (type !== constants.TEXT) ? new RegExp(type) : new RegExp('(vtt|ttml)');\n\n        let mimeType = findMimeType(adaptation);\n        if (mimeType) {\n            return mimeTypeRegEx.test(mimeType);\n        }\n\n        // no mime type in adaptation, search in representation\n        let representations = findRepresentations(adaptation);\n        if (representations) {\n            for (let i = 0; i < representations.length; i++) {\n                let representation = representations[i];\n                mimeType = findMimeType(representation);\n                if (mimeType) {\n                    return mimeTypeRegEx.test(mimeType);\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Search for fragmented text codec in adaptation (STPP or WVTT)\n     * @param {Object} adaptation\n     */\n    function isFragmentedTextCodecFound (adaptation) {\n        let isFragmentedTextCodecFoundInTag = function (tag) {\n            let codecs = tag.getAttribute(dashConstants.CODECS);\n            if (codecs) {\n                if (codecs.search(constants.STPP) === 0 ||\n                    codecs.search(constants.WVTT) === 0 ) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        if (isFragmentedTextCodecFoundInTag(adaptation)) {\n            return true;\n        }\n\n        // check in representations\n        let representations = findRepresentations(adaptation);\n        if (representations && representations.length > 0) {\n\n            if (isFragmentedTextCodecFoundInTag(representations[0])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns mime-type of xml tag\n     * @param {Object} tag\n     * @returns {string|null} mimeType\n     * @instance\n    */\n    function findMimeType(tag) {\n        return tag.getAttribute(dashConstants.MIME_TYPE);\n    }\n\n    /**\n     * Returns representations of adaptation set\n     * @param {XML} adaptation\n     * @returns {XML} representations\n     * @instance\n    */\n    function findRepresentations(adaptation) {\n        return adaptation.getElementsByTagName(dashConstants.REPRESENTATION);\n    }\n\n    /**\n     * Return segment template list of adaptations set\n     * @param {XML} currentAdaptationSet\n     * @returns {XML} representations\n     * @instance\n    */\n    function getSegmentTemplate(currentAdaptationSet) {\n        return currentAdaptationSet.getElementsByTagName(dashConstants.SEGMENT_TEMPLATE);\n    }\n\n    /**\n     * Return segment list tags of adaptations set\n     * @param {XML} tag\n     * @returns {XML} representations\n     * @instance\n    */\n    function getSegmentList(tag) {\n        return tag.getElementsByTagName(dashConstants.SEGMENT_LIST);\n    }\n\n    function deleteSegmentBase(tag) {\n        let elements = tag.getElementsByTagName(dashConstants.SEGMENT_BASE);\n        for (let i = 0; i < elements.length; i++) {\n            let segmentBase = elements[i];\n            segmentBase.parentNode.removeChild(segmentBase);\n        }\n    }\n\n    /**\n     * @param {XML} segmentTemplate\n     * @param {object} rep\n     * @instance\n    */\n    function addSegmentTimelineElements(segmentTemplate, rep) {\n        let S = DOM.createElement('S');\n        if (rep && rep.segments) {\n            let segmentTimelineElement = DOM.createElement(dashConstants.SEGMENT_TIMELINE);\n            let changedDuration = getDurationChangeArray(rep);\n            for (let i = 0; i < changedDuration.length; i++) {\n                let repeatValue = i + 1 < changedDuration.length ? (changedDuration[i + 1] - changedDuration[i]) - 1 : 0;\n                if (repeatValue > 1) {\n                    S.setAttribute('r', repeatValue);\n                }\n                S.setAttribute('d', rep.segments[changedDuration[i]].duration);\n                segmentTimelineElement.appendChild(S);\n                S = DOM.createElement('S');\n            }\n            segmentTemplate.appendChild(segmentTimelineElement);\n        }\n    }\n\n    function getDurationChangeArray(rep) {\n        let array = [];\n        array.push(0);\n        for (let i = 1; i < rep.segments.length; i++) {\n            if (rep.segments[i - 1].duration !== rep.segments[i].duration) {\n                array.push(i);\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Update attributes of segment templates to match offline urls\n     * @param {Array} segmentsTemplates\n     * @instance\n    */\n    function editSegmentTemplateAttributes(segmentsTemplates) {\n        for (let i = 0; i < segmentsTemplates.length; i++) {\n            let media = segmentsTemplates[i].getAttribute(dashConstants.MEDIA);\n            media = '$RepresentationID$_$Number$' + media.substring(media.indexOf('.'), media.length); //id + extension\n            segmentsTemplates[i].setAttribute(dashConstants.START_NUMBER, '0');\n            segmentsTemplates[i].setAttribute(dashConstants.MEDIA, media);\n            segmentsTemplates[i].setAttribute(dashConstants.INITIALIZATION_MINUS,'$RepresentationID$_init');\n        }\n    }\n\n    /**\n     * Update attributes of segment list to match offline urls\n     * @param {Array} segmentLists\n     * @param {Object} representation\n     * @instance\n    */\n    function editSegmentListAttributes(segmentLists, representation) {\n        let repId = representation.getAttribute(dashConstants.ID);\n        for (let i = 0; i < segmentLists.length; i++) {\n\n            let segmentList = segmentLists[i];\n            let initialisation = segmentList.getElementsByTagName(dashConstants.INITIALIZATION);\n            if (initialisation) {\n                let sourceURL = initialisation[0].getAttribute(dashConstants.SOURCE_URL);\n                sourceURL = `${repId}_init`;\n                initialisation[0].setAttribute(dashConstants.SOURCE_URL, sourceURL);\n            }\n            let segmentURLs = segmentList.getElementsByTagName(dashConstants.SEGMENT_URL);\n\n            if (segmentURLs) {\n                for (let j = 0; j < segmentURLs.length; j++) {\n                    let segmentUrl = segmentURLs[j];\n                    let media = segmentUrl.getAttribute(dashConstants.MEDIA);\n                    media = `${repId}_${j}`;\n                    segmentUrl.setAttribute(dashConstants.MEDIA, media);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {XML} adaptationSet\n     * @param {object} rep\n     * @instance\n    */\n    function addSegmentTemplateAttributes(adaptationSet, rep) {\n        let segmentTemplateElement = DOM.createElement(dashConstants.SEGMENT_TEMPLATE);\n        segmentTemplateElement.setAttribute(dashConstants.START_NUMBER, '0');\n        segmentTemplateElement.setAttribute(dashConstants.MEDIA, '$RepresentationID$-$Time$');\n        segmentTemplateElement.setAttribute(dashConstants.INITIALIZATION_MINUS,'$RepresentationID$_init');\n        addSegmentTimelineElements(segmentTemplateElement, rep);\n        adaptationSet.appendChild(segmentTemplateElement);\n    }\n\n    /**\n     * Delete all representations except the one choosed by user\n     * @param {XML} currentAdaptationSet\n     * @param {XML} representations\n     * @param {string} adaptationType\n     * @instance\n    */\n    function findAndKeepOnlySelectedRepresentations(currentAdaptationSet, representations, adaptationType) {\n        for ( var i = representations.length - 1; i >= 0; i--) {\n            let representation = representations[i];\n            let repId = representation.getAttribute(dashConstants.ID);\n            if (allMediaInfos[adaptationType] && allMediaInfos[adaptationType].indexOf(repId) === -1) {\n                // representation is not selected, remove it\n                currentAdaptationSet.removeChild(representation);\n            }\n        }\n    }\n\n    //  UTILS\n    /**\n     * Get id of first representation of adaptation set\n     * @param {XMl} currentAdaptationSet\n     * @returns {string} id\n     * @instance\n    */\n    function getBestRepresentationId(currentAdaptationSet) {\n        let bestRepresentation = currentAdaptationSet.getElementsByTagName(dashConstants.REPRESENTATION)[0];\n        console.log(bestRepresentation.getAttribute(dashConstants.ID));\n        return bestRepresentation.getAttribute(dashConstants.ID);\n    }\n\n    /**\n     * Parse and returns fragments of offline url => xxxx://xxxx/fragmentId/\n     * @param {string} url\n     * @returns {string} fragmentId\n     * @instance\n    */\n    function getFragmentId(url) {\n        let idxFragId = url.lastIndexOf('/');\n        //logger.warn('fragId : ' + url.substring(idxFragId + 1, url.length));\n        return url.substring(idxFragId,url.length);\n    }\n\n    setup();\n\n    instance = {\n        parse: parse\n    };\n\n    return instance;\n}\nOfflineIndexDBManifestParser.__dashjs_factory_name = 'OfflineIndexDBManifestParser';\nexport default dashjs.FactoryMaker.getClassFactory(OfflineIndexDBManifestParser); /* jshint ignore:line */\n"]}
{"version":3,"sources":["../../../../src/offline/OfflineDownload.js"],"names":["OfflineDownload","config","context","manifestLoader","mediaPlayerModel","abrController","playbackController","adapter","dashMetrics","timelineConverter","offlineStoreController","manifestId","id","eventBus","errHandler","events","errors","settings","debug","manifestUpdater","baseURLController","constants","dashConstants","urlUtils","instance","logger","_manifestURL","_offlineURL","_xmlManifest","_streams","_manifest","_isDownloadingStatus","_isComposed","_representationsToUpdate","_indexDBManifestParser","_progressionById","_progression","_status","setup","getLogger","initialize","undefined","getId","getOfflineUrl","getManifestUrl","getStatus","setInitialState","state","url","progress","originalUrl","status","downloadFromUrl","OfflineConstants","OFFLINE_SCHEME","OFFLINE_STATUS_CREATED","setupOfflineEvents","offlineManifest","createOfflineManifest","initDownload","load","on","MANIFEST_UPDATED","onManifestUpdated","ORIGINAL_MANIFEST_LOADED","onOriginalManifestLoaded","setupIndexedDBEvents","ERROR","onError","isDownloading","e","error","manifest","err","OFFLINE_STATUS_ERROR","code","OfflineErrors","OFFLINE_ERROR","message","data","onDownloadingStarted","OFFLINE_STATUS_STARTED","setDownloadingStatus","then","trigger","OFFLINE_RECORD_STARTED","OnStreamProgression","stream","downloaded","available","getStreamInfo","segments","allSegments","waitForAllProgress","property","hasOwnProperty","getManifestById","item","updateOfflineManifest","onDownloadingFinished","OFFLINE_STATUS_FINISHED","OFFLINE_RECORD_FINISHED","resetDownload","onManifestUpdateNeeded","representations","length","parse","parsedManifest","i","ln","startOfflineStreamProcessors","catch","composeStreams","updatePeriods","streamsInfo","getStreamsInfo","streamInfo","create","callbacks","started","progression","finished","updateManifestNeeded","push","info","getMediaInfos","forEach","createFragmentStore","off","originalManifest","type","DYNAMIC","Period_asArray","STREAMS_COMPOSED","initializeAllMediasInfoList","selectedRepresentations","getSelectedRepresentations","mediaInfos","rep","VIDEO","AUDIO","TEXT","FRAGMENTED_TEXT","mediaInfo","bitrateList","bitrate","startDownload","saveSelectedRepresentations","generateOfflineManifest","allMediaInfos","originalURL","Promise","reject","stopDownload","stopOfflineStreamProcessors","OFFLINE_STATUS_STOPPED","OFFLINE_RECORD_STOPPED","sender","deleteDownload","resumeDownload","parser","selected","getDownloadProgression","Math","round","reset","resetIndexedDBEvents","INDEXEDDB_QUOTA_EXCEED_ERROR","INDEXEDDB_INVALID_STATE_ERROR","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineDownload.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport OfflineConstants from './constants/OfflineConstants';\nimport OfflineStream from './OfflineStream';\nimport OfflineIndexDBManifestParser from './utils/OfflineIndexDBManifestParser';\nimport OfflineErrors from './errors/OfflineErrors';\nimport DashParser from '../dash/parser/DashParser';\n\nfunction OfflineDownload(config) {\n    config = config || {};\n\n    const context = this.context;\n    const manifestLoader = config.manifestLoader;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const timelineConverter = config.timelineConverter;\n    const offlineStoreController = config.offlineStoreController;\n    const manifestId = config.id;\n    const eventBus = config.eventBus;\n    const errHandler = config.errHandler;\n    const events = config.events;\n    const errors = config.errors;\n    const settings = config.settings;\n    const debug = config.debug;\n    const manifestUpdater = config.manifestUpdater;\n    const baseURLController = config.baseURLController;\n    const constants = config.constants;\n    const dashConstants = config.dashConstants;\n    const urlUtils = config.urlUtils;\n\n    let instance,\n        logger,\n        _manifestURL,\n        _offlineURL,\n        _xmlManifest,\n        _streams,\n        _manifest,\n        _isDownloadingStatus,\n        _isComposed,\n        _representationsToUpdate,\n        _indexDBManifestParser,\n        _progressionById,\n        _progression,\n        _status;\n\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        manifestUpdater.initialize();\n        _streams = [];\n        _isDownloadingStatus = false;\n        _isComposed = false;\n        _progressionById = {};\n        _progression = 0;\n        _status = undefined;\n    }\n\n    function getId() {\n        return manifestId;\n    }\n\n    function getOfflineUrl () {\n        return _offlineURL;\n    }\n\n    function getManifestUrl () {\n        return _manifestURL;\n    }\n\n    function getStatus () {\n        return _status;\n    }\n\n    function setInitialState(state) {\n        _offlineURL = state.url;\n        _progression = state.progress;\n        _manifestURL = state.originalUrl;\n        _status = state.status;\n    }\n\n    /**\n     * Download a stream, from url of manifest\n     * @param {string} url\n     * @instance\n     */\n    function downloadFromUrl(url) {\n        _manifestURL = url;\n        _offlineURL = `${OfflineConstants.OFFLINE_SCHEME}://${manifestId}`;\n        _status = OfflineConstants.OFFLINE_STATUS_CREATED;\n        setupOfflineEvents();\n        let offlineManifest = {\n            'fragmentStore': manifestId,\n            'status': _status,\n            'manifestId': manifestId,\n            'url': _offlineURL,\n            'originalURL': url\n        };\n        return createOfflineManifest(offlineManifest);\n    }\n\n    function initDownload() {\n        manifestLoader.load(_manifestURL);\n        _isDownloadingStatus = true;\n    }\n\n    function setupOfflineEvents() {\n        eventBus.on(events.MANIFEST_UPDATED, onManifestUpdated, instance);\n        eventBus.on(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\n        setupIndexedDBEvents();\n    }\n\n    function setupIndexedDBEvents() {\n        eventBus.on(events.ERROR, onError, instance);\n    }\n\n    function isDownloading() {\n        return _isDownloadingStatus;\n    }\n\n    function onManifestUpdated(e) {\n        if (_isComposed) {\n            return;\n        }\n        if (!e.error) {\n            try {\n                _manifest = e.manifest;\n            } catch (err) {\n                _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n                errHandler.error({\n                    code: OfflineErrors.OFFLINE_ERROR,\n                    message: err.message,\n                    data: {\n                        id: manifestId,\n                        status: _status\n                    }\n                });\n            }\n        }\n    }\n\n    function onDownloadingStarted(e) {\n        if (e.id !== manifestId) {\n            return;\n        }\n        if (!e.error && manifestId !== null) {\n            _status = OfflineConstants.OFFLINE_STATUS_STARTED;\n            offlineStoreController.setDownloadingStatus(manifestId, _status).then(function () {\n                eventBus.trigger(events.OFFLINE_RECORD_STARTED, {id: manifestId, message: 'Downloading started for this stream !'});\n            });\n        } else {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: 'Cannot start download ',\n                data: {\n                    id: manifestId,\n                    status: _status,\n                    error: e.error\n                }\n            });\n        }\n    }\n\n    function OnStreamProgression(stream, downloaded, available) {\n\n        _progressionById[stream.getStreamInfo().id] = {\n            downloaded,\n            available\n        };\n\n        let segments = 0;\n        let allSegments = 0;\n        let waitForAllProgress;\n        for (var property in _progressionById) {\n            if (_progressionById.hasOwnProperty(property)) {\n                if (_progressionById[property] === null) {\n                    waitForAllProgress = true;\n                } else {\n                    segments += _progressionById[property].downloaded;\n                    allSegments += _progressionById[property].available;\n                }\n            }\n        }\n\n        if (!waitForAllProgress) {\n            // all progression have been started, we can compute global progression\n            _progression = segments / allSegments;\n\n            // store progression\n            offlineStoreController.getManifestById(manifestId)\n                .then((item) => {\n                    item.progress = _progression;\n                    return updateOfflineManifest(item);\n                });\n        }\n    }\n\n    function onDownloadingFinished(e) {\n        if (e.id !== manifestId) {\n            return;\n        }\n        if (!e.error && manifestId !== null) {\n            _status = OfflineConstants.OFFLINE_STATUS_FINISHED;\n            offlineStoreController.setDownloadingStatus(manifestId, _status)\n            .then(function () {\n                eventBus.trigger(events.OFFLINE_RECORD_FINISHED, {id: manifestId, message: 'Downloading has been successfully completed for this stream !'});\n                resetDownload();\n            });\n        } else {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: 'Error finishing download ',\n                data: {\n                    id: manifestId,\n                    status: _status,\n                    error: e.error\n                }\n            });\n        }\n    }\n\n    function onManifestUpdateNeeded(e) {\n        if (e.id !== manifestId) {\n            return;\n        }\n\n        _representationsToUpdate = e.representations;\n\n        if (_representationsToUpdate.length > 0) {\n            _indexDBManifestParser.parse(_xmlManifest, _representationsToUpdate).then(function (parsedManifest) {\n                if (parsedManifest !== null && manifestId !== null) {\n                    offlineStoreController.getManifestById(manifestId)\n                    .then((item) => {\n                        item.manifest = parsedManifest;\n                        return updateOfflineManifest(item);\n                    })\n                    .then( function () {\n                        for (let i = 0, ln = _streams.length; i < ln; i++) {\n                            _streams[i].startOfflineStreamProcessors();\n                        }\n                    });\n                } else {\n                    throw 'falling parsing offline manifest';\n                }\n            }).catch(function (err) {\n                throw err;\n            });\n        }\n    }\n\n    function composeStreams() {\n        try {\n            adapter.updatePeriods(_manifest);\n            baseURLController.initialize(_manifest);\n            const streamsInfo = adapter.getStreamsInfo();\n            if (streamsInfo.length === 0) {\n                _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n                errHandler.error({\n                    code: OfflineErrors.OFFLINE_ERROR,\n                    message: 'Cannot download - no streams',\n                    data: {\n                        id: manifestId,\n                        status: _status\n                    }\n                });\n            }\n            for (let i = 0, ln = streamsInfo.length; i < ln; i++) {\n                const streamInfo = streamsInfo[i];\n                let stream = OfflineStream(context).create({\n                    id: manifestId,\n                    callbacks: {\n                        started: onDownloadingStarted,\n                        progression: OnStreamProgression,\n                        finished: onDownloadingFinished,\n                        updateManifestNeeded: onManifestUpdateNeeded\n                    },\n                    constants: constants,\n                    dashConstants: dashConstants,\n                    eventBus: eventBus,\n                    events: events,\n                    errors: errors,\n                    settings: settings,\n                    debug: debug,\n                    errHandler: errHandler,\n                    mediaPlayerModel: mediaPlayerModel,\n                    abrController: abrController,\n                    playbackController: playbackController,\n                    dashMetrics: dashMetrics,\n                    baseURLController: baseURLController,\n                    timelineConverter: timelineConverter,\n                    adapter: adapter,\n                    offlineStoreController: offlineStoreController\n                });\n                _streams.push(stream);\n\n                // initialise stream and get downloadable representations\n                stream.initialize(streamInfo);\n                _progressionById[streamInfo.id] = null;\n            }\n            _isComposed = true;\n        } catch (e) {\n            logger.info(e);\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: e.message,\n                data: {\n                    id: manifestId,\n                    status: _status,\n                    error: e.error\n                }\n            });\n        }\n    }\n\n    function getMediaInfos() {\n        _streams.forEach(stream => {\n            stream.getMediaInfos();\n        });\n    }\n\n    /**\n     * Init databsse to store fragments\n     * @param {number} manifestId\n     * @instance\n     */\n    function createFragmentStore(manifestId) {\n        return offlineStoreController.createFragmentStore(manifestId);\n    }\n\n    /**\n     * Store in database the string representation of offline manifest (with only downloaded representations)\n     * @param {object} offlineManifest\n     * @instance\n     */\n    function createOfflineManifest(offlineManifest) {\n        return offlineStoreController.createOfflineManifest(offlineManifest);\n    }\n\n    /**\n     * Store in database the string representation of offline manifest (with only downloaded representations)\n     * @param {object} offlineManifest\n     * @instance\n     */\n    function updateOfflineManifest(offlineManifest) {\n        return offlineStoreController.updateOfflineManifest(offlineManifest);\n    }\n\n    /**\n     * Triggered when manifest is loaded from internet.\n     * @param {Object[]} e\n     */\n    function onOriginalManifestLoaded(e) {\n        // unregister form event\n        eventBus.off(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\n\n        _xmlManifest = e.originalManifest;\n\n        if (_manifest.type === dashConstants.DYNAMIC) {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: 'Cannot handle DYNAMIC manifest',\n                data: {\n                    id: manifestId,\n                    status: _status\n                }\n            });\n            logger.error('Cannot handle DYNAMIC manifest');\n\n            return;\n        }\n\n        if (_manifest.Period_asArray.length > 1) {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: 'MultiPeriod manifest are not yet supported',\n                data: {\n                    id: manifestId,\n                    status: _status\n                }\n            });\n            logger.error('MultiPeriod manifest are not yet supported');\n\n            return;\n        }\n\n        // save original manifest (for resume)\n\n        // initialise offline streams\n        composeStreams(_manifest);\n\n        // get MediaInfos\n        getMediaInfos();\n\n        eventBus.trigger(events.STREAMS_COMPOSED);\n    }\n\n    function initializeAllMediasInfoList(selectedRepresentations) {\n        for (let i = 0; i < _streams.length; i++) {\n            _streams[i].initializeAllMediasInfoList(selectedRepresentations);\n        }\n    }\n\n    function getSelectedRepresentations(mediaInfos) {\n        let rep = {};\n        rep[constants.VIDEO] = [];\n        rep[constants.AUDIO] = [];\n        rep[constants.TEXT] = [];\n        rep[constants.FRAGMENTED_TEXT] = [];\n\n        // selectedRepresentations.video.forEach(item => {\n        //     ret[constants.VIDEO].push(item.id);\n        // });\n        // selectedRepresentations.audio.forEach(item => {\n        //     ret[constants.AUDIO].push(item.id);\n        // });\n        // selectedRepresentations.text.forEach(item => {\n        //     ret[item.type].push(item.id);\n        // });\n\n        mediaInfos.forEach(mediaInfo => {\n            mediaInfo.bitrateList.forEach(bitrate => {\n                rep[mediaInfo.type].push(bitrate.id);\n            });\n        });\n        return rep;\n    }\n\n    function startDownload(mediaInfos) {\n        try {\n            let rep = getSelectedRepresentations(mediaInfos);\n\n            offlineStoreController.saveSelectedRepresentations(manifestId, rep)\n            .then(() => {\n                return createFragmentStore(manifestId);\n            })\n            .then(() => {\n                return generateOfflineManifest(rep);\n            })\n            .then(function () {\n                initializeAllMediasInfoList(rep);\n            });\n        } catch (err) {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: err.message,\n                data: {\n                    id: manifestId,\n                    status: _status\n                }\n            });\n        }\n    }\n\n    /**\n     * Create the parser used to convert original manifest in offline manifest\n     * Creates a JSON object that will be stored in database\n     * @param {Object[]} selectedRepresentations\n     * @instance\n     */\n    function generateOfflineManifest(selectedRepresentations) {\n        _indexDBManifestParser = OfflineIndexDBManifestParser(context).create({\n            manifestId: manifestId,\n            allMediaInfos: selectedRepresentations,\n            debug: debug,\n            dashConstants: dashConstants,\n            constants: constants,\n            urlUtils: urlUtils\n        });\n\n        return _indexDBManifestParser.parse(_xmlManifest).then(function (parsedManifest) {\n            if (parsedManifest !== null) {\n                return offlineStoreController.getManifestById(manifestId)\n                .then((item) => {\n                    item.originalURL = _manifest.url;\n                    item.originalManifest = _xmlManifest;\n                    item.manifest = parsedManifest;\n                    return updateOfflineManifest(item);\n                });\n            } else {\n                return Promise.reject('falling parsing offline manifest');\n            }\n        }).catch(function (err) {\n            return Promise.reject(err);\n        });\n    }\n\n    /**\n     * Stops downloading of fragments\n     * @instance\n     */\n    function stopDownload() {\n        if (manifestId !== null && isDownloading()) {\n            for (let i = 0, ln = _streams.length; i < ln; i++) {\n                _streams[i].stopOfflineStreamProcessors();\n            }\n\n            // remove streams\n            _streams = [];\n\n            _isComposed = false;\n\n            _status = OfflineConstants.OFFLINE_STATUS_STOPPED;\n            // update status\n            offlineStoreController.setDownloadingStatus(manifestId, _status).then(function () {\n                eventBus.trigger(events.OFFLINE_RECORD_STOPPED, {\n                    sender: this,\n                    id: manifestId,\n                    status: _status,\n                    message: 'Downloading has been stopped for this stream !'\n                });\n                _isDownloadingStatus = false;\n            });\n        }\n    }\n\n    /**\n     * Delete an offline manifest (and all of its data)\n     * @instance\n     */\n    function deleteDownload() {\n        stopDownload();\n    }\n\n    /**\n     * Resume download of a stream\n     * @instance\n     */\n    function resumeDownload() {\n        if (isDownloading()) {\n            return;\n        }\n\n        _isDownloadingStatus = true;\n\n        let selectedRepresentations;\n\n        offlineStoreController.getManifestById(manifestId)\n        .then((item) => {\n            let parser = DashParser(context).create({debug: debug});\n            _manifest = parser.parse(item.originalManifest);\n\n            composeStreams(_manifest);\n\n            selectedRepresentations = item.selected;\n\n            eventBus.trigger(events.STREAMS_COMPOSED);\n\n            return createFragmentStore(manifestId);\n        }). then(() => {\n            initializeAllMediasInfoList(selectedRepresentations);\n        });\n    }\n\n    /**\n     * Compute the progression of download\n     * @instance\n     */\n    function getDownloadProgression() {\n        return Math.round(_progression * 100);\n    }\n\n    /**\n     * Reset events listeners\n     * @instance\n     */\n    function resetDownload() {\n        for (let i = 0, ln = _streams.length; i < ln; i++) {\n            _streams[i].reset();\n        }\n        _indexDBManifestParser = null;\n        _isDownloadingStatus = false;\n        _streams = [];\n        eventBus.off(events.MANIFEST_UPDATED, onManifestUpdated, instance);\n        eventBus.off(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\n        resetIndexedDBEvents();\n    }\n\n    function onError(e) {\n        if ( e.error.code === OfflineErrors.INDEXEDDB_QUOTA_EXCEED_ERROR ||\n             e.error.code === OfflineErrors.INDEXEDDB_INVALID_STATE_ERROR ) {\n            stopDownload();\n        }\n    }\n\n    function resetIndexedDBEvents() {\n        eventBus.on(events.ERROR, onError, instance);\n    }\n\n    /**\n     * Reset\n     * @instance\n     */\n    function reset() {\n        if (isDownloading()) {\n            resetDownload();\n        }\n        baseURLController.reset();\n        manifestUpdater.reset();\n    }\n\n    instance = {\n        reset: reset,\n        getId: getId,\n        getOfflineUrl: getOfflineUrl,\n        getManifestUrl: getManifestUrl,\n        getStatus: getStatus,\n        setInitialState: setInitialState,\n        initDownload: initDownload,\n        downloadFromUrl: downloadFromUrl,\n        startDownload: startDownload,\n        stopDownload: stopDownload,\n        resumeDownload: resumeDownload,\n        deleteDownload: deleteDownload,\n        getDownloadProgression: getDownloadProgression,\n        isDownloading: isDownloading,\n        resetDownload: resetDownload\n    };\n\n    setup();\n\n    return instance;\n}\n\nOfflineDownload.__dashjs_factory_name = 'OfflineDownload';\nexport default dashjs.FactoryMaker.getClassFactory(OfflineDownload); /* jshint ignore:line */\n"]}
{"version":3,"sources":["../../../../src/offline/OfflineStream.js"],"names":["OfflineStream","config","context","eventBus","events","errors","constants","dashConstants","settings","debug","errHandler","mediaPlayerModel","abrController","playbackController","adapter","dashMetrics","baseURLController","timelineConverter","offlineStoreController","manifestId","id","startedCb","callbacks","started","progressionCb","progression","finishedCb","finished","updateManifest","updateManifestNeeded","instance","offlineStreamProcessors","startedOfflineStreamProcessors","finishedOfflineStreamProcessors","streamInfo","representationsToUpdate","allMediasInfosList","progressionById","setup","resetInitialSettings","initialize","initStreamInfo","on","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","getMediaInfos","mediaInfos","getAllMediaInfoForType","VIDEO","concat","AUDIO","FRAGMENTED_TEXT","TEXT","trigger","OFFLINE_RECORD_LOADEDMETADATA","initializeAllMediasInfoList","mediasInfoList","initializeMedia","createOfflineStreamProcessorFor","MUXED","IMAGE","type","allMediaInfoForType","forEach","media","bitrateList","filter","bitrate","indexOf","length","mediaInfo","createStreamProcessor","streamProcessor","create","mimeType","completed","onStreamCompleted","onStreamProgression","push","sender","message","downloadedSegments","availableSegments","getRepresentationId","segments","allSegments","waitForAllProgress","property","hasOwnProperty","e","repCtrl","getStreamId","currentRepresentation","sp","i","getRepresentationController","getType","checkIfAllOfflineStreamProcessorsStarted","representations","startOfflineStreamProcessors","getStreamInfo","getStartTime","start","NaN","getDuration","duration","stopOfflineStreamProcessors","stop","deactivate","ln","removeExecutedRequestsBeforeTime","reset","off","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineStream.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport OfflineStreamProcessor from './OfflineStreamProcessor';\n\n/**\n * Initialize and Manage Offline Stream for each type\n */\n/**\n * @class OfflineStream\n * @description Initialize and Manage Offline Stream for each type\n * @param {Object} config - dependences\n * @ignore\n */\nfunction OfflineStream(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const errors = config.errors;\n    const constants = config.constants;\n    const dashConstants = config.dashConstants;\n    const settings = config.settings;\n    const debug = config.debug;\n    const errHandler = config.errHandler;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const baseURLController = config.baseURLController;\n    const timelineConverter = config.timelineConverter;\n    const offlineStoreController = config.offlineStoreController;\n    const manifestId = config.id;\n    const startedCb = config.callbacks && config.callbacks.started;\n    const progressionCb = config.callbacks && config.callbacks.progression;\n    const finishedCb = config.callbacks && config.callbacks.finished;\n    const updateManifest = config.callbacks && config.callbacks.updateManifestNeeded;\n\n    let instance,\n        offlineStreamProcessors,\n        startedOfflineStreamProcessors,\n        finishedOfflineStreamProcessors,\n        streamInfo,\n        representationsToUpdate,\n        allMediasInfosList,\n        progressionById;\n\n    function setup() {\n        resetInitialSettings();\n    }\n\n    /**\n     * Reset\n     */\n    function resetInitialSettings() {\n        streamInfo = null;\n        offlineStreamProcessors = [];\n        startedOfflineStreamProcessors = 0;\n        finishedOfflineStreamProcessors = 0;\n        allMediasInfosList = [];\n        representationsToUpdate = [];\n        progressionById = {};\n    }\n\n    /**\n     * Initialize offlinestream\n     * @param {Object} initStreamInfo\n     */\n    function initialize(initStreamInfo) {\n        streamInfo = initStreamInfo;\n        eventBus.on(events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n    }\n\n    /**\n     * Creates media infos list, so that user will be able to choose the representation he wants to download\n     */\n    function getMediaInfos() {\n        let mediaInfos = adapter.getAllMediaInfoForType(streamInfo, constants.VIDEO);\n        mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.AUDIO));\n        mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.FRAGMENTED_TEXT));\n        mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.TEXT));\n\n        // mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.MUXED));\n        // mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.IMAGE));\n\n        eventBus.trigger(events.OFFLINE_RECORD_LOADEDMETADATA, {\n            id: manifestId,\n            mediaInfos: mediaInfos\n        });\n    }\n\n    /**\n     * Initialize with choosen representations by user\n     * @param {Object} mediasInfoList\n     */\n    function initializeAllMediasInfoList(mediasInfoList) {\n        allMediasInfosList = mediasInfoList;\n        initializeMedia(streamInfo);\n    }\n\n    /**\n     * Initialize media for each type\n     * @param {Object} streamInfo\n     */\n    function initializeMedia(streamInfo) {\n        createOfflineStreamProcessorFor(constants.VIDEO,streamInfo);\n        createOfflineStreamProcessorFor(constants.AUDIO,streamInfo);\n        createOfflineStreamProcessorFor(constants.FRAGMENTED_TEXT,streamInfo);\n        createOfflineStreamProcessorFor(constants.TEXT,streamInfo);\n\n        createOfflineStreamProcessorFor(constants.MUXED,streamInfo);\n        createOfflineStreamProcessorFor(constants.IMAGE,streamInfo);\n    }\n\n    function createOfflineStreamProcessorFor(type, streamInfo) {\n        // filter mediaInfo according to choosen representation id\n        let allMediaInfoForType = adapter.getAllMediaInfoForType(streamInfo, type);\n        allMediaInfoForType.forEach((media) => {\n            media.bitrateList = media.bitrateList.filter((bitrate) => {\n                if (allMediasInfosList[type] && allMediasInfosList[type].indexOf(bitrate.id) !== -1) {\n                    return true;\n                }\n                return false;\n            });\n        });\n\n        allMediaInfoForType = allMediaInfoForType.filter((media) => {\n            return (media.bitrateList && media.bitrateList.length > 0);\n        });\n\n        // cration of an offline stream processor for each choosen representation\n        allMediaInfoForType.forEach((mediaInfo) => {\n            if (mediaInfo.bitrateList) {\n                mediaInfo.bitrateList.forEach((bitrate) => {\n                    createStreamProcessor(mediaInfo, bitrate);\n                });\n            }\n        });\n        return allMediaInfoForType;\n    }\n\n    function createStreamProcessor (mediaInfo, bitrate) {\n\n        let streamProcessor = OfflineStreamProcessor(context).create({\n            id: manifestId,\n            streamInfo: streamInfo,\n            debug: debug,\n            events: events,\n            errors: errors,\n            eventBus: eventBus,\n            constants: constants,\n            dashConstants: dashConstants,\n            settings: settings,\n            type: mediaInfo.type,\n            mimeType: mediaInfo.mimeType,\n            bitrate: bitrate,\n            errHandler: errHandler,\n            mediaPlayerModel: mediaPlayerModel,\n            abrController: abrController,\n            playbackController: playbackController,\n            adapter: adapter,\n            dashMetrics: dashMetrics,\n            baseURLController: baseURLController,\n            timelineConverter: timelineConverter,\n            offlineStoreController: offlineStoreController,\n            callbacks: {\n                completed: onStreamCompleted,\n                progression: onStreamProgression\n            }\n        });\n        offlineStreamProcessors.push(streamProcessor);\n        streamProcessor.initialize(mediaInfo);\n\n        progressionById[bitrate.id] = null;\n    }\n\n    function onStreamCompleted() {\n        finishedOfflineStreamProcessors++;\n        if (finishedOfflineStreamProcessors === offlineStreamProcessors.length) {\n            finishedCb({sender: this, id: manifestId, message: 'Downloading has been successfully completed for this stream !'});\n        }\n    }\n\n    function onStreamProgression(streamProcessor, downloadedSegments, availableSegments ) {\n        progressionById[streamProcessor.getRepresentationId()] = {\n            downloadedSegments,\n            availableSegments\n        };\n\n        let segments = 0;\n        let allSegments = 0;\n        let waitForAllProgress;\n        for (var property in progressionById) {\n            if (progressionById.hasOwnProperty(property)) {\n                if (progressionById[property] === null) {\n                    waitForAllProgress = true;\n                } else {\n                    segments += progressionById[property].downloadedSegments;\n                    allSegments += progressionById[property].availableSegments;\n                }\n            }\n        }\n\n        if (!waitForAllProgress && progressionCb) {\n            // all progression have been started, we can compute global progression\n            if (allSegments > 0) {\n                progressionCb(instance, segments, allSegments);\n            }\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        let repCtrl = e.sender;\n        if (!streamInfo || repCtrl.getStreamId() !== streamInfo.id) return;\n\n        if (e.currentRepresentation.segments && e.currentRepresentation.segments.length > 0) {\n            representationsToUpdate.push(e.currentRepresentation);\n        }\n\n        let sp;\n        // data are ready fr stream processor, let's start download\n        for (let i = 0; i < offlineStreamProcessors.length; i++ ) {\n            if (offlineStreamProcessors[i].getRepresentationController().getType() === repCtrl.getType()) {\n                sp = offlineStreamProcessors[i];\n                break;\n            }\n        }\n\n        if (sp) {\n            checkIfAllOfflineStreamProcessorsStarted();\n        }\n    }\n\n    function checkIfAllOfflineStreamProcessorsStarted() {\n        startedOfflineStreamProcessors++;\n        if (startedOfflineStreamProcessors === offlineStreamProcessors.length) {\n            startedCb({sender: this, id: manifestId, message: 'Downloading started for this stream !'});\n\n            if (representationsToUpdate.length > 0) {\n                updateManifest({sender: this, id: manifestId, representations: representationsToUpdate });\n            } else {\n                startOfflineStreamProcessors();\n            }\n        }\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function getStartTime() {\n        return streamInfo ? streamInfo.start : NaN;\n    }\n\n    function getDuration() {\n        return streamInfo ? streamInfo.duration : NaN;\n    }\n\n    /**\n     * Stop offline stream processors\n     */\n    function stopOfflineStreamProcessors() {\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\n            offlineStreamProcessors[i].stop();\n        }\n    }\n\n    /**\n     * Start offline stream processors\n     */\n    function startOfflineStreamProcessors() {\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\n            offlineStreamProcessors[i].start();\n        }\n    }\n\n    function deactivate() {\n        let ln = offlineStreamProcessors ? offlineStreamProcessors.length : 0;\n        for (let i = 0; i < ln; i++) {\n            offlineStreamProcessors[i].removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n            offlineStreamProcessors[i].reset();\n        }\n    }\n\n    /**\n     * Reset\n     */\n    function reset() {\n        stopOfflineStreamProcessors();\n        deactivate();\n        resetInitialSettings();\n\n        eventBus.off(events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n    }\n\n    instance = {\n        initialize: initialize,\n        getMediaInfos: getMediaInfos,\n        initializeAllMediasInfoList: initializeAllMediasInfoList,\n        getStreamInfo: getStreamInfo,\n        stopOfflineStreamProcessors: stopOfflineStreamProcessors,\n        startOfflineStreamProcessors: startOfflineStreamProcessors,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nOfflineStream.__dashjs_factory_name = 'OfflineStream';\nexport default dashjs.FactoryMaker.getClassFactory(OfflineStream); /* jshint ignore:line */\n"]}
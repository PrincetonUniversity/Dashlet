{"version":3,"sources":["../../../../../src/streaming/text/NotFragmentedTextBufferController.js"],"names":["BUFFER_CONTROLLER_TYPE","NotFragmentedTextBufferController","config","context","eventBus","getInstance","textController","errHandler","streamInfo","type","mimeType","fragmentModel","instance","isBufferingCompleted","initialized","mediaSource","buffer","initCache","setup","on","Events","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","INIT_FRAGMENT_LOADED","onInitFragmentLoaded","getBufferControllerType","initialize","source","setMediaSource","createBuffer","mediaInfoArr","mediaInfo","create","textBuffer","getBuffer","hasOwnProperty","Constants","INITIALIZE","e","isText","codec","indexOf","getTextSourceBuffer","error","DashJSError","Errors","MEDIASOURCE_TYPE_UNSUPPORTED_CODE","MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE","message","getType","value","getMediaSource","getIsPruningInProgress","dischargePreBuffer","getBufferLevel","getIsBufferingCompleted","reset","errored","off","abort","sender","getStreamId","id","extract","currentRepresentation","trigger","INIT_FRAGMENT_NEEDED","streamId","mediaType","representationId","appendInitSegment","chunk","bytes","save","append","STREAM_COMPLETED","request","getRangeAt","updateTimestampOffset","MSETimeOffset","timestampOffset","isNaN","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"NotFragmentedTextBufferController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport InitCache from '../utils/InitCache';\nimport SourceBufferSink from '../SourceBufferSink';\nimport TextController from '../../streaming/text/TextController';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nconst BUFFER_CONTROLLER_TYPE = 'NotFragmentedTextBufferController';\nfunction NotFragmentedTextBufferController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const textController = TextController(context).getInstance();\n\n    const errHandler = config.errHandler;\n    const streamInfo = config.streamInfo;\n    const type = config.type;\n    const mimeType = config.mimeType;\n    const fragmentModel = config.fragmentModel;\n\n    let instance,\n        isBufferingCompleted,\n        initialized,\n        mediaSource,\n        buffer,\n        initCache;\n\n    function setup() {\n        initialized = false;\n        mediaSource = null;\n        isBufferingCompleted = false;\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.on(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n    }\n\n    function getBufferControllerType() {\n        return BUFFER_CONTROLLER_TYPE;\n    }\n\n    function initialize(source) {\n        setMediaSource(source);\n        initCache = InitCache(context).getInstance();\n    }\n\n    function createBuffer(mediaInfoArr) {\n        const mediaInfo = mediaInfoArr[0];\n        try {\n            buffer = SourceBufferSink(context).create(mediaSource, mediaInfo);\n            if (!initialized) {\n                const textBuffer = buffer.getBuffer();\n                if (textBuffer.hasOwnProperty(Constants.INITIALIZE)) {\n                    textBuffer.initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n                }\n                initialized = true;\n            }\n            return buffer;\n        } catch (e) {\n            if (mediaInfo && ((mediaInfo.isText) || (mediaInfo.codec.indexOf('codecs=\"stpp') !== -1) || (mediaInfo.codec.indexOf('codecs=\"wvtt') !== -1))) {\n                try {\n                    buffer = textController.getTextSourceBuffer();\n                } catch (e) {\n                    errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type + ' : ' + e.message));\n                }\n            } else {\n                errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type));\n            }\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function setMediaSource(value) {\n        mediaSource = value;\n    }\n\n    function getMediaSource() {\n        return mediaSource;\n    }\n\n    function getIsPruningInProgress() {\n        return false;\n    }\n\n    function dischargePreBuffer() {\n    }\n\n    function getBufferLevel() {\n        return 0;\n    }\n\n    function getIsBufferingCompleted() {\n        return isBufferingCompleted;\n    }\n\n    function reset(errored) {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n\n        if (!errored && buffer) {\n            buffer.abort();\n            buffer.reset();\n            buffer = null;\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.sender.getStreamId() !== streamInfo.id || e.sender.getType() !== type || e.error) return;\n\n        if (initCache.extract(streamInfo.id, e.currentRepresentation.id) !== null) {\n            return;\n        }\n\n        // Representation has changed, clear buffer\n        isBufferingCompleted = false;\n\n        // // Text data file is contained in initialization segment\n        eventBus.trigger(Events.INIT_FRAGMENT_NEEDED, {\n            sender: instance,\n            streamId: streamInfo.id,\n            mediaType: type,\n            representationId: e.currentRepresentation.id\n        });\n    }\n\n    function appendInitSegment(representationId) {\n        // If text data file already in cache then no need to append it again\n        return initCache.extract(streamInfo.id, representationId) !== null;\n    }\n\n    function onInitFragmentLoaded(e) {\n        if (e.chunk.streamId !== streamInfo.id || e.chunk.mediaInfo.type !== type || (!e.chunk.bytes)) return;\n\n        initCache.save(e.chunk);\n        buffer.append(e.chunk);\n\n        isBufferingCompleted = true;\n\n        eventBus.trigger(Events.STREAM_COMPLETED, {\n            request: e.request\n        });\n    }\n\n    function getRangeAt() {\n        return null;\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            buffer.timestampOffset = MSETimeOffset;\n        }\n    }\n\n    instance = {\n        getBufferControllerType: getBufferControllerType,\n        initialize: initialize,\n        createBuffer: createBuffer,\n        getType: getType,\n        getBuffer: getBuffer,\n        getBufferLevel: getBufferLevel,\n        setMediaSource: setMediaSource,\n        getMediaSource: getMediaSource,\n        getIsBufferingCompleted: getIsBufferingCompleted,\n        getIsPruningInProgress: getIsPruningInProgress,\n        dischargePreBuffer: dischargePreBuffer,\n        appendInitSegment: appendInitSegment,\n        getRangeAt: getRangeAt,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset\n    };\n\n    setup();\n\n    return instance;\n}\n\nNotFragmentedTextBufferController.__dashjs_factory_name = BUFFER_CONTROLLER_TYPE;\nexport default FactoryMaker.getClassFactory(NotFragmentedTextBufferController);\n"]}
{"version":3,"sources":["../../../../../../src/streaming/rules/abr/InsufficientBufferRule.js"],"names":["InsufficientBufferRule","config","INSUFFICIENT_BUFFER_SAFETY_FACTOR","SEGMENT_IGNORE_COUNT","context","eventBus","getInstance","dashMetrics","instance","logger","bufferStateDict","setup","getLogger","resetInitialSettings","on","Events","PLAYBACK_SEEKING","onPlaybackSeeking","BYTES_APPENDED_END_FRAGMENT","onEndFragment","checkConfig","hasOwnProperty","Error","Constants","MISSING_CONFIG_ERROR","getMaxIndex","rulesContext","switchRequest","create","mediaType","getMediaType","currentBufferState","getCurrentBufferState","representationInfo","getRepresentationInfo","fragmentDuration","shouldIgnore","state","MetricsConstants","BUFFER_EMPTY","debug","quality","reason","mediaInfo","getMediaInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","bufferLevel","getCurrentBufferLevel","throughput","getAverageThroughput","latency","getAverageLatency","bitrate","getQualityForBitrate","ignoreCount","VIDEO","AUDIO","e","isNaN","startTime","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"InsufficientBufferRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport Debug from '../../../core/Debug';\nimport SwitchRequest from '../SwitchRequest';\nimport Constants from '../../constants/Constants';\nimport MetricsConstants from '../../constants/MetricsConstants';\n\nfunction InsufficientBufferRule(config) {\n\n    config = config || {};\n    const INSUFFICIENT_BUFFER_SAFETY_FACTOR = 0.5;\n    const SEGMENT_IGNORE_COUNT = 2;\n\n    const context = this.context;\n\n    const eventBus = EventBus(context).getInstance();\n    const dashMetrics = config.dashMetrics;\n\n    let instance,\n        logger,\n        bufferStateDict;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onEndFragment, instance);\n    }\n\n    function checkConfig() {\n        if (!dashMetrics || !dashMetrics.hasOwnProperty('getCurrentBufferLevel') || !dashMetrics.hasOwnProperty('getCurrentBufferState')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    /*\n     * InsufficientBufferRule does not kick in before the first BUFFER_LOADED event happens. This is reset at every seek.\n     *\n     * If a BUFFER_EMPTY event happens, then InsufficientBufferRule returns switchRequest.quality=0 until BUFFER_LOADED happens.\n     *\n     * Otherwise InsufficientBufferRule gives a maximum bitrate depending on throughput and bufferLevel such that\n     * a whole fragment can be downloaded before the buffer runs out, subject to a conservative safety factor of 0.5.\n     * If the bufferLevel is low, then InsufficientBufferRule avoids rebuffering risk.\n     * If the bufferLevel is high, then InsufficientBufferRule give a high MaxIndex allowing other rules to take over.\n     */\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaType')) {\n            return switchRequest;\n        }\n\n        checkConfig();\n\n        const mediaType = rulesContext.getMediaType();\n        const currentBufferState = dashMetrics.getCurrentBufferState(mediaType);\n        const representationInfo = rulesContext.getRepresentationInfo();\n        const fragmentDuration = representationInfo.fragmentDuration;\n\n        // Don't ask for a bitrate change if there is not info about buffer state or if fragmentDuration is not defined\n        if (shouldIgnore(mediaType) || !fragmentDuration) {\n            return switchRequest;\n        }\n\n        if (currentBufferState && currentBufferState.state === MetricsConstants.BUFFER_EMPTY) {\n            logger.debug('[' + mediaType + '] Switch to index 0; buffer is empty.');\n            switchRequest.quality = 0;\n            switchRequest.reason = 'InsufficientBufferRule: Buffer is empty';\n        } else {\n            const mediaInfo = rulesContext.getMediaInfo();\n            const abrController = rulesContext.getAbrController();\n            const throughputHistory = abrController.getThroughputHistory();\n\n            const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n            const throughput = throughputHistory.getAverageThroughput(mediaType);\n            const latency = throughputHistory.getAverageLatency(mediaType);\n            const bitrate = throughput * (bufferLevel / fragmentDuration) * INSUFFICIENT_BUFFER_SAFETY_FACTOR;\n\n            switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, bitrate, latency);\n            switchRequest.reason = 'InsufficientBufferRule: being conservative to avoid immediate rebuffering';\n        }\n\n        return switchRequest;\n    }\n\n    function shouldIgnore(mediaType) {\n        return bufferStateDict[mediaType].ignoreCount > 0;\n    }\n\n    function resetInitialSettings() {\n        bufferStateDict = {};\n        bufferStateDict[Constants.VIDEO] = {ignoreCount: SEGMENT_IGNORE_COUNT};\n        bufferStateDict[Constants.AUDIO] = {ignoreCount: SEGMENT_IGNORE_COUNT};\n    }\n\n    function onPlaybackSeeking() {\n        resetInitialSettings();\n    }\n\n    function onEndFragment(e) {\n        if (!isNaN(e.startTime) && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            if (bufferStateDict[e.mediaType].ignoreCount > 0) {\n                bufferStateDict[e.mediaType].ignoreCount--;\n            }\n        }\n    }\n\n    function reset() {\n        resetInitialSettings();\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onEndFragment, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nInsufficientBufferRule.__dashjs_factory_name = 'InsufficientBufferRule';\nexport default FactoryMaker.getClassFactory(InsufficientBufferRule);\n"]}
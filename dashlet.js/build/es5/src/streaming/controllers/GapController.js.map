{"version":3,"sources":["../../../../../src/streaming/controllers/GapController.js"],"names":["GAP_HANDLER_INTERVAL","THRESHOLD_TO_STALLS","GAP_THRESHOLD","GapController","context","eventBus","getInstance","instance","lastPlaybackTime","settings","wallclockTicked","gapHandlerInterval","lastGapJumpPosition","playbackController","streamController","videoModel","timelineConverter","adapter","logger","initialize","registerEvents","setup","getLogger","reset","stopGapHandler","unregisterEvents","resetInitialSettings","NaN","setConfig","config","on","Events","WALLCLOCK_TIME_UPDATED","onWallclockTimeUpdated","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","off","startGapHandler","_shouldCheckForGaps","get","streaming","jumpGaps","getActiveStreamProcessors","length","isSeeking","hasStreamFinishedBuffering","getActiveStream","isPaused","getIsStreamSwitchInProgress","getHasMediaOrIntialisationError","currentTime","getTime","jumpGap","getNextRangeStartTime","ranges","getBufferRange","nextRangeStartTime","j","rangeEnd","end","start","e","debug","setInterval","clearInterval","playbackStalled","smallGapLimit","jumpLargeGaps","seekToPosition","jumpToStreamEnd","gap","timeToStreamEnd","getTimeToStreamEnd","isNaN","isFinite","parseFloat","getStreamEndTime","toFixed","warn","trigger","GAP_CAUSED_SEEK_TO_PERIOD_END","seekTime","seek","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"GapController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport Events from '../../core/events/Events';\nimport EventBus from '../../core/EventBus';\n\nconst GAP_HANDLER_INTERVAL = 100;\nconst THRESHOLD_TO_STALLS = 10;\nconst GAP_THRESHOLD = 0.1;\n\nfunction GapController() {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        lastPlaybackTime,\n        settings,\n        wallclockTicked,\n        gapHandlerInterval,\n        lastGapJumpPosition,\n        playbackController,\n        streamController,\n        videoModel,\n        timelineConverter,\n        adapter,\n        logger;\n\n    function initialize() {\n        registerEvents();\n    }\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function reset() {\n        stopGapHandler();\n        unregisterEvents();\n        resetInitialSettings();\n    }\n\n    function resetInitialSettings() {\n        gapHandlerInterval = null;\n        lastGapJumpPosition = NaN;\n        wallclockTicked = 0;\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n        if (config.playbackController) {\n            playbackController = config.playbackController;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n    }\n\n    function unregisterEvents() {\n        eventBus.off(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n    }\n\n    function onBytesAppended() {\n        if (!gapHandlerInterval) {\n            startGapHandler();\n        }\n    }\n\n    function _shouldCheckForGaps() {\n        return settings.get().streaming.jumpGaps && streamController.getActiveStreamProcessors().length > 0 &&\n            (!playbackController.isSeeking() || streamController.hasStreamFinishedBuffering(streamController.getActiveStream())) && !playbackController.isPaused() && !streamController.getIsStreamSwitchInProgress() &&\n            !streamController.getHasMediaOrIntialisationError();\n    }\n\n    function onWallclockTimeUpdated(/*e*/) {\n        if (!_shouldCheckForGaps()) {\n            return;\n        }\n\n        wallclockTicked++;\n        if (wallclockTicked >= THRESHOLD_TO_STALLS) {\n            const currentTime = playbackController.getTime();\n            if (lastPlaybackTime === currentTime) {\n                jumpGap(currentTime, true);\n            } else {\n                lastPlaybackTime = currentTime;\n                lastGapJumpPosition = NaN;\n            }\n            wallclockTicked = 0;\n        }\n    }\n\n    function getNextRangeStartTime(currentTime) {\n        try {\n            const ranges = videoModel.getBufferRange();\n            if (!ranges || (ranges.length <= 1 && currentTime > 0)) {\n                return null;\n            }\n            let nextRangeStartTime = null;\n            let j = 0;\n\n            while (!nextRangeStartTime && j < ranges.length) {\n                const rangeEnd = j > 0 ? ranges.end(j - 1) : 0;\n                if (currentTime < ranges.start(j) && rangeEnd - currentTime < GAP_THRESHOLD) {\n                    nextRangeStartTime = ranges.start(j);\n                }\n                j += 1;\n            }\n            return nextRangeStartTime;\n\n        } catch (e) {\n            return null;\n        }\n    }\n\n\n    function startGapHandler() {\n        try {\n            if (!gapHandlerInterval) {\n                logger.debug('Starting the gap controller');\n                gapHandlerInterval = setInterval(() => {\n                    if (!_shouldCheckForGaps()) {\n                        return;\n                    }\n                    const currentTime = playbackController.getTime();\n                    jumpGap(currentTime);\n\n                }, GAP_HANDLER_INTERVAL);\n            }\n        } catch (e) {\n        }\n    }\n\n    function stopGapHandler() {\n        logger.debug('Stopping the gap controller');\n        if (gapHandlerInterval) {\n            clearInterval(gapHandlerInterval);\n            gapHandlerInterval = null;\n        }\n    }\n\n    function jumpGap(currentTime, playbackStalled = false) {\n        const smallGapLimit = settings.get().streaming.smallGapLimit;\n        const jumpLargeGaps = settings.get().streaming.jumpLargeGaps;\n        let nextRangeStartTime = null;\n        let seekToPosition = NaN;\n        let jumpToStreamEnd = false;\n\n\n        // Get the range just after current time position\n        nextRangeStartTime = getNextRangeStartTime(currentTime);\n\n        if (nextRangeStartTime && nextRangeStartTime > 0) {\n            const gap = nextRangeStartTime - currentTime;\n            if (gap > 0 && (gap <= smallGapLimit || jumpLargeGaps)) {\n                seekToPosition = nextRangeStartTime;\n            }\n        }\n\n        // Playback has stalled before period end. We seek to the end of the period\n        const timeToStreamEnd = playbackController.getTimeToStreamEnd();\n        if (isNaN(seekToPosition) && playbackStalled && isFinite(timeToStreamEnd) && !isNaN(timeToStreamEnd) && ((timeToStreamEnd < smallGapLimit) || streamController.hasStreamFinishedBuffering(streamController.getActiveStream()))) {\n            seekToPosition = parseFloat(playbackController.getStreamEndTime().toFixed(5));\n            jumpToStreamEnd = true;\n        }\n\n        if (seekToPosition > 0 && lastGapJumpPosition !== seekToPosition) {\n            if (jumpToStreamEnd) {\n                logger.warn(`Jumping to end of stream because of gap from ${currentTime} to ${seekToPosition}. Gap duration: ${seekToPosition - currentTime}`);\n                eventBus.trigger(Events.GAP_CAUSED_SEEK_TO_PERIOD_END, {seekTime: seekToPosition});\n            } else {\n                logger.warn(`Jumping gap from ${currentTime} to ${seekToPosition}. Gap duration: ${seekToPosition - currentTime}`);\n                playbackController.seek(seekToPosition, true, true);\n            }\n            lastGapJumpPosition = seekToPosition;\n        }\n    }\n\n    instance = {\n        reset,\n        setConfig,\n        initialize\n    };\n\n    setup();\n\n    return instance;\n}\n\nGapController.__dashjs_factory_name = 'GapController';\nexport default FactoryMaker.getSingletonFactory(GapController);\n"]}
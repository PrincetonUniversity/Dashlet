{"version":3,"sources":["../../../../../src/streaming/controllers/ScheduleController.js"],"names":["ScheduleController","config","context","eventBus","getInstance","adapter","dashMetrics","mediaPlayerModel","fragmentModel","abrController","playbackController","textController","streamId","type","mimeType","mediaController","bufferController","settings","instance","logger","currentRepresentationInfo","initialRequest","isStopped","isFragmentProcessingInProgress","timeToLoadDelay","scheduleTimeout","seekTarget","hasVideoTrack","bufferLevelRule","lastFragmentRequest","topQualityIndex","lastInitQuality","replaceRequestArray","switchTrack","replacingBuffer","mediaRequest","checkPlaybackQuality","isReplacementRequest","setup","getLogger","resetInitialSettings","initialize","_hasVideoTrack","create","on","Events","DATA_UPDATE_STARTED","onDataUpdateStarted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","STREAM_COMPLETED","onStreamCompleted","BUFFER_CLEARED","onBufferCleared","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","QUOTA_EXCEEDED","onQuotaExceeded","PLAYBACK_SEEKING","onPlaybackSeeking","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_RATE_CHANGED","onPlaybackRateChanged","PLAYBACK_TIME_UPDATED","onPlaybackTimeUpdated","URL_RESOLUTION_FAILED","onURLResolutionFailed","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","BUFFERING_COMPLETED","onBufferingCompleted","setCurrentRepresentation","representationInfo","isStarted","start","getIsBufferingCompleted","debug","createPlaylistTraceMetrics","id","getTime","getPlaybackRate","startScheduleTimer","stop","clearTimeout","hasTopQualityChanged","newTopQualityIndex","getTopQualityIndexFor","info","schedule","isPaused","get","streaming","scheduleWhilePaused","Constants","FRAGMENTED_TEXT","TEXT","isTextEnabled","validateExecutedFragmentRequest","isReplacement","length","isNaN","execute","getNextFragment","quality","getSwitchMode","MediaController","TRACK_SWITCH_MODE_ALWAYS_REPLACE","replaceBuffer","trigger","INIT_FRAGMENT_NEEDED","sender","mediaType","representationId","replacement","shift","isInitializationRequest","MEDIA_FRAGMENT_NEEDED","console","log","setFragmentProcessState","time","safeBufferLevel","fragmentDuration","schedulingInfo","getCurrentSchedulingInfo","mediaInfo","duration","request","getRequests","state","FragmentModel","FRAGMENT_MODEL_EXECUTED","threshold","indexOf","getIsTextTrack","fastSwitchModeEnabled","fastSwitchEnabled","bufferLevel","getBufferLevel","abandonmentState","getAbandonmentStateFor","trackChanged","isCurrentTrack","TRACK_SWITCH_MODE_NEVER_REPLACE","qualityChanged","MetricsConstants","ABANDON_LOAD","replaceRequest","index","setSeekTarget","value","setTimeout","processInitRequest","executeRequest","processMediaRequest","url","getIsDynamic","lowLatencyEnabled","switchTrackAsked","push","completeQualityChange","item","startTime","TRACK_CHANGE_RENDERED","oldMediaInfo","newMediaInfo","adaptationIndex","QUALITY_CHANGE_RENDERED","oldQuality","newQuality","e","streamInfo","range","error","serviceLocation","addExecutedRequest","currentTime","fragEndTime","isSeeking","getType","getStreamId","flushBufferAtTrackSwitch","seek","hasEnoughSpaceToAppend","quotaExceeded","abortRequests","seekTime","setTimeToLoadDelay","latency","DVRWindow","end","NaN","updateManifestUpdateInfo","updatePlayListTraceMetrics","playbackspeed","playbackRate","toString","getTimeToLoadDelay","getBufferTarget","undefined","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"sEA8BA,iD,mDACA,+D,iEACA,oE,+DACA,sD,2DACA,6C,iDACA,gD,6CACA,qD,yDACA,uC,2CACA,kD,kJAEA,QAASA,mBAAT,CAA4BC,MAA5B,CAAoC,CAEhCA,OAASA,QAAU,EAAnB,CACA,GAAMC,SAAU,KAAKA,OAArB,CACA,GAAMC,UAAW,uBAASD,OAAT,EAAkBE,WAAlB,EAAjB,CACA,GAAMC,SAAUJ,OAAOI,OAAvB,CACA,GAAMC,aAAcL,OAAOK,WAA3B,CACA,GAAMC,kBAAmBN,OAAOM,gBAAhC,CACA,GAAMC,eAAgBP,OAAOO,aAA7B,CACA,GAAMC,eAAgBR,OAAOQ,aAA7B,CACA,GAAMC,oBAAqBT,OAAOS,kBAAlC,CACA,GAAMC,gBAAiBV,OAAOU,cAA9B,CACA,GAAMC,UAAWX,OAAOW,QAAxB,CACA,GAAMC,MAAOZ,OAAOY,IAApB,CACA,GAAMC,UAAWb,OAAOa,QAAxB,CACA,GAAMC,iBAAkBd,OAAOc,eAA/B,CACA,GAAMC,kBAAmBf,OAAOe,gBAAhC,CACA,GAAMC,UAAWhB,OAAOgB,QAAxB,CAEA,GAAIC,gBAAJ,CACIC,aADJ,CAEIC,gCAFJ,CAGIC,qBAHJ,CAIIC,gBAJJ,CAKIC,qCALJ,CAMIC,sBANJ,CAOIC,sBAPJ,CAQIC,iBARJ,CASIC,oBATJ,CAUIC,sBAVJ,CAWIC,0BAXJ,CAYIC,sBAZJ,CAaIC,sBAbJ,CAcIC,0BAdJ,CAeIC,kBAfJ,CAgBIC,sBAhBJ,CAiBIC,mBAjBJ,CAkBIC,2BAlBJ,CAmBIC,2BAnBJ,CAqBA,QAASC,MAAT,EAAiB,CACbnB,OAAS,oBAAMjB,OAAN,EAAeE,WAAf,GAA6BmC,SAA7B,CAAuCrB,QAAvC,CAAT,CACAsB,uBACH,CAED,QAASC,WAAT,CAAoBC,cAApB,CAAoC,CAChCf,cAAgBe,cAAhB,CAEAd,gBAAkB,8BAAgB1B,OAAhB,EAAyByC,MAAzB,CAAgC,CAC9ClC,cAAeA,aAD+B,CAE9CH,YAAaA,WAFiC,CAG9CC,iBAAkBA,gBAH4B,CAI9CI,eAAgBA,cAJ8B,CAK9CM,SAAUA,QALoC,CAAhC,CAAlB,CAQA;AACAd,SAASyC,EAAT,CAAYC,iBAAOC,mBAAnB,CAAwCC,mBAAxC,CAA6D,IAA7D,EACA5C,SAASyC,EAAT,CAAYC,iBAAOG,0BAAnB,CAA+CC,0BAA/C,CAA2E,IAA3E,EACA9C,SAASyC,EAAT,CAAYC,iBAAOK,gBAAnB,CAAqCC,iBAArC,CAAwD,IAAxD,EACAhD,SAASyC,EAAT,CAAYC,iBAAOO,cAAnB,CAAmCC,eAAnC,CAAoD,IAApD,EACAlD,SAASyC,EAAT,CAAYC,iBAAOS,2BAAnB,CAAgDC,eAAhD,CAAiE,IAAjE,EACApD,SAASyC,EAAT,CAAYC,iBAAOW,cAAnB,CAAmCC,eAAnC,CAAoD,IAApD,EACAtD,SAASyC,EAAT,CAAYC,iBAAOa,gBAAnB,CAAqCC,iBAArC,CAAwD,IAAxD,EACAxD,SAASyC,EAAT,CAAYC,iBAAOe,gBAAnB,CAAqCC,iBAArC,CAAwD,IAAxD,EACA1D,SAASyC,EAAT,CAAYC,iBAAOiB,qBAAnB,CAA0CC,qBAA1C,CAAiE,IAAjE,EACA5D,SAASyC,EAAT,CAAYC,iBAAOmB,qBAAnB,CAA0CC,qBAA1C,CAAiE,IAAjE,EACA9D,SAASyC,EAAT,CAAYC,iBAAOqB,qBAAnB,CAA0CC,qBAA1C,CAAiE,IAAjE,EACAhE,SAASyC,EAAT,CAAYC,iBAAOuB,0BAAnB,CAA+CC,0BAA/C,CAA2E,IAA3E,EACAlE,SAASyC,EAAT,CAAYC,iBAAOyB,mBAAnB,CAAwCC,oBAAxC,CAA8D,IAA9D,EACH,CAED,QAASC,yBAAT,CAAkCC,kBAAlC,CAAsD,CAClDrD,0BAA4BqD,kBAA5B,CACH,CAED,QAASC,UAAT,EAAqB,CACjB,MAAQpD,aAAc,KAAtB,CACH,CAED,QAASqD,MAAT,EAAiB,CACb,GAAID,WAAJ,CAAiB,OACjB,GAAI,CAACtD,yBAAD,EAA8BJ,iBAAiB4D,uBAAjB,EAAlC,CAA8E,OAE9EzD,OAAO0D,KAAP,CAAa,4BAAb,EACAvD,UAAY,KAAZ,CACAhB,YAAYwE,0BAAZ,CAAuC1D,0BAA0B2D,EAAjE,CAAqErE,mBAAmBsE,OAAnB,GAA+B,IAApG,CAA0GtE,mBAAmBuE,eAAnB,EAA1G,EAEA,GAAI5D,cAAJ,CAAoB,CAChBA,eAAiB,KAAjB,CACH,CAED6D,mBAAmB,CAAnB,EACH,CAED,QAASC,KAAT,EAAgB,CACZ,GAAI7D,SAAJ,CAAe,OAEfH,OAAO0D,KAAP,CAAa,2BAAb,EACA1D,OAAO0D,KAAP,CAAahE,KAAO,4BAApB,EACAS,UAAY,IAAZ,CACA8D,aAAa3D,eAAb,EACH,CAED,QAAS4D,qBAAT,CAA8BxE,IAA9B,CAAoCkE,EAApC,CAAwC,CACpCjD,gBAAgBiD,EAAhB,EAAsBjD,gBAAgBiD,EAAhB,GAAuB,EAA7C,CACA,GAAMO,oBAAqB7E,cAAc8E,qBAAd,CAAoC1E,IAApC,CAA0CkE,EAA1C,CAA3B,CAEA,GAAIjD,gBAAgBiD,EAAhB,EAAoBlE,IAApB,GAA6ByE,kBAAjC,CAAqD,CACjDnE,OAAOqE,IAAP,CAAY,eAAiB3E,IAAjB,CAAwB,0BAAxB,CAAqDiB,gBAAgBiD,EAAhB,EAAoBlE,IAApB,CAArD,CAAiF,MAAjF,CAA0FyE,kBAAtG,EACAxD,gBAAgBiD,EAAhB,EAAoBlE,IAApB,EAA4ByE,kBAA5B,CACA,MAAO,KAAP,CACH,CACD,MAAO,MAAP,CAEH,CAED,QAASG,SAAT,EAAoB,CAChB,GAAInE,WAAaC,8BAAb,EACCb,mBAAmBgF,QAAnB,IAAiC,CAACzE,SAAS0E,GAAT,GAAeC,SAAf,CAAyBC,mBAD5D,EAEC,CAAChF,OAASiF,oBAAUC,eAAnB,EAAsClF,OAASiF,oBAAUE,IAA1D,GAAmE,CAACrF,eAAesF,aAAf,EAFrE,EAGAjF,iBAAiB4D,uBAAjB,EAHJ,CAGgD,CAC5CO,OACA,OACH,CAEDe,kCAEA,GAAMC,eAAgBnE,oBAAoBoE,MAApB,CAA6B,CAAnD,CACA;AACA,GAAIlE,iBAAmBmE,MAAMtE,eAAN,CAAnB,EAA6CE,WAA7C,EAA4DkE,aAA5D,EACAd,qBAAqBxE,IAArB,CAA2BD,QAA3B,CADA,EAEAgB,gBAAgB0E,OAAhB,CAAwBzF,IAAxB,CAA8BO,yBAA9B,CAAyDO,aAAzD,CAFJ,CAE6E,CAEzE,GAAM4E,iBAAkB,QAAlBA,gBAAkB,EAAY,CAChC,GAAI,CAACnF,0BAA0BoF,OAA1B,GAAsCzE,eAAtC,EAAyDE,WAA1D,GAA2E,CAACC,eAAhF,CAAkG,CAC9F,GAAID,WAAJ,CAAiB,CACbd,OAAO0D,KAAP,CAAa,oBAAsBhE,IAAtB,CAA6B,wBAA7B,CAAwDO,0BAA0B2D,EAA/F,EACA7C,gBAAkBnB,gBAAgB0F,aAAhB,CAA8B5F,IAA9B,IAAwC6F,0BAAgBC,gCAA1E,CACA,GAAIzE,iBAAmBlB,iBAAiB4F,aAAxC,CAAuD,CACnD5F,iBAAiB4F,aAAjB,GACH,CACD3E,YAAc,KAAd,CACH,CAPD,IAOO,CACHd,OAAO0D,KAAP,CAAa,gEAAkEzD,0BAA0B2D,EAAzG,EACH,CACD5E,SAAS0G,OAAT,CAAiBhE,iBAAOiE,oBAAxB,CAA8C,CAC1CC,OAAQ7F,QADkC,CAE1CN,SAAUA,QAFgC,CAG1CoG,UAAWnG,IAH+B,CAI1CoG,iBAAkB7F,0BAA0B2D,EAJF,CAA9C,EAMAhD,gBAAkBX,0BAA0BoF,OAA5C,CACApE,qBAAuB,KAAvB,CACH,CAnBD,IAmBO,CACH,GAAM8E,aAAclF,oBAAoBmF,KAApB,EAApB,CAEA,GAAID,aAAeA,YAAYE,uBAAZ,EAAnB,CAA0D,CACtD;AACAjH,SAAS0G,OAAT,CAAiBhE,iBAAOiE,oBAAxB,CAA8C,CAC1CC,OAAQ7F,QADkC,CAE1CN,SAAUA,QAFgC,CAG1CoG,UAAWnG,IAH+B,CAI1CoG,iBAAkBC,YAAYD,gBAJY,CAA9C,EAMA7E,qBAAuB,KAAvB,CACH,CATD,IASO,CACHjC,SAAS0G,OAAT,CAAiBhE,iBAAOwE,qBAAxB,CAA+C,CAC3CN,OAAQ7F,QADmC,CAE3CN,SAAUA,QAFiC,CAG3CoG,UAAWnG,IAHgC,CAI3Ca,WAAYA,UAJ+B,CAK3CwF,YAAaA,WAL8B,CAA/C,EAOA9E,qBAAuB,IAAvB,CAEAkF,QAAQC,GAAR,CAAY,aAAZ,EACAD,QAAQC,GAAR,CAAYrG,QAAZ,EACAoG,QAAQC,GAAR,CAAY3G,QAAZ,EACA0G,QAAQC,GAAR,CAAY1G,IAAZ,EACAyG,QAAQC,GAAR,CAAY7F,UAAZ,EACA4F,QAAQC,GAAR,CAAYL,WAAZ,EACH,CACJ,CACJ,CAlDD,CAoDAM,wBAAwB,IAAxB,EACA,GAAI,CAACrB,aAAD,EAAkB/D,oBAAtB,CAA4C,CACxC3B,cAAc2B,oBAAd,CAAmCvB,IAAnC,EACH,CAED0F,kBAEH,CA/DD,IA+DO,CACHrB,mBAAmB,GAAnB,EACH,CACJ,CAED,QAASgB,gCAAT,EAA2C,CACvC;AACA;AACA,GAAMuB,MAAO/G,mBAAmBsE,OAAnB,EAAb,CACA,GAAI0C,iBAAkB,GAAtB,CAEA,GAAIrB,MAAMjF,0BAA0BuG,gBAAhC,CAAJ,CAAuD,CAAE;AACrD;AACA;AACA,GAAMC,gBAAiBtH,YAAYuH,wBAAZ,CAAqCzG,0BAA0B0G,SAA1B,CAAoCjH,IAAzE,CAAvB,CACA6G,gBAAkBE,eAAiBA,eAAeG,QAAf,CAA0B,GAA3C,CAAiD,GAAnE,CACH,CACD,GAAMC,SAAUxH,cAAcyH,WAAd,CAA0B,CACtCC,MAAOC,wBAAcC,uBADiB,CAEtCX,KAAMA,KAAOC,eAFyB,CAGtCW,UAAW,CAH2B,CAA1B,EAIb,CAJa,CAAhB,CAMA,GAAIL,SAAWhG,oBAAoBsG,OAApB,CAA4BN,OAA5B,IAAyC,CAAC,CAArD,EAA0D,CAAC3H,QAAQkI,cAAR,CAAuBzH,QAAvB,CAA/D,CAAiG,CAC7F,GAAM0H,uBAAwBvH,SAAS0E,GAAT,GAAeC,SAAf,CAAyB6C,iBAAvD,CACA,GAAMC,aAAc1H,iBAAiB2H,cAAjB,EAApB,CACA,GAAMC,kBAAmBnI,cAAcoI,sBAAd,CAAqChI,IAArC,CAAzB,CAEA;AACA,GAAMiI,cAAe,CAAC/H,gBAAgBgI,cAAhB,CAA+Bf,QAAQF,SAAvC,CAAD,EAAsD/G,gBAAgB0F,aAAhB,CAA8BuB,QAAQF,SAAR,CAAkBjH,IAAhD,IAA0D6F,0BAAgBsC,+BAArJ,CACA,GAAMC,gBAAiBjB,QAAQxB,OAAR,CAAkBpF,0BAA0BoF,OAAnE,CAEA,GAAIgC,wBAA0BM,cAAgBG,cAA1C,GAA6DP,aAAehB,eAA5E,EAA+FkB,mBAAqBM,2BAAiBC,YAAzI,CAAuJ,CACnJC,eAAepB,OAAf,EACA3F,qBAAuB,IAAvB,CACAlB,OAAO0D,KAAP,CAAa,wCAAb,CAAuDmD,QAAQqB,KAA/D,EACH,CAJD,IAIO,IAAIrB,QAAQxB,OAAR,CAAkBpF,0BAA0BoF,OAA5C,EAAuD,CAACtE,eAA5D,CAA6E,CAChF;AACAoH,cAAc5I,mBAAmBsE,OAAnB,GAA+B0D,WAA7C,EACH,CACJ,CACJ,CAED,QAASxD,mBAAT,CAA4BqE,KAA5B,CAAmC,CAC/BnE,aAAa3D,eAAb,EAEAA,gBAAkB+H,WAAW/D,QAAX,CAAqB8D,KAArB,CAAlB,CACH,CAED,QAAS/B,wBAAT,CAAkCU,KAAlC,CAAyC,CACrC,GAAI3G,iCAAmC2G,KAAvC,CAA+C,CAC3C3G,+BAAiC2G,KAAjC,CACH,CAFD,IAEO,CACH/G,OAAO0D,KAAP,CAAa,oDAAb,CAAmEqD,KAAnE,EACH,CACJ,CAED,QAASuB,mBAAT,CAA4BzB,OAA5B,CAAqC,CACjC,GAAIA,OAAJ,CAAa,CACTR,wBAAwB,IAAxB,EACAhH,cAAckJ,cAAd,CAA6B1B,OAA7B,EACH,CACJ,CAED,QAAS2B,oBAAT,CAA6B3B,OAA7B,CAAsC,CAClC,GAAIA,OAAJ,CAAa,CACT7G,OAAO0D,KAAP,CAAa,gCAAkCmD,QAAQ4B,GAAvD,EACApJ,cAAckJ,cAAd,CAA6B1B,OAA7B,EACH,CAHD,IAGO,CAAE;AACL,GAAItH,mBAAmBmJ,YAAnB,EAAJ,CAAuC,CACnC1I,OAAO0D,KAAP,CAAa,6FAAb,EACH,CACD2C,wBAAwB,KAAxB,EACAtC,mBAAmBjE,SAAS0E,GAAT,GAAeC,SAAf,CAAyBkE,iBAAzB,CAA6C,GAA7C,CAAmD,GAAtE,EACH,CACJ,CAED,QAASC,iBAAT,EAA4B,CACxB9H,YAAc,IAAd,CACH,CAED,QAASmH,eAAT,CAAwBpB,OAAxB,CAAiC,CAC7BhG,oBAAoBgI,IAApB,CAAyBhC,OAAzB,EACH,CAED,QAASiC,sBAAT,CAA+BpD,OAA/B,CAAwC,CACpC,GAAInG,oBAAsBF,aAA1B,CAAyC,CACrC,GAAM0J,MAAO1J,cAAcyH,WAAd,CAA0B,CACnCC,MAAOC,wBAAcC,uBADc,CAEnCX,KAAM/G,mBAAmBsE,OAAnB,EAF6B,CAGnCqD,UAAW,CAHwB,CAA1B,EAIV,CAJU,CAAb,CAKA,GAAI6B,MAAQxJ,mBAAmBsE,OAAnB,IAAgCkF,KAAKC,SAAjD,CAA4D,CACxD,GAAI,CAAC,CAACtI,oBAAoBiG,SAArB,EAAmCoC,KAAKpC,SAAL,CAAejH,IAAf,GAAwBgB,oBAAoBiG,SAApB,CAA8BjH,IAAtD,EAA8DqJ,KAAKpC,SAAL,CAAe/C,EAAf,GAAsBlD,oBAAoBiG,SAApB,CAA8B/C,EAAtJ,GAA8J8B,OAAlK,CAA2K,CACvK1G,SAAS0G,OAAT,CAAiBhE,iBAAOuH,qBAAxB,CAA+C,CAC3CpD,UAAWnG,IADgC,CAE3CwJ,aAAcxI,oBAAoBiG,SAFS,CAG3CwC,aAAcJ,KAAKpC,SAHwB,CAA/C,EAKH,CACD,GAAI,CAACoC,KAAK1D,OAAL,GAAiB3E,oBAAoB2E,OAArC,EAAgD0D,KAAKK,eAAL,GAAyB1I,oBAAoB0I,eAA9F,GAAkH1D,OAAtH,CAA+H,CAC3H1G,SAAS0G,OAAT,CAAiBhE,iBAAO2H,uBAAxB,CAAiD,CAC7CxD,UAAWnG,IADkC,CAE7C4J,WAAY5I,oBAAoB2E,OAFa,CAG7CkE,WAAYR,KAAK1D,OAH4B,CAAjD,EAKH,CACD3E,oBAAsB,CAClBiG,UAAWoC,KAAKpC,SADE,CAElBtB,QAAS0D,KAAK1D,OAFI,CAGlB+D,gBAAiBL,KAAKK,eAHJ,CAAtB,CAKH,CACJ,CACJ,CAED,QAASpH,kBAAT,CAA2BwH,CAA3B,CAA8B,CAC1B,GAAIA,EAAE3C,OAAF,CAAUF,SAAV,CAAoB8C,UAApB,CAA+B7F,EAA/B,GAAsCnE,QAAtC,EAAkD+J,EAAE3C,OAAF,CAAUhB,SAAV,GAAwBnG,IAA9E,CAAoF,OAEpFsE,OACAqC,wBAAwB,KAAxB,EACArG,OAAOqE,IAAP,WAAsB5E,QAAtB,iBACH,CAED,QAASqC,2BAAT,CAAoC0H,CAApC,CAAuC,CACnC,GAAIA,EAAE3C,OAAF,CAAUF,SAAV,CAAoB8C,UAApB,CAA+B7F,EAA/B,GAAsCnE,QAAtC,EAAkD+J,EAAE3C,OAAF,CAAUhB,SAAV,GAAwBnG,IAA9E,CAAoF,OAEpFM,OAAOqE,IAAP,CAAY,mCAAZ,CAAiDmF,EAAE3C,OAAF,CAAY2C,EAAE3C,OAAF,CAAU4B,GAAtB,CAA4B,WAA7E,CAA0Fe,EAAE3C,OAAF,CAAU6C,KAAV,CAAkB,WAAaF,EAAE3C,OAAF,CAAU6C,KAAzC,CAAiD,EAA3I,EAEA,GAAIxK,QAAQkI,cAAR,CAAuBzH,QAAvB,CAAJ,CAAsC,CAClC0G,wBAAwB,KAAxB,EACH,CAED,GAAImD,EAAEG,KAAF,EAAWH,EAAE3C,OAAF,CAAU+C,eAArB,EAAwC,CAACzJ,SAA7C,CAAwD,CACpD8H,eAAeuB,EAAE3C,OAAjB,EACAR,wBAAwB,KAAxB,EACAtC,mBAAmB,CAAnB,EACH,CAED,GAAIhD,eAAJ,CAAqB,CACjBC,aAAewI,EAAE3C,OAAjB,CACH,CACJ,CAED,QAAS/D,sBAAT,EAAiC,CAC7BgG,sBAAsB,IAAtB,EACH,CAED,QAAS1G,gBAAT,CAAyBoH,CAAzB,CAA4B,CACxB,GAAIA,EAAE/J,QAAF,GAAeA,QAAf,EAA2B+J,EAAE3D,SAAF,GAAgBnG,IAA/C,CAAqD,OAErD,GAAIqB,iBAAmB,CAACmE,MAAMsE,EAAER,SAAR,CAAxB,CAA4C,CACxCjI,gBAAkB,KAAlB,CACA1B,cAAcwK,kBAAd,CAAiC7I,YAAjC,EACH,CAEDqF,wBAAwB,KAAxB,EACA,GAAInF,sBAAwB,CAACgE,MAAMsE,EAAER,SAAR,CAA7B,CAAiD,CAC7C;AACA;AACA;AACA,GAAMc,aAAcvK,mBAAmBsE,OAAnB,EAApB,CACA,GAAMkG,aAAcP,EAAER,SAAF,CAAc/I,0BAA0BuG,gBAA5D,CACA,GAAMD,iBAAkBtG,0BAA0BuG,gBAA1B,CAA6C,GAArE,CACA,GAAKsD,YAAcvD,eAAf,EAAmCwD,WAAvC,CAAoD,CAChDhG,mBAAmB,CAAnB,EACH,CAFD,IAEO,CACHA,mBAAmB,CAACgG,aAAeD,YAAcvD,eAA7B,CAAD,EAAkD,IAArE,EACH,CACDrF,qBAAuB,KAAvB,CACH,CAbD,IAaO,CACH6C,mBAAmB,CAAnB,EACH,CACJ,CAED,QAASb,2BAAT,CAAoCsG,CAApC,CAAuC,CACnC,GAAIA,EAAE/J,QAAF,GAAeA,QAAf,EAA2B+J,EAAE3D,SAAF,GAAgBnG,IAA/C,CAAqD,OAErDM,OAAOqE,IAAP,CAAY,uCAAyCmF,EAAE3C,OAAF,CAAU4B,GAAnD,CAAyD,mBAArE,EACA,GAAI,CAAClJ,mBAAmByK,SAAnB,EAAD,EAAmC,CAAClJ,WAAxC,CAAqD,CACjDd,OAAOqE,IAAP,CAAY,uCAAyCmF,EAAE3C,OAAF,CAAU4B,GAAnD,CAAyD,iFAArE,EACAR,eAAeuB,EAAE3C,OAAjB,EACH,CACDR,wBAAwB,KAAxB,EACAtC,mBAAmB,CAAnB,EACH,CAED,QAASnC,oBAAT,CAA6B4H,CAA7B,CAAgC,CAC5B,GAAIA,EAAE5D,MAAF,CAASqE,OAAT,KAAuBvK,IAAvB,EAA+B8J,EAAE5D,MAAF,CAASsE,WAAT,KAA2BzK,QAA9D,CAAwE,OACxE;AACH,CAED,QAAS2D,qBAAT,CAA8BoG,CAA9B,CAAiC,CAC7B,GAAI9J,OAAS8J,EAAE3D,SAAX,EAAwBpG,WAAa+J,EAAE/J,QAA3C,CAAqD,OACrDuE,OACH,CAED,QAAS9B,gBAAT,CAAyBsH,CAAzB,CAA4B,CACxB,GAAIA,EAAE/J,QAAF,GAAeA,QAAf,EAA2B+J,EAAE3D,SAAF,GAAgBnG,IAA/C,CAAqD,OAErD,GAAIqB,iBAAmBjB,SAAS0E,GAAT,GAAeC,SAAf,CAAyB0F,wBAAhD,CAA0E,CACtE;AACA;AACA5K,mBAAmB6K,IAAnB,CAAwB7K,mBAAmBsE,OAAnB,GAA+B,KAAvD,CAA8D,KAA9D,CAAqE,IAArE,EACH,CAED;AACA,GAAI2F,EAAEa,sBAAF,EAA4Bb,EAAEc,aAAlC,CAAiD,CAC7C9G,QACH,CACJ,CAED,QAASlB,gBAAT,CAAyBkH,CAAzB,CAA4B,CACxB,GAAIA,EAAE/J,QAAF,GAAeA,QAAf,EAA2B+J,EAAE3D,SAAF,GAAgBnG,IAA/C,CAAqD,OAErD;AACAsE,OACAqC,wBAAwB,KAAxB,EACH,CAED,QAASrD,sBAAT,EAAiC,CAC7B3D,cAAckL,aAAd,GACAvG,OACH,CAED,QAAStB,kBAAT,EAA6B,CACzB,GAAIvC,WAAa,CAACL,SAAS0E,GAAT,GAAeC,SAAf,CAAyBC,mBAA3C,CAAgE,CAC5DlB,QACH,CACJ,CAED,QAAShB,kBAAT,CAA2BgH,CAA3B,CAA8B,CAC1BrB,cAAcqB,EAAEgB,QAAhB,EACAC,mBAAmB,CAAnB,EAEA,GAAItK,SAAJ,CAAe,CACXqD,QACH,CAED,GAAMkH,SAAUzK,0BAA0B0K,SAA1B,EAAuCpL,kBAAvC,CAA4DU,0BAA0B0K,SAA1B,CAAoCC,GAApC,CAA0CrL,mBAAmBsE,OAAnB,EAAtG,CAAqIgH,GAArJ,CACA1L,YAAY2L,wBAAZ,CAAqC,CACjCJ,QAASA,OADwB,CAArC,EAIA,GAAI,CAACtK,8BAAL,CAAqC,CACjC;AACA2D,mBAAmB,CAAnB,EACH,CAHD,IAGO,CACH;AACA1E,cAAckL,aAAd,GACH,CACJ,CAED,QAAS3H,sBAAT,CAA+B4G,CAA/B,CAAkC,CAC9BrK,YAAY4L,0BAAZ,CAAuC,CAACC,cAAexB,EAAEyB,YAAF,CAAeC,QAAf,EAAhB,CAAvC,EACH,CAED,QAAS/C,cAAT,CAAuBC,KAAvB,CAA8B,CAC1B7H,WAAa6H,KAAb,CACH,CAED,QAASqC,mBAAT,CAA4BrC,KAA5B,CAAmC,CAC/B/H,gBAAkB+H,KAAlB,CACH,CAED,QAAS+C,mBAAT,EAA8B,CAC1B,MAAO9K,gBAAP,CACH,CAED,QAAS+K,gBAAT,EAA2B,CACvB,MAAO3K,iBAAgB2K,eAAhB,CAAgC1L,IAAhC,CAAsCO,yBAAtC,CAAP,CACH,CAED,QAASgK,QAAT,EAAmB,CACf,MAAOvK,KAAP,CACH,CAED,QAASwK,YAAT,EAAuB,CACnB,MAAOzK,SAAP,CACH,CAED,QAAS4B,qBAAT,EAAgC,CAC5BJ,qBAAuB,IAAvB,CACAb,+BAAiC,KAAjC,CACAC,gBAAkB,CAAlB,CACAE,WAAasK,GAAb,CACA3K,eAAiB,IAAjB,CACAU,gBAAkBiK,GAAlB,CACAnK,oBAAsB,CAClBiG,UAAW0E,SADO,CAElBhG,QAASwF,GAFS,CAGlBzB,gBAAiByB,GAHC,CAAtB,CAKAlK,gBAAkB,EAAlB,CACAE,oBAAsB,EAAtB,CACAV,UAAY,IAAZ,CACAW,YAAc,KAAd,CACAC,gBAAkB,KAAlB,CACAC,aAAe,IAAf,CACAE,qBAAuB,KAAvB,CACH,CAED,QAASoK,MAAT,EAAiB,CACb;AACAtM,SAASuM,GAAT,CAAa7J,iBAAOC,mBAApB,CAAyCC,mBAAzC,CAA8D,IAA9D,EACA5C,SAASuM,GAAT,CAAa7J,iBAAOG,0BAApB,CAAgDC,0BAAhD,CAA4E,IAA5E,EACA9C,SAASuM,GAAT,CAAa7J,iBAAOK,gBAApB,CAAsCC,iBAAtC,CAAyD,IAAzD,EACAhD,SAASuM,GAAT,CAAa7J,iBAAOO,cAApB,CAAoCC,eAApC,CAAqD,IAArD,EACAlD,SAASuM,GAAT,CAAa7J,iBAAOS,2BAApB,CAAiDC,eAAjD,CAAkE,IAAlE,EACApD,SAASuM,GAAT,CAAa7J,iBAAOW,cAApB,CAAoCC,eAApC,CAAqD,IAArD,EACAtD,SAASuM,GAAT,CAAa7J,iBAAOa,gBAApB,CAAsCC,iBAAtC,CAAyD,IAAzD,EACAxD,SAASuM,GAAT,CAAa7J,iBAAOe,gBAApB,CAAsCC,iBAAtC,CAAyD,IAAzD,EACA1D,SAASuM,GAAT,CAAa7J,iBAAOiB,qBAApB,CAA2CC,qBAA3C,CAAkE,IAAlE,EACA5D,SAASuM,GAAT,CAAa7J,iBAAOmB,qBAApB,CAA2CC,qBAA3C,CAAkE,IAAlE,EACA9D,SAASuM,GAAT,CAAa7J,iBAAOqB,qBAApB,CAA2CC,qBAA3C,CAAkE,IAAlE,EACAhE,SAASuM,GAAT,CAAa7J,iBAAOuB,0BAApB,CAAgDC,0BAAhD,CAA4E,IAA5E,EACAlE,SAASuM,GAAT,CAAa7J,iBAAOyB,mBAApB,CAAyCC,oBAAzC,CAA+D,IAA/D,EAEAY,OACA8E,sBAAsB,KAAtB,EACAzH,uBACH,CAEDtB,SAAW,CACPuB,WAAYA,UADL,CAEP2I,QAASA,OAFF,CAGPC,YAAaA,WAHN,CAIP7G,yBAA0BA,wBAJnB,CAKP8E,cAAeA,aALR,CAMPsC,mBAAoBA,kBANb,CAOPU,mBAAoBA,kBAPb,CAQPvC,iBAAkBA,gBARX,CASPrF,UAAWA,SATJ,CAUPC,MAAOA,KAVA,CAWPQ,KAAMA,IAXC,CAYPsH,MAAOA,KAZA,CAaPF,gBAAiBA,eAbV,CAcP9C,mBAAoBA,kBAdb,CAePE,oBAAqBA,mBAfd,CAAX,CAkBArH,QAEA,MAAOpB,SAAP,CACH,CAjkBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmkBAlB,mBAAmB2M,qBAAnB,CAA2C,oBAA3C,C,gBACeC,uBAAaC,eAAb,CAA6B7M,kBAA7B,C","file":"ScheduleController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport BufferLevelRule from '../rules/scheduling/BufferLevelRule';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport MediaController from './MediaController';\n\nfunction ScheduleController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const fragmentModel = config.fragmentModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const textController = config.textController;\n    const streamId = config.streamId;\n    const type = config.type;\n    const mimeType = config.mimeType;\n    const mediaController = config.mediaController;\n    const bufferController = config.bufferController;\n    const settings = config.settings;\n\n    let instance,\n        logger,\n        currentRepresentationInfo,\n        initialRequest,\n        isStopped,\n        isFragmentProcessingInProgress,\n        timeToLoadDelay,\n        scheduleTimeout,\n        seekTarget,\n        hasVideoTrack,\n        bufferLevelRule,\n        lastFragmentRequest,\n        topQualityIndex,\n        lastInitQuality,\n        replaceRequestArray,\n        switchTrack,\n        replacingBuffer,\n        mediaRequest,\n        checkPlaybackQuality,\n        isReplacementRequest;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n    }\n\n    function initialize(_hasVideoTrack) {\n        hasVideoTrack = _hasVideoTrack;\n\n        bufferLevelRule = BufferLevelRule(context).create({\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            textController: textController,\n            settings: settings\n        });\n\n        //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.on(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.on(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.on(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, this);\n    }\n\n    function setCurrentRepresentation(representationInfo) {\n        currentRepresentationInfo = representationInfo;\n    }\n\n    function isStarted() {\n        return (isStopped === false);\n    }\n\n    function start() {\n        if (isStarted()) return;\n        if (!currentRepresentationInfo || bufferController.getIsBufferingCompleted()) return;\n\n        logger.debug('Schedule Controller starts');\n        isStopped = false;\n        dashMetrics.createPlaylistTraceMetrics(currentRepresentationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n\n        if (initialRequest) {\n            initialRequest = false;\n        }\n\n        startScheduleTimer(0);\n    }\n\n    function stop() {\n        if (isStopped) return;\n\n        logger.debug('Schedule Controller stops');\n        logger.debug(type + ' Schedule Controller stops');\n        isStopped = true;\n        clearTimeout(scheduleTimeout);\n    }\n\n    function hasTopQualityChanged(type, id) {\n        topQualityIndex[id] = topQualityIndex[id] || {};\n        const newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\n\n        if (topQualityIndex[id][type] != newTopQualityIndex) {\n            logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\n            topQualityIndex[id][type] = newTopQualityIndex;\n            return true;\n        }\n        return false;\n\n    }\n\n    function schedule() {\n        if (isStopped || isFragmentProcessingInProgress ||\n            (playbackController.isPaused() && !settings.get().streaming.scheduleWhilePaused) ||\n            ((type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) && !textController.isTextEnabled()) ||\n            bufferController.getIsBufferingCompleted()) {\n            stop();\n            return;\n        }\n\n        validateExecutedFragmentRequest();\n\n        const isReplacement = replaceRequestArray.length > 0;\n        // bufferLevelRule.execute(type, currentRepresentationInfo, hasVideoTrack) checks the buffer length\n        if (replacingBuffer || isNaN(lastInitQuality) || switchTrack || isReplacement ||\n            hasTopQualityChanged(type, streamId) ||\n            bufferLevelRule.execute(type, currentRepresentationInfo, hasVideoTrack)) {\n\n            const getNextFragment = function () {\n                if ((currentRepresentationInfo.quality !== lastInitQuality || switchTrack) && (!replacingBuffer)) {\n                    if (switchTrack) {\n                        logger.debug('Switch track for ' + type + ', representation id = ' + currentRepresentationInfo.id);\n                        replacingBuffer = mediaController.getSwitchMode(type) === MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE;\n                        if (replacingBuffer && bufferController.replaceBuffer) {\n                            bufferController.replaceBuffer();\n                        }\n                        switchTrack = false;\n                    } else {\n                        logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\n                    }\n                    eventBus.trigger(Events.INIT_FRAGMENT_NEEDED, {\n                        sender: instance,\n                        streamId: streamId,\n                        mediaType: type,\n                        representationId: currentRepresentationInfo.id\n                    });\n                    lastInitQuality = currentRepresentationInfo.quality;\n                    checkPlaybackQuality = false;\n                } else {\n                    const replacement = replaceRequestArray.shift();\n\n                    if (replacement && replacement.isInitializationRequest()) {\n                        // To be sure the specific init segment had not already been loaded\n                        eventBus.trigger(Events.INIT_FRAGMENT_NEEDED, {\n                            sender: instance,\n                            streamId: streamId,\n                            mediaType: type,\n                            representationId: replacement.representationId\n                        });\n                        checkPlaybackQuality = false;\n                    } else {\n                        eventBus.trigger(Events.MEDIA_FRAGMENT_NEEDED, {\n                            sender: instance,\n                            streamId: streamId,\n                            mediaType: type,\n                            seekTarget: seekTarget,\n                            replacement: replacement\n                        });\n                        checkPlaybackQuality = true;\n\n                        console.log('===========');\n                        console.log(instance);\n                        console.log(streamId);\n                        console.log(type);\n                        console.log(seekTarget);\n                        console.log(replacement);\n                    }\n                }\n            };\n\n            setFragmentProcessState(true);\n            if (!isReplacement && checkPlaybackQuality) {\n                abrController.checkPlaybackQuality(type);\n            }\n\n            getNextFragment();\n\n        } else {\n            startScheduleTimer(500);\n        }\n    }\n\n    function validateExecutedFragmentRequest() {\n        // Validate that the fragment request executed and appended into the source buffer is as\n        // good of quality as the current quality and is the correct media track.\n        const time = playbackController.getTime();\n        let safeBufferLevel = 1.5;\n\n        if (isNaN(currentRepresentationInfo.fragmentDuration)) { //fragmentDuration of representationInfo is not defined,\n            // call metrics function to have data in the latest scheduling info...\n            // if no metric, returns 0. In this case, rule will return false.\n            const schedulingInfo = dashMetrics.getCurrentSchedulingInfo(currentRepresentationInfo.mediaInfo.type);\n            safeBufferLevel = schedulingInfo ? schedulingInfo.duration * 1.5 : 1.5;\n        }\n        const request = fragmentModel.getRequests({\n            state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n            time: time + safeBufferLevel,\n            threshold: 0\n        })[0];\n\n        if (request && replaceRequestArray.indexOf(request) === -1 && !adapter.getIsTextTrack(mimeType)) {\n            const fastSwitchModeEnabled = settings.get().streaming.fastSwitchEnabled;\n            const bufferLevel = bufferController.getBufferLevel();\n            const abandonmentState = abrController.getAbandonmentStateFor(type);\n\n            // Only replace on track switch when NEVER_REPLACE\n            const trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE;\n            const qualityChanged = request.quality < currentRepresentationInfo.quality;\n\n            if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== MetricsConstants.ABANDON_LOAD) {\n                replaceRequest(request);\n                isReplacementRequest = true;\n                logger.debug('Reloading outdated fragment at index: ', request.index);\n            } else if (request.quality > currentRepresentationInfo.quality && !replacingBuffer) {\n                // The buffer has better quality it in then what we would request so set append point to end of buffer!!\n                setSeekTarget(playbackController.getTime() + bufferLevel);\n            }\n        }\n    }\n\n    function startScheduleTimer(value) {\n        clearTimeout(scheduleTimeout);\n\n        scheduleTimeout = setTimeout(schedule, value);\n    }\n\n    function setFragmentProcessState (state) {\n        if (isFragmentProcessingInProgress !== state ) {\n            isFragmentProcessingInProgress = state;\n        } else {\n            logger.debug('isFragmentProcessingInProgress is already equal to', state);\n        }\n    }\n\n    function processInitRequest(request) {\n        if (request) {\n            setFragmentProcessState(true);\n            fragmentModel.executeRequest(request);\n        }\n    }\n\n    function processMediaRequest(request) {\n        if (request) {\n            logger.debug('Next fragment request url is ' + request.url);\n            fragmentModel.executeRequest(request);\n        } else { // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\n            if (playbackController.getIsDynamic()) {\n                logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\n            }\n            setFragmentProcessState(false);\n            startScheduleTimer(settings.get().streaming.lowLatencyEnabled ? 100 : 500);\n        }\n    }\n\n    function switchTrackAsked() {\n        switchTrack = true;\n    }\n\n    function replaceRequest(request) {\n        replaceRequestArray.push(request);\n    }\n\n    function completeQualityChange(trigger) {\n        if (playbackController && fragmentModel) {\n            const item = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                time: playbackController.getTime(),\n                threshold: 0\n            })[0];\n            if (item && playbackController.getTime() >= item.startTime) {\n                if ((!lastFragmentRequest.mediaInfo || (item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id)) && trigger) {\n                    eventBus.trigger(Events.TRACK_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldMediaInfo: lastFragmentRequest.mediaInfo,\n                        newMediaInfo: item.mediaInfo\n                    });\n                }\n                if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\n                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldQuality: lastFragmentRequest.quality,\n                        newQuality: item.quality\n                    });\n                }\n                lastFragmentRequest = {\n                    mediaInfo: item.mediaInfo,\n                    quality: item.quality,\n                    adaptationIndex: item.adaptationIndex\n                };\n            }\n        }\n    }\n\n    function onStreamCompleted(e) {\n        if (e.request.mediaInfo.streamInfo.id !== streamId || e.request.mediaType !== type) return;\n\n        stop();\n        setFragmentProcessState(false);\n        logger.info(`Stream ${streamId} is complete`);\n    }\n\n    function onFragmentLoadingCompleted(e) {\n        if (e.request.mediaInfo.streamInfo.id !== streamId || e.request.mediaType !== type) return;\n\n        logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined', e.request.range ? ', Range:' + e.request.range : '');\n\n        if (adapter.getIsTextTrack(mimeType)) {\n            setFragmentProcessState(false);\n        }\n\n        if (e.error && e.request.serviceLocation && !isStopped) {\n            replaceRequest(e.request);\n            setFragmentProcessState(false);\n            startScheduleTimer(0);\n        }\n\n        if (replacingBuffer) {\n            mediaRequest = e.request;\n        }\n    }\n\n    function onPlaybackTimeUpdated() {\n        completeQualityChange(true);\n    }\n\n    function onBytesAppended(e) {\n        if (e.streamId !== streamId || e.mediaType !== type) return;\n\n        if (replacingBuffer && !isNaN(e.startTime)) {\n            replacingBuffer = false;\n            fragmentModel.addExecutedRequest(mediaRequest);\n        }\n\n        setFragmentProcessState(false);\n        if (isReplacementRequest && !isNaN(e.startTime)) {\n            //replace requests process is in progress, call schedule in n seconds.\n            //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\n            //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\n            const currentTime = playbackController.getTime();\n            const fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\n            const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n            if ((currentTime + safeBufferLevel) >= fragEndTime) {\n                startScheduleTimer(0);\n            } else {\n                startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\n            }\n            isReplacementRequest = false;\n        } else {\n            startScheduleTimer(0);\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e.streamId !== streamId || e.mediaType !== type) return;\n\n        logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has been aborted');\n        if (!playbackController.isSeeking() && !switchTrack) {\n            logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\n            replaceRequest(e.request);\n        }\n        setFragmentProcessState(false);\n        startScheduleTimer(0);\n    }\n\n    function onDataUpdateStarted(e) {\n        if (e.sender.getType() !== type || e.sender.getStreamId() !== streamId) return;\n        // stop();\n    }\n\n    function onBufferingCompleted(e) {\n        if (type !== e.mediaType || streamId !== e.streamId) return;\n        stop();\n    }\n\n    function onBufferCleared(e) {\n        if (e.streamId !== streamId || e.mediaType !== type) return;\n\n        if (replacingBuffer && settings.get().streaming.flushBufferAtTrackSwitch) {\n            // For some devices (like chromecast) it is necessary to seek the video element to reset the internal decoding buffer,\n            // otherwise audio track switch will be effective only once after previous buffered track is consumed\n            playbackController.seek(playbackController.getTime() + 0.001, false, true);\n        }\n\n        // (Re)start schedule once buffer has been pruned after a QuotaExceededError\n        if (e.hasEnoughSpaceToAppend && e.quotaExceeded) {\n            start();\n        }\n    }\n\n    function onQuotaExceeded(e) {\n        if (e.streamId !== streamId || e.mediaType !== type) return;\n\n        // Stop scheduler (will be restarted once buffer is pruned)\n        stop();\n        setFragmentProcessState(false);\n    }\n\n    function onURLResolutionFailed() {\n        fragmentModel.abortRequests();\n        stop();\n    }\n\n    function onPlaybackStarted() {\n        if (isStopped || !settings.get().streaming.scheduleWhilePaused) {\n            start();\n        }\n    }\n\n    function onPlaybackSeeking(e) {\n        setSeekTarget(e.seekTime);\n        setTimeToLoadDelay(0);\n\n        if (isStopped) {\n            start();\n        }\n\n        const latency = currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\n        dashMetrics.updateManifestUpdateInfo({\n            latency: latency\n        });\n\n        if (!isFragmentProcessingInProgress) {\n            // No pending request, request next segment at seek target\n            startScheduleTimer(0);\n        } else {\n            // Abort current request\n            fragmentModel.abortRequests();\n        }\n    }\n\n    function onPlaybackRateChanged(e) {\n        dashMetrics.updatePlayListTraceMetrics({playbackspeed: e.playbackRate.toString()});\n    }\n\n    function setSeekTarget(value) {\n        seekTarget = value;\n    }\n\n    function setTimeToLoadDelay(value) {\n        timeToLoadDelay = value;\n    }\n\n    function getTimeToLoadDelay() {\n        return timeToLoadDelay;\n    }\n\n    function getBufferTarget() {\n        return bufferLevelRule.getBufferTarget(type, currentRepresentationInfo);\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamId() {\n        return streamId;\n    }\n\n    function resetInitialSettings() {\n        checkPlaybackQuality = true;\n        isFragmentProcessingInProgress = false;\n        timeToLoadDelay = 0;\n        seekTarget = NaN;\n        initialRequest = true;\n        lastInitQuality = NaN;\n        lastFragmentRequest = {\n            mediaInfo: undefined,\n            quality: NaN,\n            adaptationIndex: NaN\n        };\n        topQualityIndex = {};\n        replaceRequestArray = [];\n        isStopped = true;\n        switchTrack = false;\n        replacingBuffer = false;\n        mediaRequest = null;\n        isReplacementRequest = false;\n    }\n\n    function reset() {\n        //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.off(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.off(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.off(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.off(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, this);\n\n        stop();\n        completeQualityChange(false);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        getType: getType,\n        getStreamId: getStreamId,\n        setCurrentRepresentation: setCurrentRepresentation,\n        setSeekTarget: setSeekTarget,\n        setTimeToLoadDelay: setTimeToLoadDelay,\n        getTimeToLoadDelay: getTimeToLoadDelay,\n        switchTrackAsked: switchTrackAsked,\n        isStarted: isStarted,\n        start: start,\n        stop: stop,\n        reset: reset,\n        getBufferTarget: getBufferTarget,\n        processInitRequest: processInitRequest,\n        processMediaRequest: processMediaRequest\n    };\n\n    setup();\n\n    return instance;\n}\n\nScheduleController.__dashjs_factory_name = 'ScheduleController';\nexport default FactoryMaker.getClassFactory(ScheduleController);\n"]}
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "path", "./node/process"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var path_1 = require("path");
    var process_1 = require("./node/process");
    function resolveEnvironments(capabilities, environments, available) {
        environments = environments.map(expandPwd);
        if (available) {
            environments = normalizeBrowserNames(environments, available);
        }
        var flatEnvironments = createPermutations(capabilities, environments);
        var expandedEnvironments = flatEnvironments.map(function (environment) {
            var browserVersion = resolveVersions(environment, available);
            if (browserVersion == null) {
                return environment;
            }
            return tslib_1.__assign({}, environment, { browserVersion: browserVersion, version: browserVersion });
        });
        return createPermutations({}, expandedEnvironments).map(normalizeEnvironment);
    }
    exports.default = resolveEnvironments;
    function expandPwd(value) {
        if (value == null) {
            return value;
        }
        if (typeof value === 'string' && /{pwd}/.test(value)) {
            return path_1.normalize(value.replace(/{pwd}/g, process_1.default.cwd()));
        }
        if (Array.isArray(value)) {
            return value.map(expandPwd);
        }
        if (typeof value === 'object') {
            return Object.keys(value).reduce(function (newObj, key) {
                var _a;
                return (tslib_1.__assign({}, newObj, (_a = {}, _a[key] = expandPwd(value[key]), _a)));
            }, {});
        }
        return value;
    }
    function normalizeEnvironment(env) {
        var normEnv = tslib_1.__assign({}, env);
        var browserVersion = env.browserVersion || env.version;
        if (browserVersion != null) {
            normEnv.version = browserVersion;
            normEnv.browserVersion = browserVersion;
        }
        var browserName = env.browserName || env.browser;
        normEnv.browser = browserName;
        normEnv.browserName = browserName;
        return normEnv;
    }
    function expandVersionRange(left, right, availableVersions) {
        if (availableVersions.indexOf(left) === -1 ||
            availableVersions.indexOf(right) === -1) {
            throw new Error('The version range ' + left + '..' + right + ' is unavailable');
        }
        return availableVersions.filter(function (version) {
            return version >= left && version <= right;
        });
    }
    function resolveVersionAlias(version, availableVersions) {
        if (version === 'insider preview') {
            if (availableVersions.length > 0 &&
                availableVersions.indexOf(version) === -1) {
                throw new Error("\"" + version + "\" is not available");
            }
            return version;
        }
        var pieces = version.split('-');
        if (pieces.length > 2) {
            throw new Error('Invalid alias syntax "' + version + '"');
        }
        pieces = pieces.map(function (piece) {
            return piece.trim();
        });
        if ((pieces.length === 2 &&
            (pieces[0] !== 'latest' || isNaN(Number(pieces[1])))) ||
            (pieces.length === 1 && isNaN(Number(pieces[0])) && pieces[0] !== 'latest')) {
            throw new Error('Invalid alias syntax "' + version + '"');
        }
        if (pieces[0] === 'latest') {
            var numericVersions = availableVersions
                .filter(function (version) { return !isNaN(Number(version)); })
                .sort(function (a, b) { return Number(a) - Number(b); });
            var offset = pieces.length === 2 ? Number(pieces[1]) : 0;
            if (offset > numericVersions.length) {
                throw new Error("Can't get " + version + "; " + numericVersions.length + " version" + (numericVersions.length !== 1 ? 's are' : ' is') + " available");
            }
            return numericVersions[numericVersions.length - 1 - offset];
        }
        else {
            return pieces[0];
        }
    }
    function splitVersions(versionSpec) {
        var versions = versionSpec.split('..');
        if (versions.length > 2) {
            throw new Error('Invalid version syntax');
        }
        return versions.map(function (version) {
            return version.trim();
        });
    }
    function getVersions(environment, available) {
        var versions = {};
        available
            .filter(function (availableEnvironment) {
            return !Object.keys(environment)
                .filter(function (key) {
                return key === 'browserName' ||
                    key === 'platformName' ||
                    key === 'platform' ||
                    key === 'platformVersion';
            })
                .some(function (envKey) {
                var key = envKey;
                if (!(key in availableEnvironment)) {
                    return false;
                }
                var value = environment[key];
                if (typeof value === 'string') {
                    value = value.toLowerCase();
                }
                var availableValue = availableEnvironment[key];
                if (typeof availableValue === 'string') {
                    availableValue = availableValue.toLowerCase();
                }
                if (key === 'browserName' && value === 'microsoftedge') {
                    return (availableValue !== 'microsoftedge' || availableValue !== 'edge');
                }
                return availableValue !== value;
            });
        })
            .forEach(function (availableEnvironment) {
            versions[availableEnvironment.version] = true;
        });
        return Object.keys(versions).sort(function (a, b) {
            var na = Number(a);
            var nb = Number(b);
            if (!isNaN(na) && !isNaN(nb)) {
                return na - nb;
            }
            if (a < b) {
                return -1;
            }
            if (a > b) {
                return 1;
            }
            return 0;
        });
    }
    function resolveVersions(environment, available) {
        var versionSpec = environment.version;
        var versions;
        available = available || [];
        if (versionSpec && isNaN(Number(versionSpec))) {
            var availableVersions_1 = getVersions(environment, available);
            versions = splitVersions(versionSpec).map(function (version) {
                var resolved = resolveVersionAlias(version, availableVersions_1);
                if (resolved == null) {
                    throw new Error("Unable to resolve version \"" + version + "\" for " + environment.browserName + ". Are you using the proper browser and platform names for the tunnel?");
                }
                return resolved;
            });
            if (versions.length === 2) {
                if (versions[0] === 'insider preview' ||
                    versions[1] === 'insider preview') {
                    throw new Error('"insider preview" cannot be used in a version range');
                }
                if (versions[0] > versions[1]) {
                    throw new Error('Invalid range [' + versions + '], must be in ascending order');
                }
                versions = expandVersionRange(versions[0], versions[1], availableVersions_1);
            }
            return versions;
        }
        return versionSpec;
    }
    function createPermutations(base, sources) {
        if (!sources || sources.length === 0) {
            return [tslib_1.__assign({}, base)];
        }
        return sources
            .map(function (source) {
            return Object.keys(source).reduce(function (permutations, key) {
                if (Array.isArray(source[key])) {
                    permutations = source[key]
                        .map(function (value) {
                        return permutations.map(function (permutation) {
                            var _a;
                            return (tslib_1.__assign({}, permutation, (_a = {}, _a[key] = value, _a)));
                        });
                    })
                        .reduce(function (newPermutations, keyPermutations) {
                        return newPermutations.concat(keyPermutations);
                    }, []);
                }
                else {
                    permutations.forEach(function (permutation) {
                        permutation[key] = source[key];
                    });
                }
                return permutations;
            }, [tslib_1.__assign({}, base)]);
        })
            .reduce(function (newPermutations, sourcePermutations) {
            return newPermutations.concat(sourcePermutations);
        }, []);
    }
    function normalizeBrowserNames(environments, available) {
        return environments.map(function (env) {
            if (env.browserName === 'MicrosoftEdge') {
                if (available.some(function (ae) { return ae.browserName === 'edge'; })) {
                    return tslib_1.__assign({}, env, { browserName: 'edge' });
                }
            }
            return env;
        });
    }
});
//# sourceMappingURL=resolveEnvironments.js.map
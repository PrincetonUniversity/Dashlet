<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"streaming_controllers_AbrController.js.html":{"id":"streaming_controllers_AbrController.js.html","title":"Source: streaming/controllers/AbrController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/controllers/AbrController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import ABRRulesCollection from '../rules/abr/ABRRulesCollection'; import Constants from '../constants/Constants'; import MetricsConstants from '../constants/MetricsConstants'; import BitrateInfo from '../vo/BitrateInfo'; import FragmentModel from '../models/FragmentModel'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import RulesContext from '../rules/RulesContext'; import SwitchRequest from '../rules/SwitchRequest'; import SwitchRequestHistory from '../rules/SwitchRequestHistory'; import DroppedFramesHistory from '../rules/DroppedFramesHistory'; import ThroughputHistory from '../rules/ThroughputHistory'; import Debug from '../../core/Debug'; import { HTTPRequest } from '../vo/metrics/HTTPRequest'; import { checkInteger } from '../utils/SupervisorTools'; const DEFAULT_VIDEO_BITRATE = 1000; const DEFAULT_AUDIO_BITRATE = 100; const QUALITY_DEFAULT = 0; function AbrController() { const context = this.context; const debug = Debug(context).getInstance(); const eventBus = EventBus(context).getInstance(); let instance, logger, abrRulesCollection, streamController, topQualities, qualityDict, streamProcessorDict, abandonmentStateDict, abandonmentTimeout, windowResizeEventCalled, elementWidth, elementHeight, adapter, videoModel, mediaPlayerModel, domStorage, playbackIndex, switchHistoryDict, droppedFramesHistory, throughputHistory, isUsingBufferOccupancyABRDict, dashMetrics, settings; function setup() { logger = debug.getLogger(instance); resetInitialSettings(); } function registerStreamType(type, streamProcessor) { switchHistoryDict[type] = switchHistoryDict[type] || SwitchRequestHistory(context).create(); streamProcessorDict[type] = streamProcessor; abandonmentStateDict[type] = abandonmentStateDict[type] || {}; abandonmentStateDict[type].state = MetricsConstants.ALLOW_LOAD; isUsingBufferOccupancyABRDict[type] = false; eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this); if (type == Constants.VIDEO) { eventBus.on(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, this); droppedFramesHistory = droppedFramesHistory || DroppedFramesHistory(context).create(); setElementSize(); } eventBus.on(Events.METRIC_ADDED, onMetricAdded, this); eventBus.on(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, this); throughputHistory = throughputHistory || ThroughputHistory(context).create({ settings: settings }); } function unRegisterStreamType(type) { delete streamProcessorDict[type]; } function createAbrRulesCollection() { abrRulesCollection = ABRRulesCollection(context).create({ dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, settings: settings }); abrRulesCollection.initialize(); } function resetInitialSettings() { topQualities = {}; qualityDict = {}; abandonmentStateDict = {}; streamProcessorDict = {}; switchHistoryDict = {}; isUsingBufferOccupancyABRDict = {}; if (windowResizeEventCalled === undefined) { windowResizeEventCalled = false; } playbackIndex = undefined; droppedFramesHistory = undefined; throughputHistory = undefined; clearTimeout(abandonmentTimeout); abandonmentTimeout = null; } function reset() { resetInitialSettings(); eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this); eventBus.off(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, this); eventBus.off(Events.METRIC_ADDED, onMetricAdded, this); eventBus.off(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, this); if (abrRulesCollection) { abrRulesCollection.reset(); } } function setConfig(config) { if (!config) return; if (config.streamController) { streamController = config.streamController; } if (config.domStorage) { domStorage = config.domStorage; } if (config.mediaPlayerModel) { mediaPlayerModel = config.mediaPlayerModel; } if (config.dashMetrics) { dashMetrics = config.dashMetrics; } if (config.adapter) { adapter = config.adapter; } if (config.videoModel) { videoModel = config.videoModel; } if (config.settings) { settings = config.settings; } } function checkConfig() { if (!domStorage || !domStorage.hasOwnProperty('getSavedBitrateSettings')) { throw new Error(Constants.MISSING_CONFIG_ERROR); } } function onQualityChangeRendered(e) { if (e.mediaType === Constants.VIDEO) { playbackIndex = e.oldQuality; droppedFramesHistory.push(playbackIndex, videoModel.getPlaybackQuality()); } } function onMetricAdded(e) { if (e.metric === MetricsConstants.HTTP_REQUEST &amp;&amp; e.value &amp;&amp; e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE &amp;&amp; (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) { throughputHistory.push(e.mediaType, e.value, settings.get().streaming.abr.useDeadTimeLatency); } if (e.metric === MetricsConstants.BUFFER_LEVEL &amp;&amp; (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) { updateIsUsingBufferOccupancyABR(e.mediaType, 0.001 * e.value.level); } } function getTopQualityIndexFor(type, id) { let idx; topQualities[id] = topQualities[id] || {}; if (!topQualities[id].hasOwnProperty(type)) { topQualities[id][type] = 0; } idx = checkMaxBitrate(topQualities[id][type], type); idx = checkMaxRepresentationRatio(idx, type, topQualities[id][type]); idx = checkPortalSize(idx, type); return idx; } /** * Gets top BitrateInfo for the player * @param {string} type - 'video' or 'audio' are the type options. * @returns {BitrateInfo | null} */ function getTopBitrateInfoFor(type) { if (type &amp;&amp; streamProcessorDict &amp;&amp; streamProcessorDict[type]) { const streamInfo = streamProcessorDict[type].getStreamInfo(); if (streamInfo &amp;&amp; streamInfo.id) { const idx = getTopQualityIndexFor(type, streamInfo.id); const bitrates = getBitrateList(streamProcessorDict[type].getMediaInfo()); return bitrates[idx] ? bitrates[idx] : null; } } return null; } /** * @param {string} type * @returns {number} A value of the initial bitrate, kbps * @memberof AbrController# */ function getInitialBitrateFor(type) { checkConfig(); if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT) { return NaN; } const savedBitrate = domStorage.getSavedBitrateSettings(type); let configBitrate = settings.get().streaming.abr.initialBitrate[type]; let configRatio = settings.get().streaming.abr.initialRepresentationRatio[type]; if (configBitrate === -1) { if (configRatio &gt; -1) { const representation = adapter.getAdaptationForType(0, type).Representation; if (Array.isArray(representation)) { const repIdx = Math.max(Math.round(representation.length * configRatio) - 1, 0); configBitrate = representation[repIdx].bandwidth; } else { configBitrate = 0; } } else if (!isNaN(savedBitrate)) { configBitrate = savedBitrate; } else { configBitrate = (type === Constants.VIDEO) ? DEFAULT_VIDEO_BITRATE : DEFAULT_AUDIO_BITRATE; } } return configBitrate; } function getMaxAllowedBitrateFor(type) { return settings.get().streaming.abr.maxBitrate[type]; } function getMinAllowedBitrateFor(type) { return settings.get().streaming.abr.minBitrate[type]; } function getMaxAllowedIndexFor(type) { const maxBitrate = getMaxAllowedBitrateFor(type); if (maxBitrate &gt; -1) { return getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), maxBitrate); } else { return undefined; } } function getMinAllowedIndexFor(type) { const minBitrate = getMinAllowedBitrateFor(type); if (minBitrate &gt; -1) { const mediaInfo = streamProcessorDict[type].getMediaInfo(); const bitrateList = getBitrateList(mediaInfo); // This returns the quality index &lt;= for the given bitrate let minIdx = getQualityForBitrate(mediaInfo, minBitrate); if (bitrateList[minIdx] &amp;&amp; minIdx &lt; bitrateList.length - 1 &amp;&amp; bitrateList[minIdx].bitrate &lt; minBitrate * 1000) { minIdx++; // Go to the next bitrate } return minIdx; } else { return undefined; } } function checkPlaybackQuality(type) { if (type &amp;&amp; streamProcessorDict &amp;&amp; streamProcessorDict[type]) { const streamInfo = streamProcessorDict[type].getStreamInfo(); const streamId = streamInfo ? streamInfo.id : null; const oldQuality = getQualityFor(type); const rulesContext = RulesContext(context).create({ abrController: instance, streamProcessor: streamProcessorDict[type], currentValue: oldQuality, switchHistory: switchHistoryDict[type], droppedFramesHistory: droppedFramesHistory, useBufferOccupancyABR: useBufferOccupancyABR(type) }); if (droppedFramesHistory) { const playbackQuality = videoModel.getPlaybackQuality(); if (playbackQuality) { droppedFramesHistory.push(playbackIndex, playbackQuality); } } if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) { const minIdx = getMinAllowedIndexFor(type); const topQualityIdx = getTopQualityIndexFor(type, streamId); const switchRequest = abrRulesCollection.getMaxQuality(rulesContext); let newQuality = switchRequest.quality; if (minIdx !== undefined &amp;&amp; ((newQuality &gt; SwitchRequest.NO_CHANGE) ? newQuality : oldQuality) &lt; minIdx) { newQuality = minIdx; } if (newQuality &gt; topQualityIdx) { newQuality = topQualityIdx; } switchHistoryDict[type].push({oldValue: oldQuality, newValue: newQuality}); if (newQuality &gt; SwitchRequest.NO_CHANGE &amp;&amp; newQuality != oldQuality) { if (abandonmentStateDict[type].state === MetricsConstants.ALLOW_LOAD || newQuality &gt; oldQuality) { changeQuality(type, oldQuality, newQuality, topQualityIdx, switchRequest.reason); } } else if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) { const bufferLevel = dashMetrics.getCurrentBufferLevel(type); logger.debug('[' + type + '] stay on ' + oldQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ')'); } } } } function setPlaybackQuality(type, streamInfo, newQuality, reason) { const id = streamInfo.id; const oldQuality = getQualityFor(type); checkInteger(newQuality); const topQualityIdx = getTopQualityIndexFor(type, id); if (newQuality !== oldQuality &amp;&amp; newQuality &gt;= 0 &amp;&amp; newQuality &lt;= topQualityIdx) { changeQuality(type, oldQuality, newQuality, topQualityIdx, reason); } } function changeQuality(type, oldQuality, newQuality, topQualityIdx, reason) { if (type &amp;&amp; streamProcessorDict[type]) { const streamInfo = streamProcessorDict[type].getStreamInfo(); const id = streamInfo ? streamInfo.id : null; if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) { const bufferLevel = dashMetrics.getCurrentBufferLevel(type); logger.info('[' + type + '] switch from ' + oldQuality + ' to ' + newQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ') ' + (reason ? JSON.stringify(reason) : '.')); } setQualityFor(type, id, newQuality); eventBus.trigger(Events.QUALITY_CHANGE_REQUESTED, {mediaType: type, streamInfo: streamInfo, oldQuality: oldQuality, newQuality: newQuality, reason: reason}); const bitrate = throughputHistory.getAverageThroughput(type); if (!isNaN(bitrate)) { domStorage.setSavedBitrateSettings(type, bitrate); } } } function setAbandonmentStateFor(type, state) { abandonmentStateDict[type].state = state; } function getAbandonmentStateFor(type) { return abandonmentStateDict[type] ? abandonmentStateDict[type].state : null; } /** * @param {MediaInfo} mediaInfo * @param {number} bitrate A bitrate value, kbps * @param {number} latency Expected latency of connection, ms * @returns {number} A quality index &lt;= for the given bitrate * @memberof AbrController# */ function getQualityForBitrate(mediaInfo, bitrate, latency) { const voRepresentation = mediaInfo &amp;&amp; mediaInfo.type ? streamProcessorDict[mediaInfo.type].getRepresentationInfo() : null; if (settings.get().streaming.abr.useDeadTimeLatency &amp;&amp; latency &amp;&amp; voRepresentation &amp;&amp; voRepresentation.fragmentDuration) { latency = latency / 1000; const fragmentDuration = voRepresentation.fragmentDuration; if (latency &gt; fragmentDuration) { return 0; } else { const deadTimeRatio = latency / fragmentDuration; bitrate = bitrate * (1 - deadTimeRatio); } } const bitrateList = getBitrateList(mediaInfo); for (let i = bitrateList.length - 1; i &gt;= 0; i--) { const bitrateInfo = bitrateList[i]; if (bitrate * 1000 &gt;= bitrateInfo.bitrate) { return i; } } return QUALITY_DEFAULT; } /** * @param {MediaInfo} mediaInfo * @returns {Array|null} A list of {@link BitrateInfo} objects * @memberof AbrController# */ function getBitrateList(mediaInfo) { const infoList = []; if (!mediaInfo || !mediaInfo.bitrateList) return infoList; const bitrateList = mediaInfo.bitrateList; const type = mediaInfo.type; let bitrateInfo; for (let i = 0, ln = bitrateList.length; i &lt; ln; i++) { bitrateInfo = new BitrateInfo(); bitrateInfo.mediaType = type; bitrateInfo.qualityIndex = i; bitrateInfo.bitrate = bitrateList[i].bandwidth; bitrateInfo.width = bitrateList[i].width; bitrateInfo.height = bitrateList[i].height; bitrateInfo.scanType = bitrateList[i].scanType; infoList.push(bitrateInfo); } return infoList; } function updateIsUsingBufferOccupancyABR(mediaType, bufferLevel) { const strategy = settings.get().streaming.abr.ABRStrategy; if (strategy === Constants.ABR_STRATEGY_BOLA) { isUsingBufferOccupancyABRDict[mediaType] = true; return; } else if (strategy === Constants.ABR_STRATEGY_THROUGHPUT) { isUsingBufferOccupancyABRDict[mediaType] = false; return; } // else ABR_STRATEGY_DYNAMIC const stableBufferTime = mediaPlayerModel.getStableBufferTime(); const switchOnThreshold = stableBufferTime; const switchOffThreshold = 0.5 * stableBufferTime; const useBufferABR = isUsingBufferOccupancyABRDict[mediaType]; const newUseBufferABR = bufferLevel &gt; (useBufferABR ? switchOffThreshold : switchOnThreshold); // use hysteresis to avoid oscillating rules isUsingBufferOccupancyABRDict[mediaType] = newUseBufferABR; if (newUseBufferABR !== useBufferABR) { if (newUseBufferABR) { logger.info('[' + mediaType + '] switching from throughput to buffer occupancy ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').'); } else { logger.info('[' + mediaType + '] switching from buffer occupancy to throughput ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').'); } } } function useBufferOccupancyABR(mediaType) { return isUsingBufferOccupancyABRDict[mediaType]; } function getThroughputHistory() { return throughputHistory; } function updateTopQualityIndex(mediaInfo) { if (mediaInfo) { const type = mediaInfo.type; const streamId = mediaInfo.streamInfo.id; const max = mediaInfo.representationCount - 1; setTopQualityIndex(type, streamId, max); return max; } } function isPlayingAtTopQuality(streamInfo) { const streamId = streamInfo ? streamInfo.id : null; const audioQuality = getQualityFor(Constants.AUDIO); const videoQuality = getQualityFor(Constants.VIDEO); const isAtTop = (audioQuality === getTopQualityIndexFor(Constants.AUDIO, streamId)) &amp;&amp; (videoQuality === getTopQualityIndexFor(Constants.VIDEO, streamId)); return isAtTop; } function getQualityFor(type) { if (type &amp;&amp; streamProcessorDict[type]) { const streamInfo = streamProcessorDict[type].getStreamInfo(); const id = streamInfo ? streamInfo.id : null; let quality; if (id) { qualityDict[id] = qualityDict[id] || {}; if (!qualityDict[id].hasOwnProperty(type)) { qualityDict[id][type] = QUALITY_DEFAULT; } quality = qualityDict[id][type]; return quality; } } return QUALITY_DEFAULT; } function setQualityFor(type, id, value) { qualityDict[id] = qualityDict[id] || {}; qualityDict[id][type] = value; } function setTopQualityIndex(type, id, value) { topQualities[id] = topQualities[id] || {}; topQualities[id][type] = value; } function checkMaxBitrate(idx, type) { let newIdx = idx; if (!streamProcessorDict[type]) { return newIdx; } const minIdx = getMinAllowedIndexFor(type); if (minIdx !== undefined) { newIdx = Math.max (idx , minIdx); } const maxIdx = getMaxAllowedIndexFor(type); if (maxIdx !== undefined) { newIdx = Math.min (newIdx , maxIdx); } return newIdx; } function checkMaxRepresentationRatio(idx, type, maxIdx) { const maxRepresentationRatio = settings.get().streaming.abr.maxRepresentationRatio[type]; if (isNaN(maxRepresentationRatio) || maxRepresentationRatio &gt;= 1 || maxRepresentationRatio &lt; 0) { return idx; } return Math.min(idx , Math.round(maxIdx * maxRepresentationRatio) ); } function setWindowResizeEventCalled(value) { windowResizeEventCalled = value; } function setElementSize() { if (videoModel) { const hasPixelRatio = settings.get().streaming.abr.usePixelRatioInLimitBitrateByPortal &amp;&amp; window.hasOwnProperty('devicePixelRatio'); const pixelRatio = hasPixelRatio ? window.devicePixelRatio : 1; elementWidth = videoModel.getClientWidth() * pixelRatio; elementHeight = videoModel.getClientHeight() * pixelRatio; } } function checkPortalSize(idx, type) { if (type !== Constants.VIDEO || !settings.get().streaming.abr.limitBitrateByPortal || !streamProcessorDict[type]) { return idx; } if (!windowResizeEventCalled) { setElementSize(); } const representation = adapter.getAdaptationForType(0, type).Representation; let newIdx = idx; if (elementWidth &gt; 0 &amp;&amp; elementHeight &gt; 0) { while ( newIdx &gt; 0 &amp;&amp; representation[newIdx] &amp;&amp; elementWidth &lt; representation[newIdx].width &amp;&amp; elementWidth - representation[newIdx - 1].width &lt; representation[newIdx].width - elementWidth) { newIdx = newIdx - 1; } // Make sure that in case of multiple representation elements have same // resolution, every such element is included while (newIdx &lt; representation.length - 1 &amp;&amp; representation[newIdx].width === representation[newIdx + 1].width) { newIdx = newIdx + 1; } } return newIdx; } function onFragmentLoadProgress(e) { const type = e.request.mediaType; if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) { const streamProcessor = streamProcessorDict[type]; if (!streamProcessor) return; // There may be a fragment load in progress when we switch periods and recreated some controllers. const rulesContext = RulesContext(context).create({ abrController: instance, streamProcessor: streamProcessor, currentRequest: e.request, useBufferOccupancyABR: useBufferOccupancyABR(type) }); const switchRequest = abrRulesCollection.shouldAbandonFragment(rulesContext); if (switchRequest.quality &gt; SwitchRequest.NO_CHANGE) { const fragmentModel = streamProcessor.getFragmentModel(); const request = fragmentModel.getRequests({state: FragmentModel.FRAGMENT_MODEL_LOADING, index: e.request.index})[0]; if (request) { //TODO Check if we should abort or if better to finish download. check bytesLoaded/Total fragmentModel.abortRequests(); setAbandonmentStateFor(type, MetricsConstants.ABANDON_LOAD); switchHistoryDict[type].reset(); switchHistoryDict[type].push({oldValue: getQualityFor(type), newValue: switchRequest.quality, confidence: 1, reason: switchRequest.reason}); setPlaybackQuality(type, streamController.getActiveStreamInfo(), switchRequest.quality, switchRequest.reason); clearTimeout(abandonmentTimeout); abandonmentTimeout = setTimeout( () =&gt; {setAbandonmentStateFor(type, MetricsConstants.ALLOW_LOAD); abandonmentTimeout = null;}, settings.get().streaming.abandonLoadTimeout ); } } } } instance = { isPlayingAtTopQuality: isPlayingAtTopQuality, updateTopQualityIndex: updateTopQualityIndex, getThroughputHistory: getThroughputHistory, getBitrateList: getBitrateList, getQualityForBitrate: getQualityForBitrate, getTopBitrateInfoFor: getTopBitrateInfoFor, getMaxAllowedIndexFor: getMaxAllowedIndexFor, getMinAllowedIndexFor: getMinAllowedIndexFor, getInitialBitrateFor: getInitialBitrateFor, getQualityFor: getQualityFor, getAbandonmentStateFor: getAbandonmentStateFor, setPlaybackQuality: setPlaybackQuality, checkPlaybackQuality: checkPlaybackQuality, getTopQualityIndexFor: getTopQualityIndexFor, setElementSize: setElementSize, setWindowResizeEventCalled: setWindowResizeEventCalled, createAbrRulesCollection: createAbrRulesCollection, registerStreamType: registerStreamType, unRegisterStreamType: unRegisterStreamType, setConfig: setConfig, reset: reset }; setup(); return instance; } AbrController.__dashjs_factory_name = 'AbrController'; const factory = FactoryMaker.getSingletonFactory(AbrController); factory.QUALITY_DEFAULT = QUALITY_DEFAULT; FactoryMaker.updateSingletonFactory(AbrController.__dashjs_factory_name, factory); export default factory; × Search results Close "},"streaming_utils_BoxParser.js.html":{"id":"streaming_utils_BoxParser.js.html","title":"Source: streaming/utils/BoxParser.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/BoxParser.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Debug from '../../core/Debug'; import IsoFile from './IsoFile'; import FactoryMaker from '../../core/FactoryMaker'; import ISOBoxer from 'codem-isoboxer'; import IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo'; function BoxParser(/*config*/) { let logger, instance; let context = this.context; function setup() { logger = Debug(context).getInstance().getLogger(instance); } /** * @param {ArrayBuffer} data * @returns {IsoFile|null} * @memberof BoxParser# */ function parse(data) { if (!data) return null; if (data.fileStart === undefined) { data.fileStart = 0; } let parsedFile = ISOBoxer.parseBuffer(data); let dashIsoFile = IsoFile(context).create(); dashIsoFile.setData(parsedFile); return dashIsoFile; } /** * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This * method only looks into the list of top boxes and doesn't analyze nested boxes. * @param {string[]} types * @param {ArrayBuffer|uint8Array} buffer * @param {number} offset * @returns {IsoBoxSearchInfo} * @memberof BoxParser# */ function findLastTopIsoBoxCompleted(types, buffer, offset) { if (offset === undefined) { offset = 0; } // 8 = size (uint32) + type (4 characters) if (!buffer || offset + 8 &gt;= buffer.byteLength) { return new IsoBoxSearchInfo(0, false); } const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer; let boxInfo; let lastCompletedOffset = 0; while (offset &lt; data.byteLength) { const boxSize = parseUint32(data, offset); const boxType = parseIsoBoxType(data, offset + 4); if (boxSize === 0) { break; } if (offset + boxSize &lt;= data.byteLength) { if (types.indexOf(boxType) &gt;= 0) { boxInfo = new IsoBoxSearchInfo(offset, true, boxSize); } else { lastCompletedOffset = offset + boxSize; } } offset += boxSize; } if (!boxInfo) { return new IsoBoxSearchInfo(lastCompletedOffset, false); } return boxInfo; } function getSamplesInfo(ab) { if (!ab || ab.byteLength === 0) { return {sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN}; } let isoFile = parse(ab); // zero or more moofs let moofBoxes = isoFile.getBoxes('moof'); // exactly one mfhd per moof let mfhdBoxes = isoFile.getBoxes('mfhd'); let sampleDuration, sampleCompositionTimeOffset, sampleCount, sampleSize, sampleDts, sampleList, sample, i, j, k, l, m, n, dataOffset, lastSequenceNumber, numSequences, totalDuration; numSequences = isoFile.getBoxes('moof').length; lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number; sampleCount = 0; sampleList = []; let subsIndex = -1; let nextSubsSample = -1; for (l = 0; l &lt; moofBoxes.length; l++) { let moofBox = moofBoxes[l]; // zero or more trafs per moof let trafBoxes = moofBox.getChildBoxes('traf'); for (j = 0; j &lt; trafBoxes.length; j++) { let trafBox = trafBoxes[j]; // exactly one tfhd per traf let tfhdBox = trafBox.getChildBox('tfhd'); // zero or one tfdt per traf let tfdtBox = trafBox.getChildBox('tfdt'); sampleDts = tfdtBox.baseMediaDecodeTime; // zero or more truns per traf let trunBoxes = trafBox.getChildBoxes('trun'); // zero or more subs per traf let subsBoxes = trafBox.getChildBoxes('subs'); for (k = 0; k &lt; trunBoxes.length; k++) { let trunBox = trunBoxes[k]; sampleCount = trunBox.sample_count; dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0); for (i = 0; i &lt; sampleCount; i++) { sample = trunBox.samples[i]; sampleDuration = (sample.sample_duration !== undefined) ? sample.sample_duration : tfhdBox.default_sample_duration; sampleSize = (sample.sample_size !== undefined) ? sample.sample_size : tfhdBox.default_sample_size; sampleCompositionTimeOffset = (sample.sample_composition_time_offset !== undefined) ? sample.sample_composition_time_offset : 0; let sampleData = { 'dts': sampleDts, 'cts': (sampleDts + sampleCompositionTimeOffset), 'duration': sampleDuration, 'offset': moofBox.offset + dataOffset, 'size': sampleSize, 'subSizes': [sampleSize] }; if (subsBoxes) { for (m = 0; m &lt; subsBoxes.length; m++) { let subsBox = subsBoxes[m]; if (subsIndex &lt; (subsBox.entry_count - 1) &amp;&amp; i &gt; nextSubsSample) { subsIndex++; nextSubsSample += subsBox.entries[subsIndex].sample_delta; } if (i == nextSubsSample) { sampleData.subSizes = []; let entry = subsBox.entries[subsIndex]; for (n = 0; n &lt; entry.subsample_count; n++) { sampleData.subSizes.push(entry.subsamples[n].subsample_size); } } } } sampleList.push(sampleData); dataOffset += sampleSize; sampleDts += sampleDuration; } } totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime; } } return {sampleList: sampleList, lastSequenceNumber: lastSequenceNumber, totalDuration: totalDuration, numSequences: numSequences}; } function getMediaTimescaleFromMoov(ab) { let isoFile = parse(ab); let mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined; return mdhdBox ? mdhdBox.timescale : NaN; } function parseUint32(data, offset) { return data[offset + 3] &gt;&gt;&gt; 0 | (data[offset + 2] &lt;&lt; 8) &gt;&gt;&gt; 0 | (data[offset + 1] &lt;&lt; 16) &gt;&gt;&gt; 0 | (data[offset] &lt;&lt; 24) &gt;&gt;&gt; 0; } function parseIsoBoxType(data, offset) { return String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset]); } function findInitRange(data) { let initRange = null; let start, end; const isoFile = parse(data); if (!isoFile) { return initRange; } const ftyp = isoFile.getBox('ftyp'); const moov = isoFile.getBox('moov'); logger.debug('Searching for initialization.'); if (moov &amp;&amp; moov.isComplete) { start = ftyp ? ftyp.offset : moov.offset; end = moov.offset + moov.size - 1; initRange = start + '-' + end; logger.debug('Found the initialization. Range: ' + initRange); } return initRange; } instance = { parse: parse, findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted, getMediaTimescaleFromMoov: getMediaTimescaleFromMoov, getSamplesInfo: getSamplesInfo, findInitRange: findInitRange }; setup(); return instance; } BoxParser.__dashjs_factory_name = 'BoxParser'; export default FactoryMaker.getSingletonFactory(BoxParser); × Search results Close "},"streaming_vo_metrics_BufferLevel.js.html":{"id":"streaming_vo_metrics_BufferLevel.js.html","title":"Source: streaming/vo/metrics/BufferLevel.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/BufferLevel.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class * @ignore */ class BufferLevel { /** * @description This Object holds reference to the current buffer level and the time it was recorded. */ constructor() { /** * Real-Time | Time of the measurement of the buffer level. * @public */ this.t = null; /** * Level of the buffer in milliseconds. Indicates the playout duration for which * media data of all active media components is available starting from the * current playout time. * @public */ this.level = null; } } export default BufferLevel; × Search results Close "},"streaming_vo_metrics_BufferState.js.html":{"id":"streaming_vo_metrics_BufferState.js.html","title":"Source: streaming/vo/metrics/BufferState.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/BufferState.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import MetricsConstants from '../../constants/MetricsConstants'; /** * @class * @ignore */ class BufferState { /** * @description This Object holds reference to the current buffer state of the video element. */ constructor() { /** * The Buffer Level Target determined by the BufferLevelRule. * @public */ this.target = null; /** * Current buffer state. Will be MetricsConstants.BUFFER_EMPTY or MetricsConstants.BUFFER_LOADED. * @public */ this.state = MetricsConstants.BUFFER_EMPTY; } } export default BufferState; × Search results Close "},"streaming_utils_Capabilities.js.html":{"id":"streaming_utils_Capabilities.js.html","title":"Source: streaming/utils/Capabilities.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/Capabilities.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; function Capabilities() { let instance, encryptedMediaSupported; function setup() { encryptedMediaSupported = false; } function supportsMediaSource() { let hasWebKit = ('WebKitMediaSource' in window); let hasMediaSource = ('MediaSource' in window); return (hasWebKit || hasMediaSource); } /** * Returns whether Encrypted Media Extensions are supported on this * user agent * * @return {boolean} true if EME is supported, false otherwise */ function supportsEncryptedMedia() { return encryptedMediaSupported; } function setEncryptedMediaSupported(value) { encryptedMediaSupported = value; } function supportsCodec(codec) { if ('MediaSource' in window &amp;&amp; MediaSource.isTypeSupported(codec)) { return true; } if ('WebKitMediaSource' in window &amp;&amp; WebKitMediaSource.isTypeSupported(codec)) { return true; } return false; } instance = { supportsMediaSource: supportsMediaSource, supportsEncryptedMedia: supportsEncryptedMedia, supportsCodec: supportsCodec, setEncryptedMediaSupported: setEncryptedMediaSupported }; setup(); return instance; } Capabilities.__dashjs_factory_name = 'Capabilities'; export default FactoryMaker.getSingletonFactory(Capabilities); × Search results Close "},"streaming_protection_vo_ClearKeyKeySet.js.html":{"id":"streaming_protection_vo_ClearKeyKeySet.js.html","title":"Source: streaming/protection/vo/ClearKeyKeySet.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/vo/ClearKeyKeySet.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc A collection of ClearKey encryption keys with an (optional) associated * type * @ignore */ class ClearKeyKeySet { /** * @param {Array.&lt;KeyPair&gt;} keyPairs * @param {string} type the type of keys in this set. One of either 'persistent' * or 'temporary'. Can also be null or undefined. * @class * @ignore */ constructor(keyPairs, type) { if (type &amp;&amp; type !== 'persistent' &amp;&amp; type !== 'temporary') throw new Error('Invalid ClearKey key set type! Must be one of \\'persistent\\' or \\'temporary\\''); this.keyPairs = keyPairs; this.type = type; } /** * Convert this key set to its JSON Web Key (JWK) representation * * @return {ArrayBuffer} JWK object UTF-8 encoded as ArrayBuffer */ toJWK() { let i; let numKeys = this.keyPairs.length; let jwk = {keys: []}; for (i = 0; i &lt; numKeys; i++) { let key = { kty: 'oct', alg: 'A128KW', kid: this.keyPairs[i].keyID, k: this.keyPairs[i].key }; jwk.keys.push(key); } if (this.type) { jwk.type = this.type; } let jwkString = JSON.stringify(jwk); const len = jwkString.length; // Convert JSON string to ArrayBuffer let buf = new ArrayBuffer(len); let bView = new Uint8Array(buf); for (i = 0; i &lt; len; i++) bView[i] = jwkString.charCodeAt(i); return buf; } } export default ClearKeyKeySet; × Search results Close "},"streaming_protection_CommonEncryption.js.html":{"id":"streaming_protection_CommonEncryption.js.html","title":"Source: streaming/protection/CommonEncryption.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/CommonEncryption.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class * @ignore */ class CommonEncryption { /** * Find and return the ContentProtection element in the given array * that indicates support for MPEG Common Encryption * * @param {Array} cpArray array of content protection elements * @returns {Object|null} the Common Encryption content protection element or * null if one was not found */ static findCencContentProtection(cpArray) { let retVal = null; for (let i = 0; i &lt; cpArray.length; ++i) { let cp = cpArray[i]; if (cp.schemeIdUri.toLowerCase() === 'urn:mpeg:dash:mp4protection:2011' &amp;&amp; (cp.value.toLowerCase() === 'cenc' || cp.value.toLowerCase() === 'cbcs')) retVal = cp; } return retVal; } /** * Returns just the data portion of a single PSSH * * @param {ArrayBuffer} pssh - the PSSH * @return {ArrayBuffer} data portion of the PSSH */ static getPSSHData(pssh) { let offset = 8; // Box size and type fields let view = new DataView(pssh); // Read version let version = view.getUint8(offset); offset += 20; // Version (1), flags (3), system ID (16) if (version &gt; 0) { offset += 4 + (16 * view.getUint32(offset)); // Key ID count (4) and All key IDs (16*count) } offset += 4; // Data size return pssh.slice(offset); } /** * Returns the PSSH associated with the given key system from the concatenated * list of PSSH boxes in the given initData * * @param {KeySystem} keySystem the desired * key system * @param {ArrayBuffer} initData 'cenc' initialization data. Concatenated list of PSSH. * @returns {ArrayBuffer|null} The PSSH box data corresponding to the given key system, null if not found * or null if a valid association could not be found. */ static getPSSHForKeySystem(keySystem, initData) { let psshList = CommonEncryption.parsePSSHList(initData); if (keySystem &amp;&amp; psshList.hasOwnProperty(keySystem.uuid.toLowerCase())) { return psshList[keySystem.uuid.toLowerCase()]; } return null; } /** * Parse a standard common encryption PSSH which contains a simple * base64-encoding of the init data * * @param {Object} cpData the ContentProtection element * @param {BASE64} BASE64 reference * @returns {ArrayBuffer|null} the init data or null if not found */ static parseInitDataFromContentProtection(cpData, BASE64) { if ('pssh' in cpData) { // Remove whitespaces and newlines from pssh text cpData.pssh.__text = cpData.pssh.__text.replace(/\\r?\\n|\\r/g, '').replace(/\\s+/g, ''); return BASE64.decodeArray(cpData.pssh.__text).buffer; } return null; } /** * Parses list of PSSH boxes into keysystem-specific PSSH data * * @param {ArrayBuffer} data - the concatenated list of PSSH boxes as provided by * CDM as initialization data when CommonEncryption content is detected * @returns {Object|Array} an object that has a property named according to each of * the detected key system UUIDs (e.g. 00000000-0000-0000-0000-0000000000) * and a ArrayBuffer (the entire PSSH box) as the property value */ static parsePSSHList(data) { if (data === null || data === undefined) return []; let dv = new DataView(data.buffer || data); // data.buffer first for Uint8Array support let done = false; let pssh = {}; // TODO: Need to check every data read for end of buffer let byteCursor = 0; while (!done) { let size, nextBox, version, systemID, psshDataSize; let boxStart = byteCursor; if (byteCursor &gt;= dv.buffer.byteLength) break; /* Box size */ size = dv.getUint32(byteCursor); nextBox = byteCursor + size; byteCursor += 4; /* Verify PSSH */ if (dv.getUint32(byteCursor) !== 0x70737368) { byteCursor = nextBox; continue; } byteCursor += 4; /* Version must be 0 or 1 */ version = dv.getUint8(byteCursor); if (version !== 0 &amp;&amp; version !== 1) { byteCursor = nextBox; continue; } byteCursor++; byteCursor += 3; /* skip flags */ // 16-byte UUID/SystemID systemID = ''; let i, val; for (i = 0; i &lt; 4; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 4; systemID += '-'; for (i = 0; i &lt; 2; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 2; systemID += '-'; for (i = 0; i &lt; 2; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 2; systemID += '-'; for (i = 0; i &lt; 2; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 2; systemID += '-'; for (i = 0; i &lt; 6; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 6; systemID = systemID.toLowerCase(); /* PSSH Data Size */ psshDataSize = dv.getUint32(byteCursor); byteCursor += 4; /* PSSH Data */ pssh[systemID] = dv.buffer.slice(boxStart, nextBox); byteCursor = nextBox; } return pssh; } } export default CommonEncryption; × Search results Close "},"streaming_constants_Constants.js.html":{"id":"streaming_constants_Constants.js.html","title":"Source: streaming/constants/Constants.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/constants/Constants.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Constants declaration * @class * @ignore * @hideconstructor */ class Constants { init () { /** * @constant {string} STREAM Stream media type. Mainly used to report metrics relative to the full stream * @memberof Constants# * @static */ this.STREAM = 'stream'; /** * @constant {string} VIDEO Video media type * @memberof Constants# * @static */ this.VIDEO = 'video'; /** * @constant {string} AUDIO Audio media type * @memberof Constants# * @static */ this.AUDIO = 'audio'; /** * @constant {string} TEXT Text media type * @memberof Constants# * @static */ this.TEXT = 'text'; /** * @constant {string} FRAGMENTED_TEXT Fragmented text media type * @memberof Constants# * @static */ this.FRAGMENTED_TEXT = 'fragmentedText'; /** * @constant {string} EMBEDDED_TEXT Embedded text media type * @memberof Constants# * @static */ this.EMBEDDED_TEXT = 'embeddedText'; /** * @constant {string} MUXED Muxed (video/audio in the same chunk) media type * @memberof Constants# * @static */ this.MUXED = 'muxed'; /** * @constant {string} IMAGE Image media type * @memberof Constants# * @static */ this.IMAGE = 'image'; /** * @constant {string} STPP STTP Subtitles format * @memberof Constants# * @static */ this.STPP = 'stpp'; /** * @constant {string} TTML STTP Subtitles format * @memberof Constants# * @static */ this.TTML = 'ttml'; /** * @constant {string} VTT STTP Subtitles format * @memberof Constants# * @static */ this.VTT = 'vtt'; /** * @constant {string} WVTT STTP Subtitles format * @memberof Constants# * @static */ this.WVTT = 'wvtt'; /** * @constant {string} ABR_STRATEGY_DYNAMIC Dynamic Adaptive bitrate algorithm * @memberof Constants# * @static */ this.ABR_STRATEGY_DYNAMIC = 'abrDynamic'; /** * @constant {string} ABR_STRATEGY_BOLA Adaptive bitrate algorithm based on Bola (buffer level) * @memberof Constants# * @static */ this.ABR_STRATEGY_BOLA = 'abrBola'; /** * @constant {string} ABR_STRATEGY_THROUGHPUT Adaptive bitrate algorithm based on throughput * @memberof Constants# * @static */ this.ABR_STRATEGY_THROUGHPUT = 'abrThroughput'; /** * @constant {string} MOVING_AVERAGE_SLIDING_WINDOW Moving average sliding window * @memberof Constants# * @static */ this.MOVING_AVERAGE_SLIDING_WINDOW = 'slidingWindow'; /** * @constant {string} EWMA Exponential moving average * @memberof Constants# * @static */ this.MOVING_AVERAGE_EWMA = 'ewma'; /** * @constant {string} BAD_ARGUMENT_ERROR Invalid Arguments type of error * @memberof Constants# * @static */ this.BAD_ARGUMENT_ERROR = 'Invalid Arguments'; /** * @constant {string} MISSING_CONFIG_ERROR Missing ocnfiguration parameters type of error * @memberof Constants# * @static */ this.MISSING_CONFIG_ERROR = 'Missing config parameter(s)'; this.LOCATION = 'Location'; this.INITIALIZE = 'initialize'; this.TEXT_SHOWING = 'showing'; this.TEXT_HIDDEN = 'hidden'; this.CC1 = 'CC1'; this.CC3 = 'CC3'; this.UTF8 = 'utf-8'; this.SCHEME_ID_URI = 'schemeIdUri'; this.START_TIME = 'starttime'; this.SERVICE_DESCRIPTION_LL_SCHEME = 'urn:dvb:dash:lowlatency:scope:2019'; this.SUPPLEMENTAL_PROPERTY_LL_SCHEME = 'urn:dvb:dash:lowlatency:critical:2019'; this.XML = 'XML'; this.ARRAY_BUFFER = 'ArrayBuffer'; } constructor () { this.init(); } } const constants = new Constants(); export default constants; × Search results Close "},"streaming_vo_metrics_DroppedFrames.js.html":{"id":"streaming_vo_metrics_DroppedFrames.js.html","title":"Source: streaming/vo/metrics/DroppedFrames.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/DroppedFrames.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class * @ignore */ class DroppedFrames { /** * @description This Object holds reference to DroppedFrames count and the time it was recorded. */ constructor() { /** * Real-Time | Time of the measurement of the dropped frames. * @public */ this.time = null; /** * Number of dropped frames * @public */ this.droppedFrames = null; } } export default DroppedFrames; × Search results Close "},"streaming_vo_metrics_DVRInfo.js.html":{"id":"streaming_vo_metrics_DVRInfo.js.html","title":"Source: streaming/vo/metrics/DVRInfo.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/DVRInfo.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class * @ignore */ class DVRInfo { /** * @description This Object holds reference to DVR availability window information. */ constructor() { /** * The current time of the video element when this was created. * @public */ this.time = null; /** * The current Segment Availability Range as an object with start and end properties. * It's delta defined by the timeShiftBufferDepth MPD attribute. * @public */ this.range = null; /** * Reference to the internal ManifestInfo.js VO. * @public */ this.manifestInfo = null; } } export default DVRInfo; × Search results Close "},"streaming_utils_EBMLParser.js.html":{"id":"streaming_utils_EBMLParser.js.html","title":"Source: streaming/utils/EBMLParser.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/EBMLParser.js import FactoryMaker from '../../core/FactoryMaker'; /** * Creates an instance of an EBMLParser class which implements a large subset * of the functionality required to parse Matroska EBML * * @param {Object} config object with data member which is the buffer to parse * @ignore */ function EBMLParser(config) { config = config || {}; let instance; let data = new DataView(config.data); let pos = 0; function getPos() { return pos; } function setPos(value) { pos = value; } /** * Consumes an EBML tag from the data stream. * * @param {Object} tag to parse, A tag is an object with at least a {number} tag and * {boolean} required flag. * @param {boolean} test whether or not the function should throw if a required * tag is not found * @return {boolean} whether or not the tag was found * @throws will throw an exception if a required tag is not found and test * param is false or undefined, or if the stream is malformed. * @memberof EBMLParser */ function consumeTag(tag, test) { let found = true; let bytesConsumed = 0; let p1, p2; if (test === undefined) { test = false; } if (tag.tag &gt; 0xFFFFFF) { if (data.getUint32(pos) !== tag.tag) { found = false; } bytesConsumed = 4; } else if (tag.tag &gt; 0xFFFF) { // 3 bytes p1 = data.getUint16(pos); p2 = data.getUint8(pos + 2); // shift p1 over a byte and add p2 if (p1 * 256 + p2 !== tag.tag) { found = false; } bytesConsumed = 3; } else if (tag.tag &gt; 0xFF) { if (data.getUint16(pos) !== tag.tag) { found = false; } bytesConsumed = 2; } else { if (data.getUint8(pos) !== tag.tag) { found = false; } bytesConsumed = 1; } if (!found &amp;&amp; tag.required &amp;&amp; !test) { throw new Error('required tag not found'); } if (found) { pos += bytesConsumed; } return found; } /** * Consumes an EBML tag from the data stream. If the tag is found then this * function will also remove the size field which follows the tag from the * data stream. * * @param {Object} tag to parse, A tag is an object with at least a {number} tag and * {boolean} required flag. * @param {boolean} test whether or not the function should throw if a required * tag is not found * @return {boolean} whether or not the tag was found * @throws will throw an exception if a required tag is not found and test * param is false or undefined, or if the stream is malformedata. * @memberof EBMLParser */ function consumeTagAndSize(tag, test) { let found = consumeTag(tag, test); if (found) { getMatroskaCodedNum(); } return found; } /** * Consumes an EBML tag from the data stream. If the tag is found then this * function will also remove the size field which follows the tag from the * data stream. It will use the value of the size field to parse a binary * field, using a parser defined in the tag itself * * @param {Object} tag to parse, A tag is an object with at least a {number} tag, * {boolean} required flag, and a parse function which takes a size parameter * @return {boolean} whether or not the tag was found * @throws will throw an exception if a required tag is not found, * or if the stream is malformed * @memberof EBMLParser */ function parseTag(tag) { let size; consumeTag(tag); size = getMatroskaCodedNum(); return instance[tag.parse](size); } /** * Consumes an EBML tag from the data stream. If the tag is found then this * function will also remove the size field which follows the tag from the * data stream. It will use the value of the size field to skip over the * entire section of EBML encapsulated by the tag. * * @param {Object} tag to parse, A tag is an object with at least a {number} tag, and * {boolean} required flag * @param {boolean} test a flag to indicate if an exception should be thrown * if a required tag is not found * @return {boolean} whether or not the tag was found * @throws will throw an exception if a required tag is not found and test is * false or undefined or if the stream is malformed * @memberof EBMLParser */ function skipOverElement(tag, test) { let found = consumeTag(tag, test); let headerSize; if (found) { headerSize = getMatroskaCodedNum(); pos += headerSize; } return found; } /** * Returns and consumes a number encoded according to the Matroska EBML * specification from the bitstream. * * @param {boolean} retainMSB whether or not to retain the Most Significant Bit (the * first 1). this is usually true when reading Tag IDs. * @return {number} the decoded number * @throws will throw an exception if the bit stream is malformed or there is * not enough data * @memberof EBMLParser */ function getMatroskaCodedNum(retainMSB) { let bytesUsed = 1; let mask = 0x80; let maxBytes = 8; let extraBytes = -1; let num = 0; let ch = data.getUint8(pos); let i = 0; for (i = 0; i &lt; maxBytes; i += 1) { if ((ch &amp; mask) === mask) { num = (retainMSB === undefined) ? ch &amp; ~mask : ch; extraBytes = i; break; } mask &gt;&gt;= 1; } for (i = 0; i &lt; extraBytes; i += 1, bytesUsed += 1) { num = (num &lt;&lt; 8) | (0xff &amp; data.getUint8(pos + bytesUsed)); } pos += bytesUsed; return num; } /** * Returns and consumes a float from the bitstream. * * @param {number} size 4 or 8 byte floats are supported * @return {number} the decoded number * @throws will throw an exception if the bit stream is malformed or there is * not enough data * @memberof EBMLParser */ function getMatroskaFloat(size) { let outFloat; switch (size) { case 4: outFloat = data.getFloat32(pos); pos += 4; break; case 8: outFloat = data.getFloat64(pos); pos += 8; break; } return outFloat; } /** * Consumes and returns an unsigned int from the bitstream. * * @param {number} size 1 to 8 bytes * @return {number} the decoded number * @throws will throw an exception if the bit stream is malformed or there is * not enough data * @memberof EBMLParser */ function getMatroskaUint(size) { let val = 0; for (let i = 0; i &lt; size; i += 1) { val &lt;&lt;= 8; val |= data.getUint8(pos + i) &amp; 0xff; } pos += size; return val; } /** * Tests whether there is more data in the bitstream for parsing * * @return {boolean} whether there is more data to parse * @memberof EBMLParser */ function moreData() { return pos &lt; data.byteLength; } instance = { getPos: getPos, setPos: setPos, consumeTag: consumeTag, consumeTagAndSize: consumeTagAndSize, parseTag: parseTag, skipOverElement: skipOverElement, getMatroskaCodedNum: getMatroskaCodedNum, getMatroskaFloat: getMatroskaFloat, getMatroskaUint: getMatroskaUint, moreData: moreData }; return instance; } EBMLParser.__dashjs_factory_name = 'EBMLParser'; export default FactoryMaker.getClassFactory(EBMLParser); × Search results Close "},"offline_utils_OfflineIndexDBManifestParser.js.html":{"id":"offline_utils_OfflineIndexDBManifestParser.js.html","title":"Source: offline/utils/OfflineIndexDBManifestParser.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/utils/OfflineIndexDBManifestParser.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ const Entities = require('html-entities').XmlEntities; const OFFLINE_BASE_URL = 'offline_indexeddb://'; function OfflineIndexDBManifestParser(config) { const manifestId = config.manifestId; const allMediaInfos = config.allMediaInfos; const urlUtils = config.urlUtils; const debug = config.debug; const dashConstants = config.dashConstants; const constants = config.constants; let instance, DOM, logger; function setup() { logger = debug.getLogger(instance); } /** * Parse XML manifest * @param {string} XMLDoc - xml manifest * @param {object} representation * @returns {Promise} a promise that will be resolved or rejected at the end of encoding process * @instance */ function parse(XMLDoc, representation) { return new Promise(function (resolve, reject) { DOM = new DOMParser().parseFromString(XMLDoc, 'application/xml'); let mpd = DOM.getElementsByTagName(dashConstants.MPD) ? DOM.getElementsByTagName(dashConstants.MPD) : null; for (let i = 0; i &lt; mpd.length; i++) { if (mpd[i] !== null) { editBaseURLAttribute(mpd[i]); browsePeriods(mpd[i], representation); } } let manifestEncoded = encodeManifest(DOM); if (manifestEncoded !== '') { resolve(manifestEncoded); } else { reject('Encoded error'); } }); } /** * URL encode parsed manifest * @param {string} DOM * @returns {string} Url encoded XML * @instance */ function encodeManifest(DOM) { logger.info('encodedManifest ' + new XMLSerializer().serializeToString(DOM)); return new Entities().encode(new XMLSerializer().serializeToString(DOM)); } /** * Update baseURL to point to local stored data P * @param {XML} currentMPD * @instance */ function editBaseURLAttribute(currentMPD) { let basesURL, fragmentId, representationId; let url = `${OFFLINE_BASE_URL}${manifestId}/`; basesURL = currentMPD.getElementsByTagName(dashConstants.BASE_URL); if (basesURL.length === 0) { // add baseURL let element = DOM.createElement(dashConstants.BASE_URL); element.innerHTML = url; currentMPD.appendChild(element); } basesURL = currentMPD.getElementsByTagName(dashConstants.BASE_URL); for (let i = 0; i &lt; basesURL.length; i++) { let parent = basesURL[i].parentNode; if (parent.nodeName === dashConstants.MPD) { basesURL[i].innerHTML = url; } else if (parent.nodeName === dashConstants.REPRESENTATION) { let adaptationsSet = parent.parentNode; if (adaptationsSet.nodeName == dashConstants.ADAPTATION_SET) { if (urlUtils.isHTTPS(basesURL[i].innerHTML) || urlUtils.isHTTPURL(basesURL[i].innerHTML)) { fragmentId = getFragmentId(basesURL[i].innerHTML); representationId = getBestRepresentationId(adaptationsSet); basesURL[i].innerHTML = url + representationId + '_' + fragmentId; } else if (basesURL[i].innerHTML === './') { basesURL[i].innerHTML = url; } else { fragmentId = getFragmentId(basesURL[i].innerHTML); representationId = getBestRepresentationId(adaptationsSet); basesURL[i].innerHTML = representationId + '_' + fragmentId; } } } else { basesURL[i].innerHTML = url; } } } /** * Browse periods * @param {XML} currentMPD * @param {Object} representation * @instance */ function browsePeriods(currentMPD, representation) { let periods = currentMPD.getElementsByTagName(dashConstants.PERIOD); for (let j = 0; j &lt; periods.length; j++) { browseAdaptationsSet(periods[j], representation); } } /** * Browse adapatation set to update data (delete those taht are not choosen by user ...) * @param {XML} currentPeriod * @param {Array} representationsToUpdate * @instance */ function browseAdaptationsSet(currentPeriod, representationsToUpdate) { let adaptationsSet, currentAdaptationSet, currentAdaptationType, representations; adaptationsSet = currentPeriod.getElementsByTagName(dashConstants.ADAPTATION_SET); for (let i = adaptationsSet.length - 1; i &gt;= 0; i--) { currentAdaptationSet = adaptationsSet[i]; if (currentAdaptationSet) { currentAdaptationType = findAdaptationType(currentAdaptationSet); representations = findRepresentations(currentAdaptationSet); findAndKeepOnlySelectedRepresentations(currentAdaptationSet, representations, currentAdaptationType); representations = findRepresentations(currentAdaptationSet); deleteSegmentBase(currentAdaptationSet); if (representations.length === 0) { currentPeriod.removeChild(currentAdaptationSet); } else { //detect Segment list use case for (let i = 0; i &lt; representations.length; i++) { let rep = representations[i]; let segmentList = getSegmentList(rep); if (segmentList.length &gt;= 1) { editSegmentListAttributes(segmentList, rep); } } let segmentTemplate = getSegmentTemplate(currentAdaptationSet); // segmentTemplate is defined, update attributes in order to be correctly played offline if (segmentTemplate.length &gt;= 1) { editSegmentTemplateAttributes(segmentTemplate); } // detect SegmentBase use case =&gt; transfrom manifest to SegmentList in SegmentTemplate if (representationsToUpdate &amp;&amp; representationsToUpdate.length &gt; 0 ) { let selectedRep; for (let i = 0; i &lt; representations.length; i++) { let rep = representations[i]; for (let j = 0; representationsToUpdate &amp;&amp; j &lt; representationsToUpdate.length; j++) { if (representationsToUpdate[j].id === rep.id) { selectedRep = representationsToUpdate[j]; break; } } } addSegmentTemplateAttributes(currentAdaptationSet, selectedRep); } } } } } /** * Returns type of adapation set * @param {XML} currentAdaptationSet * @returns {string|null} type * @instance */ function findAdaptationType(currentAdaptationSet) { if (getIsMuxed(currentAdaptationSet)) { return constants.MUXED; } else if (getIsAudio(currentAdaptationSet)) { return constants.AUDIO; } else if (getIsVideo(currentAdaptationSet)) { return constants.VIDEO; } else if (getIsFragmentedText(currentAdaptationSet)) { return constants.FRAGMENTED_TEXT; } else if (getIsImage(currentAdaptationSet)) { return constants.IMAGE; } return constants.TEXT; } function getIsAudio(adaptation) { return getIsTypeOf(adaptation, constants.AUDIO); } function getIsVideo(adaptation) { return getIsTypeOf(adaptation, constants.VIDEO); } function getIsFragmentedText(adaptation) { return getIsTypeOf(adaptation, constants.FRAGMENTED_TEXT); } function getIsMuxed(adaptation) { return getIsTypeOf(adaptation, constants.MUXED); } function getIsImage(adaptation) { return getIsTypeOf(adaptation, constants.IMAGE); } // based upon DashManifestModel, but using DomParser function getIsTypeOf(adaptation, type) { if (!adaptation) { throw new Error('adaptation is not defined'); } if (!type) { throw new Error('type is not defined'); } // 1. check codecs for fragmented text if (isFragmentedTextCodecFound(adaptation)) { // fragmented text codec has been found for adaptation, let's check if tested type is fragmented text return type === constants.FRAGMENTED_TEXT; } // 2. test mime type return testMimeType(adaptation, type); } function testMimeType(adaptation, type) { let mimeTypeRegEx = (type !== constants.TEXT) ? new RegExp(type) : new RegExp('(vtt|ttml)'); let mimeType = findMimeType(adaptation); if (mimeType) { return mimeTypeRegEx.test(mimeType); } // no mime type in adaptation, search in representation let representations = findRepresentations(adaptation); if (representations) { for (let i = 0; i &lt; representations.length; i++) { let representation = representations[i]; mimeType = findMimeType(representation); if (mimeType) { return mimeTypeRegEx.test(mimeType); } } } return false; } /** * Search for fragmented text codec in adaptation (STPP or WVTT) * @param {Object} adaptation */ function isFragmentedTextCodecFound (adaptation) { let isFragmentedTextCodecFoundInTag = function (tag) { let codecs = tag.getAttribute(dashConstants.CODECS); if (codecs) { if (codecs.search(constants.STPP) === 0 || codecs.search(constants.WVTT) === 0 ) { return true; } } return false; }; if (isFragmentedTextCodecFoundInTag(adaptation)) { return true; } // check in representations let representations = findRepresentations(adaptation); if (representations &amp;&amp; representations.length &gt; 0) { if (isFragmentedTextCodecFoundInTag(representations[0])) { return true; } } return false; } /** * Returns mime-type of xml tag * @param {Object} tag * @returns {string|null} mimeType * @instance */ function findMimeType(tag) { return tag.getAttribute(dashConstants.MIME_TYPE); } /** * Returns representations of adaptation set * @param {XML} adaptation * @returns {XML} representations * @instance */ function findRepresentations(adaptation) { return adaptation.getElementsByTagName(dashConstants.REPRESENTATION); } /** * Return segment template list of adaptations set * @param {XML} currentAdaptationSet * @returns {XML} representations * @instance */ function getSegmentTemplate(currentAdaptationSet) { return currentAdaptationSet.getElementsByTagName(dashConstants.SEGMENT_TEMPLATE); } /** * Return segment list tags of adaptations set * @param {XML} tag * @returns {XML} representations * @instance */ function getSegmentList(tag) { return tag.getElementsByTagName(dashConstants.SEGMENT_LIST); } function deleteSegmentBase(tag) { let elements = tag.getElementsByTagName(dashConstants.SEGMENT_BASE); for (let i = 0; i &lt; elements.length; i++) { let segmentBase = elements[i]; segmentBase.parentNode.removeChild(segmentBase); } } /** * @param {XML} segmentTemplate * @param {object} rep * @instance */ function addSegmentTimelineElements(segmentTemplate, rep) { let S = DOM.createElement('S'); if (rep &amp;&amp; rep.segments) { let segmentTimelineElement = DOM.createElement(dashConstants.SEGMENT_TIMELINE); let changedDuration = getDurationChangeArray(rep); for (let i = 0; i &lt; changedDuration.length; i++) { let repeatValue = i + 1 &lt; changedDuration.length ? (changedDuration[i + 1] - changedDuration[i]) - 1 : 0; if (repeatValue &gt; 1) { S.setAttribute('r', repeatValue); } S.setAttribute('d', rep.segments[changedDuration[i]].duration); segmentTimelineElement.appendChild(S); S = DOM.createElement('S'); } segmentTemplate.appendChild(segmentTimelineElement); } } function getDurationChangeArray(rep) { let array = []; array.push(0); for (let i = 1; i &lt; rep.segments.length; i++) { if (rep.segments[i - 1].duration !== rep.segments[i].duration) { array.push(i); } } return array; } /** * Update attributes of segment templates to match offline urls * @param {Array} segmentsTemplates * @instance */ function editSegmentTemplateAttributes(segmentsTemplates) { for (let i = 0; i &lt; segmentsTemplates.length; i++) { let media = segmentsTemplates[i].getAttribute(dashConstants.MEDIA); media = '$RepresentationID$_$Number$' + media.substring(media.indexOf('.'), media.length); //id + extension segmentsTemplates[i].setAttribute(dashConstants.START_NUMBER, '0'); segmentsTemplates[i].setAttribute(dashConstants.MEDIA, media); segmentsTemplates[i].setAttribute(dashConstants.INITIALIZATION_MINUS,'$RepresentationID$_init'); } } /** * Update attributes of segment list to match offline urls * @param {Array} segmentLists * @param {Object} representation * @instance */ function editSegmentListAttributes(segmentLists, representation) { let repId = representation.getAttribute(dashConstants.ID); for (let i = 0; i &lt; segmentLists.length; i++) { let segmentList = segmentLists[i]; let initialisation = segmentList.getElementsByTagName(dashConstants.INITIALIZATION); if (initialisation) { let sourceURL = initialisation[0].getAttribute(dashConstants.SOURCE_URL); sourceURL = `${repId}_init`; initialisation[0].setAttribute(dashConstants.SOURCE_URL, sourceURL); } let segmentURLs = segmentList.getElementsByTagName(dashConstants.SEGMENT_URL); if (segmentURLs) { for (let j = 0; j &lt; segmentURLs.length; j++) { let segmentUrl = segmentURLs[j]; let media = segmentUrl.getAttribute(dashConstants.MEDIA); media = `${repId}_${j}`; segmentUrl.setAttribute(dashConstants.MEDIA, media); } } } } /** * @param {XML} adaptationSet * @param {object} rep * @instance */ function addSegmentTemplateAttributes(adaptationSet, rep) { let segmentTemplateElement = DOM.createElement(dashConstants.SEGMENT_TEMPLATE); segmentTemplateElement.setAttribute(dashConstants.START_NUMBER, '0'); segmentTemplateElement.setAttribute(dashConstants.MEDIA, '$RepresentationID$-$Time$'); segmentTemplateElement.setAttribute(dashConstants.INITIALIZATION_MINUS,'$RepresentationID$_init'); addSegmentTimelineElements(segmentTemplateElement, rep); adaptationSet.appendChild(segmentTemplateElement); } /** * Delete all representations except the one choosed by user * @param {XML} currentAdaptationSet * @param {XML} representations * @param {string} adaptationType * @instance */ function findAndKeepOnlySelectedRepresentations(currentAdaptationSet, representations, adaptationType) { for ( var i = representations.length - 1; i &gt;= 0; i--) { let representation = representations[i]; let repId = representation.getAttribute(dashConstants.ID); if (allMediaInfos[adaptationType] &amp;&amp; allMediaInfos[adaptationType].indexOf(repId) === -1) { // representation is not selected, remove it currentAdaptationSet.removeChild(representation); } } } // UTILS /** * Get id of first representation of adaptation set * @param {XMl} currentAdaptationSet * @returns {string} id * @instance */ function getBestRepresentationId(currentAdaptationSet) { let bestRepresentation = currentAdaptationSet.getElementsByTagName(dashConstants.REPRESENTATION)[0]; console.log(bestRepresentation.getAttribute(dashConstants.ID)); return bestRepresentation.getAttribute(dashConstants.ID); } /** * Parse and returns fragments of offline url =&gt; xxxx://xxxx/fragmentId/ * @param {string} url * @returns {string} fragmentId * @instance */ function getFragmentId(url) { let idxFragId = url.lastIndexOf('/'); //logger.warn('fragId : ' + url.substring(idxFragId + 1, url.length)); return url.substring(idxFragId,url.length); } setup(); instance = { parse: parse }; return instance; } OfflineIndexDBManifestParser.__dashjs_factory_name = 'OfflineIndexDBManifestParser'; export default dashjs.FactoryMaker.getClassFactory(OfflineIndexDBManifestParser); /* jshint ignore:line */ × Search results Close "},"core_errors_Errors.js.html":{"id":"core_errors_Errors.js.html","title":"Source: core/errors/Errors.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: core/errors/Errors.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import ErrorsBase from './ErrorsBase'; /** * Errors declaration * @class */ class Errors extends ErrorsBase { constructor () { super(); /** * Error code returned when a manifest parsing error occurs */ this.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE = 10; /** * Error code returned when a manifest loading error occurs */ this.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE = 11; /** * Error code returned when a xlink loading error occurs */ this.XLINK_LOADER_LOADING_FAILURE_ERROR_CODE = 12; /** * Error code returned when the update of segments list has failed */ this.SEGMENTS_UPDATE_FAILED_ERROR_CODE = 13; this.SEGMENTS_UNAVAILABLE_ERROR_CODE = 14; this.SEGMENT_BASE_LOADER_ERROR_CODE = 15; this.TIME_SYNC_FAILED_ERROR_CODE = 16; this.FRAGMENT_LOADER_LOADING_FAILURE_ERROR_CODE = 17; this.FRAGMENT_LOADER_NULL_REQUEST_ERROR_CODE = 18; this.URL_RESOLUTION_FAILED_GENERIC_ERROR_CODE = 19; this.APPEND_ERROR_CODE = 20; this.REMOVE_ERROR_CODE = 21; this.DATA_UPDATE_FAILED_ERROR_CODE = 22; /** * Error code returned when MediaSource is not supported by the browser */ this.CAPABILITY_MEDIASOURCE_ERROR_CODE = 23; /** * Error code returned when Protected contents are not supported */ this.CAPABILITY_MEDIAKEYS_ERROR_CODE = 24; this.DOWNLOAD_ERROR_ID_MANIFEST_CODE = 25; this.DOWNLOAD_ERROR_ID_SIDX_CODE = 26; this.DOWNLOAD_ERROR_ID_CONTENT_CODE = 27; this.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE = 28; this.DOWNLOAD_ERROR_ID_XLINK_CODE = 29; this.MANIFEST_ERROR_ID_CODEC_CODE = 30; this.MANIFEST_ERROR_ID_PARSE_CODE = 31; /** * Error code returned when no stream (period) has been detected in the manifest */ this.MANIFEST_ERROR_ID_NOSTREAMS_CODE = 32; /** * Error code returned when something wrong has append during subtitles parsing (TTML or VTT) */ this.TIMED_TEXT_ERROR_ID_PARSE_CODE = 33; /** * Error code returned when a 'muxed' media type has been detected in the manifest. This type is not supported */ this.MANIFEST_ERROR_ID_MULTIPLEXED_CODE = 34; /** * Error code returned when a media source type is not supported */ this.MEDIASOURCE_TYPE_UNSUPPORTED_CODE = 35; this.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE = 'parsing failed for '; this.MANIFEST_LOADER_LOADING_FAILURE_ERROR_MESSAGE = 'Failed loading manifest: '; this.XLINK_LOADER_LOADING_FAILURE_ERROR_MESSAGE = 'Failed loading Xlink element: '; this.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE = 'Segments update failed'; this.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE = 'no segments are available yet'; this.SEGMENT_BASE_LOADER_ERROR_MESSAGE = 'error loading segments'; this.TIME_SYNC_FAILED_ERROR_MESSAGE = 'Failed to synchronize time'; this.FRAGMENT_LOADER_NULL_REQUEST_ERROR_MESSAGE = 'request is null'; this.URL_RESOLUTION_FAILED_GENERIC_ERROR_MESSAGE = 'Failed to resolve a valid URL'; this.APPEND_ERROR_MESSAGE = 'chunk is not defined'; this.REMOVE_ERROR_MESSAGE = 'buffer is not defined'; this.DATA_UPDATE_FAILED_ERROR_MESSAGE = 'Data update failed'; this.CAPABILITY_MEDIASOURCE_ERROR_MESSAGE = 'mediasource is not supported'; this.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE = 'mediakeys is not supported'; this.TIMED_TEXT_ERROR_MESSAGE_PARSE = 'parsing error :'; this.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE = 'Error creating source buffer of type : '; } } let errors = new Errors(); export default errors; × Search results Close "},"streaming_controllers_EventController.js.html":{"id":"streaming_controllers_EventController.js.html","title":"Source: streaming/controllers/EventController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/controllers/EventController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import XHRLoader from '../net/XHRLoader'; function EventController() { const MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012'; const MPD_RELOAD_VALUE = 1; const MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015'; const MPD_CALLBACK_VALUE = 1; const REFRESH_DELAY = 100; const REMAINING_EVENTS_THRESHOLD = 300; const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, inlineEvents, // Holds all Inline Events not triggered yet inbandEvents, // Holds all Inband Events not triggered yet activeEvents, // Holds all Events currently running eventInterval, // variable holding the setInterval lastEventTimerCall, manifestUpdater, playbackController, eventHandlingInProgress, isStarted; function setup() { logger = Debug(context).getInstance().getLogger(instance); _resetInitialSettings(); } function checkConfig() { if (!manifestUpdater || !playbackController) { throw new Error('setConfig function has to be called previously'); } } function _resetInitialSettings() { isStarted = false; inlineEvents = {}; inbandEvents = {}; activeEvents = {}; eventInterval = null; eventHandlingInProgress = false; lastEventTimerCall = Date.now() / 1000; } function _stop() { try { if (eventInterval !== null &amp;&amp; isStarted) { clearInterval(eventInterval); eventInterval = null; isStarted = false; _onStopEventController(); } } catch (e) { throw e; } } function start() { try { checkConfig(); logger.debug('Start Event Controller'); if (!isStarted &amp;&amp; !isNaN(REFRESH_DELAY)) { isStarted = true; eventInterval = setInterval(_onEventTimer, REFRESH_DELAY); } } catch (e) { throw e; } } /** * Add events to the eventList. Events that are not in the mpd anymore but not triggered yet will still be deleted * @param {Array.&lt;Object&gt;} values */ function addInlineEvents(values) { try { checkConfig(); if (values) { for (let i = 0; i &lt; values.length; i++) { let event = values[i]; inlineEvents[event.id] = event; logger.debug('Add inline event with id ' + event.id); } } logger.debug(`Added ${values.length} inline events`); } catch (e) { throw e; } } /** * i.e. processing of any one event message box with the same id is sufficient * @param {Array.&lt;Object&gt;} values */ function addInbandEvents(values) { try { checkConfig(); for (let i = 0; i &lt; values.length; i++) { let event = values[i]; if (!(event.id in inbandEvents)) { if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME &amp;&amp; inbandEvents[event.id] === undefined) { _handleManifestReloadEvent(event); } inbandEvents[event.id] = event; logger.debug('Add inband event with id ' + event.id); } else { logger.debug('Repeated event with id ' + event.id); } } _onEventTimer(); } catch (e) { throw e; } } function _handleManifestReloadEvent(event) { try { if (event.eventStream.value == MPD_RELOAD_VALUE) { const timescale = event.eventStream.timescale || 1; const validUntil = event.calculatedPresentationTime / timescale; let newDuration; if (event.calculatedPresentationTime == 0xFFFFFFFF) {//0xFF... means remaining duration unknown newDuration = NaN; } else { newDuration = (event.calculatedPresentationTime + event.duration) / timescale; } logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration); eventBus.trigger(Events.MANIFEST_VALIDITY_CHANGED, { id: event.id, validUntil: validUntil, newDuration: newDuration, newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet }); } } catch (e) { } } /** * Remove expired events from the list */ function _removeEvents() { try { if (activeEvents) { let currentVideoTime = playbackController.getTime(); let eventIds = Object.keys(activeEvents); for (let i = 0; i &lt; eventIds.length; i++) { let eventId = eventIds[i]; let event = activeEvents[eventId]; if (event !== null &amp;&amp; (event.duration + event.calculatedPresentationTime) / event.eventStream.timescale &lt; currentVideoTime) { logger.debug('Remove Event ' + eventId + ' at time ' + currentVideoTime); event = null; delete activeEvents[eventId]; } } } } catch (e) { } } /** * Iterate through the eventList and trigger/remove the events */ function _onEventTimer() { try { if (!eventHandlingInProgress) { const currentVideoTime = playbackController.getTime(); let presentationTimeThreshold = (currentVideoTime - lastEventTimerCall); // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once. presentationTimeThreshold = lastEventTimerCall &gt; 0 ? Math.max(0, presentationTimeThreshold) : 0; _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime); _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime); _removeEvents(); lastEventTimerCall = currentVideoTime; } eventHandlingInProgress = false; } catch (e) { eventHandlingInProgress = false; } } function _onStopEventController() { try { // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary. _triggerRemainingEvents(inbandEvents); _triggerRemainingEvents(inlineEvents); } catch (e) { } } function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) { try { if (events) { let eventIds = Object.keys(events); for (let i = 0; i &lt; eventIds.length; i++) { let eventId = eventIds[i]; let event = events[eventId]; if (event !== undefined) { const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime / event.eventStream.timescale; if (calculatedPresentationTimeInSeconds &lt;= currentVideoTime &amp;&amp; calculatedPresentationTimeInSeconds + presentationTimeThreshold &gt;= currentVideoTime) { _startEvent(eventId, event, events); } else if (_eventHasExpired(currentVideoTime, presentationTimeThreshold, calculatedPresentationTimeInSeconds) || _eventIsInvalid(event)) { logger.debug(`Deleting event ${eventId} as it is expired or invalid`); delete events[eventId]; } } } } } catch (e) { } } function _eventHasExpired(currentVideoTime, presentationTimeThreshold, calculatedPresentationTimeInSeconds) { try { return currentVideoTime - presentationTimeThreshold &gt; calculatedPresentationTimeInSeconds; } catch (e) { return false; } } function _eventIsInvalid(event) { try { const periodEndTime = event.eventStream.period.start + event.eventStream.period.duration; return event.calculatedPresentationTime / 1000 &gt; periodEndTime; } catch (e) { return false; } } function _triggerRemainingEvents(events) { try { const eventIds = Object.keys(events); const currentTime = playbackController.getTime(); if (!eventIds || eventIds.length === 0) { return; } const periodDuration = events[eventIds[0]].eventStream &amp;&amp; events[eventIds[0]].eventStream.period &amp;&amp; !isNaN(events[eventIds[0]].eventStream.period.duration) ? events[eventIds[0]].eventStream.period.duration : NaN; const periodStart = events[eventIds[0]].eventStream &amp;&amp; events[eventIds[0]].eventStream.period &amp;&amp; !isNaN(events[eventIds[0]].eventStream.period.start) ? events[eventIds[0]].eventStream.period.start : NaN; if (isNaN(periodDuration) || isNaN(periodStart)) { return; } eventIds.forEach((eventId) =&gt; { const event = events[eventId]; const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime / event.eventStream.timescale; if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) &lt; REMAINING_EVENTS_THRESHOLD) { _startEvent(eventId, event, events); } }); } catch (e) { } } function _startEvent(eventId, event, events) { try { const currentVideoTime = playbackController.getTime(); if (event.duration &gt; 0) { activeEvents[eventId] = event; } if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME &amp;&amp; event.eventStream.value == MPD_RELOAD_VALUE) { if (event.duration !== 0 || event.presentationTimeDelta !== 0) { //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest. logger.debug(`Starting manifest refresh event ${eventId} at ${currentVideoTime}`); _refreshManifest(); } } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME &amp;&amp; event.eventStream.value == MPD_CALLBACK_VALUE) { logger.debug(`Starting callback event ${eventId} at ${currentVideoTime}`); _sendCallbackRequest(event.messageData); } else { logger.debug(`Starting event ${eventId} at ${currentVideoTime}`); eventBus.trigger(event.eventStream.schemeIdUri, {event: event}); } delete events[eventId]; } catch (e) { } } function _refreshManifest() { try { checkConfig(); manifestUpdater.refreshManifest(); } catch (e) { } } function _sendCallbackRequest(url) { try { let loader = XHRLoader(context).create({}); loader.load({ method: 'get', url: url, request: { responseType: 'arraybuffer' } }); } catch (e) { throw e; } } function setConfig(config) { try { if (!config) { return; } if (config.manifestUpdater) { manifestUpdater = config.manifestUpdater; } if (config.playbackController) { playbackController = config.playbackController; } } catch (e) { throw e; } } function reset() { _stop(); _resetInitialSettings(); } instance = { addInlineEvents, addInbandEvents, start, setConfig, reset }; setup(); return instance; } EventController.__dashjs_factory_name = 'EventController'; export default FactoryMaker.getSingletonFactory(EventController); × Search results Close "},"streaming_models_FragmentModel.js.html":{"id":"streaming_models_FragmentModel.js.html","title":"Source: streaming/models/FragmentModel.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/models/FragmentModel.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import FragmentRequest from '../vo/FragmentRequest'; const FRAGMENT_MODEL_LOADING = 'loading'; const FRAGMENT_MODEL_EXECUTED = 'executed'; const FRAGMENT_MODEL_CANCELED = 'canceled'; const FRAGMENT_MODEL_FAILED = 'failed'; function FragmentModel(config) { config = config || {}; const eventBus = config.eventBus; const events = config.events; const dashMetrics = config.dashMetrics; const fragmentLoader = config.fragmentLoader; const debug = config.debug; const streamId = config.streamId; let instance, logger, executedRequests, loadingRequests; function setup() { logger = debug.getLogger(instance); resetInitialSettings(); eventBus.on(events.LOADING_COMPLETED, onLoadingCompleted, instance); eventBus.on(events.LOADING_DATA_PROGRESS, onLoadingInProgress, instance); eventBus.on(events.LOADING_ABANDONED, onLoadingAborted, instance); } function isFragmentLoaded(request) { const isEqualComplete = function (req1, req2) { return ((req1.action === FragmentRequest.ACTION_COMPLETE) &amp;&amp; (req1.action === req2.action)); }; const isEqualMedia = function (req1, req2) { return !isNaN(req1.index) &amp;&amp; (req1.startTime === req2.startTime) &amp;&amp; (req1.adaptationIndex === req2.adaptationIndex) &amp;&amp; (req1.type === req2.type); }; const isEqualInit = function (req1, req2) { return isNaN(req1.index) &amp;&amp; isNaN(req2.index) &amp;&amp; (req1.quality === req2.quality); }; const check = function (requests) { let isLoaded = false; requests.some(req =&gt; { if (isEqualMedia(request, req) || isEqualInit(request, req) || isEqualComplete(request, req)) { isLoaded = true; return isLoaded; } }); return isLoaded; }; if (!request) { return false; } return check(executedRequests); } function isFragmentLoadedOrPending(request) { let isLoaded = false; let i = 0; let req; // First, check if the fragment has already been loaded isLoaded = isFragmentLoaded(request); // Then, check if the fragment is about to be loeaded if (!isLoaded) { for (i = 0; i &lt; loadingRequests.length; i++) { req = loadingRequests[i]; if ((request.url === req.url) &amp;&amp; (request.startTime === req.startTime)) { isLoaded = true; } } } return isLoaded; } /** * * Gets an array of {@link FragmentRequest} objects * * @param {Object} filter The object with properties by which the method filters the requests to be returned. * the only mandatory property is state, which must be a value from * other properties should match the properties of {@link FragmentRequest}. E.g.: * getRequests({state: FragmentModel.FRAGMENT_MODEL_EXECUTED, quality: 0}) - returns * all the requests from executedRequests array where requests.quality = filter.quality * * @returns {Array} * @memberof FragmentModel# */ function getRequests(filter) { const states = filter ? filter.state instanceof Array ? filter.state : [filter.state] : []; let filteredRequests = []; states.forEach(state =&gt; { const requests = getRequestsForState(state); filteredRequests = filteredRequests.concat(filterRequests(requests, filter)); }); return filteredRequests; } function getRequestThreshold(req) { return isNaN(req.duration) ? 0.25 : Math.min(req.duration / 8, 0.5); } function removeExecutedRequestsBeforeTime(time) { executedRequests = executedRequests.filter(req =&gt; { const threshold = getRequestThreshold(req); return isNaN(req.startTime) || (time !== undefined ? req.startTime &gt;= time - threshold : false); }); } function removeExecutedRequestsAfterTime(time) { executedRequests = executedRequests.filter(req =&gt; { return isNaN(req.startTime) || (time !== undefined ? req.startTime &lt; time : false); }); } function removeExecutedRequestsInTimeRange(start, end) { if (end &lt;= start + 0.5) { return; } executedRequests = executedRequests.filter(req =&gt; { const threshold = getRequestThreshold(req); return (isNaN(req.startTime) || req.startTime &gt;= (end - threshold)) || (isNaN(req.duration) || (req.startTime + req.duration) &lt;= (start + threshold)); }); } // Remove requests that are not \"represented\" by any of buffered ranges function syncExecutedRequestsWithBufferedRange(bufferedRanges, streamDuration) { if (!bufferedRanges || bufferedRanges.length === 0) { removeExecutedRequestsBeforeTime(); return; } let start = 0; for (let i = 0, ln = bufferedRanges.length; i &lt; ln; i++) { removeExecutedRequestsInTimeRange(start, bufferedRanges.start(i)); start = bufferedRanges.end(i); } if (streamDuration &gt; 0) { removeExecutedRequestsInTimeRange(start, streamDuration); } } function abortRequests() { logger.debug('abort requests'); fragmentLoader.abort(); loadingRequests = []; } function executeRequest(request) { switch (request.action) { case FragmentRequest.ACTION_COMPLETE: executedRequests.push(request); addSchedulingInfoMetrics(request, FRAGMENT_MODEL_EXECUTED); logger.debug('STREAM_COMPLETED'); eventBus.trigger(events.STREAM_COMPLETED, { request: request }); break; case FragmentRequest.ACTION_DOWNLOAD: addSchedulingInfoMetrics(request, FRAGMENT_MODEL_LOADING); loadingRequests.push(request); loadCurrentFragment(request); break; default: logger.warn('Unknown request action.'); } } function loadCurrentFragment(request) { eventBus.trigger(events.FRAGMENT_LOADING_STARTED, { streamId: streamId, request: request }); fragmentLoader.load(request); } function getRequestForTime(arr, time, threshold) { // loop through the executed requests and pick the one for which the playback interval matches the given time const lastIdx = arr.length - 1; for (let i = lastIdx; i &gt;= 0; i--) { const req = arr[i]; const start = req.startTime; const end = start + req.duration; threshold = !isNaN(threshold) ? threshold : getRequestThreshold(req); if ((!isNaN(start) &amp;&amp; !isNaN(end) &amp;&amp; ((time + threshold) &gt;= start) &amp;&amp; ((time - threshold) &lt; end)) || (isNaN(start) &amp;&amp; isNaN(time))) { return req; } } return null; } function filterRequests(arr, filter) { // for time use a specific filtration function if (filter.hasOwnProperty('time')) { return [getRequestForTime(arr, filter.time, filter.threshold)]; } return arr.filter(request =&gt; { for (const prop in filter) { if (prop === 'state') continue; if (filter.hasOwnProperty(prop) &amp;&amp; request[prop] != filter[prop]) return false; } return true; }); } function getRequestsForState(state) { let requests; switch (state) { case FRAGMENT_MODEL_LOADING: requests = loadingRequests; break; case FRAGMENT_MODEL_EXECUTED: requests = executedRequests; break; default: requests = []; } return requests; } function addSchedulingInfoMetrics(request, state) { dashMetrics.addSchedulingInfo(request, state); dashMetrics.addRequestsQueue(request.mediaType, loadingRequests, executedRequests); } function onLoadingCompleted(e) { if (e.sender !== fragmentLoader) return; loadingRequests.splice(loadingRequests.indexOf(e.request), 1); if (e.response &amp;&amp; !e.error) { executedRequests.push(e.request); } addSchedulingInfoMetrics(e.request, e.error ? FRAGMENT_MODEL_FAILED : FRAGMENT_MODEL_EXECUTED); eventBus.trigger(events.FRAGMENT_LOADING_COMPLETED, { request: e.request, response: e.response, error: e.error, sender: this }); } function onLoadingInProgress(e) { if (e.sender !== fragmentLoader) return; eventBus.trigger(events.FRAGMENT_LOADING_PROGRESS, { request: e.request, response: e.response, error: e.error, sender: this }); } function onLoadingAborted(e) { if (e.sender !== fragmentLoader) return; eventBus.trigger(events.FRAGMENT_LOADING_ABANDONED, { streamId: streamId, request: e.request, mediaType: e.mediaType }); } function resetInitialSettings() { executedRequests = []; loadingRequests = []; } function reset() { eventBus.off(events.LOADING_COMPLETED, onLoadingCompleted, this); eventBus.off(events.LOADING_DATA_PROGRESS, onLoadingInProgress, this); eventBus.off(events.LOADING_ABANDONED, onLoadingAborted, this); if (fragmentLoader) { fragmentLoader.reset(); } resetInitialSettings(); } function addExecutedRequest(request) { executedRequests.push(request); } instance = { getRequests: getRequests, isFragmentLoaded: isFragmentLoaded, isFragmentLoadedOrPending: isFragmentLoadedOrPending, removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime, removeExecutedRequestsAfterTime: removeExecutedRequestsAfterTime, syncExecutedRequestsWithBufferedRange: syncExecutedRequestsWithBufferedRange, abortRequests: abortRequests, executeRequest: executeRequest, reset: reset, addExecutedRequest: addExecutedRequest }; setup(); return instance; } FragmentModel.__dashjs_factory_name = 'FragmentModel'; const factory = FactoryMaker.getClassFactory(FragmentModel); factory.FRAGMENT_MODEL_LOADING = FRAGMENT_MODEL_LOADING; factory.FRAGMENT_MODEL_EXECUTED = FRAGMENT_MODEL_EXECUTED; factory.FRAGMENT_MODEL_CANCELED = FRAGMENT_MODEL_CANCELED; factory.FRAGMENT_MODEL_FAILED = FRAGMENT_MODEL_FAILED; FactoryMaker.updateClassFactory(FragmentModel.__dashjs_factory_name, factory); export default factory; × Search results Close "},"streaming_FragmentSink.js.html":{"id":"streaming_FragmentSink.js.html","title":"Source: streaming/FragmentSink.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/FragmentSink.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * The end place to put fragments after they have been fetched. * @interface FragmentSink * @ignore */ /** * Append a chunk to the internal buffer. You should assume that the effects of this are asynchronous. * @function FragmentSink#append * @param {Object} chunk A loaded chunk like that generated by the FragmentController */ /** * Remove data from within the specified time ranges. * @function FragmentSink#remove * @param {?Number} start The beginning of the range that should be removed from the sink's internal buffer. If NaN, it is regarded as unbounded. * @param {?Number} end The end of the range that should be removed from the sink's internal buffer. If NaN, it is regarded as unbounded. */ /** * Abort an append operation currently ongoing. * @function FragmentSink#abort */ /** * @function FragmentSink#getAllBufferRanges * @returns {Array} A TimeRanges-like object representing all the buffer ranges that are present in the sink. */ /** * Remove all the data in the sink's internal buffer. * @function FragmentSink#reset */ × Search results Close "},"streaming_vo_metrics_HTTPRequest.js.html":{"id":"streaming_vo_metrics_HTTPRequest.js.html","title":"Source: streaming/vo/metrics/HTTPRequest.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/HTTPRequest.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc This Object holds reference to the HTTPRequest for manifest, fragment and xlink loading. * Members which are not defined in ISO23009-1 Annex D should be prefixed by a _ so that they are ignored * by Metrics Reporting code. * @ignore */ class HTTPRequest { /** * @class */ constructor() { /** * Identifier of the TCP connection on which the HTTP request was sent. * @public */ this.tcpid = null; /** * This is an optional parameter and should not be included in HTTP request/response transactions for progressive download. * The type of the request: * - MPD * - XLink expansion * - Initialization Fragment * - Index Fragment * - Media Fragment * - Bitstream Switching Fragment * - other * @public */ this.type = null; /** * The original URL (before any redirects or failures) * @public */ this.url = null; /** * The actual URL requested, if different from above * @public */ this.actualurl = null; /** * The contents of the byte-range-spec part of the HTTP Range header. * @public */ this.range = null; /** * Real-Time | The real time at which the request was sent. * @public */ this.trequest = null; /** * Real-Time | The real time at which the first byte of the response was received. * @public */ this.tresponse = null; /** * The HTTP response code. * @public */ this.responsecode = null; /** * The duration of the throughput trace intervals (ms), for successful requests only. * @public */ this.interval = null; /** * Throughput traces, for successful requests only. * @public */ this.trace = []; /** * Type of stream (\"audio\" | \"video\" etc..) * @public */ this._stream = null; /** * Real-Time | The real time at which the request finished. * @public */ this._tfinish = null; /** * The duration of the media requests, if available, in milliseconds. * @public */ this._mediaduration = null; /** * The media segment quality * @public */ this._quality = null; /** * all the response headers from request. * @public */ this._responseHeaders = null; /** * The selected service location for the request. string. * @public */ this._serviceLocation = null; } } /** * @classdesc This Object holds reference to the progress of the HTTPRequest. * @ignore */ class HTTPRequestTrace { /** * @class */ constructor() { /** * Real-Time | Measurement stream start. * @public */ this.s = null; /** * Measurement stream duration (ms). * @public */ this.d = null; /** * List of integers counting the bytes received in each trace interval within the measurement stream. * @public */ this.b = []; } } HTTPRequest.GET = 'GET'; HTTPRequest.HEAD = 'HEAD'; HTTPRequest.MPD_TYPE = 'MPD'; HTTPRequest.XLINK_EXPANSION_TYPE = 'XLinkExpansion'; HTTPRequest.INIT_SEGMENT_TYPE = 'InitializationSegment'; HTTPRequest.INDEX_SEGMENT_TYPE = 'IndexSegment'; HTTPRequest.MEDIA_SEGMENT_TYPE = 'MediaSegment'; HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE = 'BitstreamSwitchingSegment'; HTTPRequest.OTHER_TYPE = 'other'; export { HTTPRequest, HTTPRequestTrace }; × Search results Close "},"offline_net_IndexDBOfflineLoader.js.html":{"id":"offline_net_IndexDBOfflineLoader.js.html","title":"Source: offline/net/IndexDBOfflineLoader.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/net/IndexDBOfflineLoader.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import IndexDBStore from '../storage/IndexDBStore'; function IndexDBOfflineLoader(config) { config = config || {}; const context = this.context; const urlUtils = config.urlUtils; const constants = config.constants; const dashConstants = config.dashConstants; let instance, indexDBStore; function setup() { indexDBStore = IndexDBStore(context).getInstance(); } function getManifestId (url) { let myURL = urlUtils.removeHostname(url); var parts = myURL.split('/'); return parts[0]; } /** * Load manifest or fragment from indexeddb database * @param {object} config configuration of request */ function load(config) { if (config.request) { let manifestId = getManifestId(config.request.url); if (manifestId % 1 === 0) { if ( config.request.mediaType === constants.AUDIO || config.request.mediaType === constants.VIDEO || config.request.mediaType === constants.TEXT || config.request.mediaType === constants.MUXED || config.request.mediaType === constants.IMAGE || config.request.mediaType === constants.FRAGMENTED_TEXT || config.request.mediaType === constants.EMBEDDED_TEXT ) { let suffix = config.request.type === 'InitializationSegment' ? 'init' : config.request.index; let key = config.request.representationId + '_' + suffix; indexDBStore.getFragmentByKey(manifestId, key).then(function (fragment) { config.success(fragment, null, config.request.url, constants.ARRAY_BUFFER); }).catch(function (err) { config.error(err); }); } else if (config.request.type === dashConstants.MPD) { indexDBStore.getManifestById(manifestId).then(function (item) { indexDBStore.createFragmentStore(item.fragmentStore); config.success(item.manifest, null, config.request.url, constants.XML); }).catch(function (err) { config.error(config.request, 404, err); }); } } else { config.error(config.request, null, 'MediaType can not be found'); } } } function abort() { // nothing to do } setup(); instance = { load: load, abort: abort }; return instance; } IndexDBOfflineLoader.__dashjs_factory_name = 'IndexDBOfflineLoader'; const factory = dashjs.FactoryMaker.getClassFactory(IndexDBOfflineLoader); /* jshint ignore:line */ export default factory; × Search results Close "},"offline_storage_IndexDBStore.js.html":{"id":"offline_storage_IndexDBStore.js.html","title":"Source: offline/storage/IndexDBStore.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/storage/IndexDBStore.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ const localforage = require('localforage'); const entities = require('html-entities').XmlEntities; /** * @ignore */ function IndexDBStore() { let instance, manifestStore, fragmentStores; function setup() { fragmentStores = {}; if (typeof window === 'undefined') { return; } localforage.config({ driver: localforage.INDEXEDDB, name: 'dash_offline_db' }); manifestStore = localforage.createInstance({ driver: localforage.INDEXEDDB, name: 'dash_offline_db', version: 1.0, storeName: 'manifest' }); } ///////////////////////////////////////// // // GET/SET Methods // //////////////////////////////////////// /** * Creates an instance of localforage to store fragments in indexed db * @param {string} storeName * @instance */ function createFragmentStore(storeName) { if (!fragmentStores[storeName]) { console.log('setStore ' + storeName); let fragmentStore = localforage.createInstance({ driver: localforage.INDEXEDDB, name: 'dash_offline_db', version: 1.0, storeName: storeName }); fragmentStores[storeName] = fragmentStore; } } /** * Update download status * @param {number} manifestId * @param {string} newStatus * @returns {Promise} promise * @instance */ function setDownloadingStatus(manifestId, newStatus) { return getManifestById(manifestId).then(function (item) { item.status = newStatus; return updateManifest(item).catch(function () { return Promise.reject('Cannot set status ' + newStatus + ' for this stream !'); }); }).catch(function (err) { return Promise.reject(err); }); } /** * Updat last downloaded fragment index for representationId * @param {number} manifestId - manifest id * @param {string} representationId - representation * @param {number} state - representation state * @returns {Promise} promise * @instance */ function setRepresentationCurrentState(manifestId, representationId, state) { return getManifestById(manifestId).then(function (item) { if (!item.state) { item.state = {}; } if (!item.state[representationId]) { item.state[representationId] = { index: -1, downloaded: 0 }; } item.state[representationId] = state; return updateManifest(item).catch(function () { return Promise.reject('Cannot set current index for represenation id ' + representationId); }); }).catch(function (err) { return Promise.reject(err); }); } /** * Returns current downloaded segment index for representation * @param {number} manifestId - manifest id * @param {string} representationId - representation * @returns {Promise} promise * @instance */ function getRepresentationCurrentState(manifestId, representationId) { return getManifestById(manifestId).then(function (item) { let state = { index: -1, downloaded: 0 }; if (item.state &amp;&amp; item.state[representationId]) { state = item.state[representationId]; } return Promise.resolve(state); }).catch(function (err) { return Promise.reject(err); }); } /** * Returns a fragment from its key * @param {number} manifestId * @param {number} key * @returns {Promise} fragment * @instance */ function getFragmentByKey(manifestId, key) { let fragmentStore = fragmentStores[manifestId]; if (!fragmentStore) { return Promise.reject(new Error (`No fragment store found for manifest ${manifestId}`)); } return fragmentStore.getItem(key).then(function (value) { return Promise.resolve(value); }).catch(function (err) { return Promise.reject(err); }); } /** * Returns a manifest from its identifier * @param {number} id * @returns {Promise} {Object[]} manifests * @instance */ function getManifestById(id) { return getAllManifests().then(function (array) { if (array) { let item = null; for (let i = 0; i &lt; array.manifests.length; i++) { if (array.manifests[i].manifestId === parseInt(id)) { item = array.manifests[i]; } } if (item !== null) { item.manifest = entities.decode(item.manifest); return Promise.resolve(item); } else { return Promise.reject('Cannot found manifest with this manifestId : ' + id); } } else { return Promise.reject('Any manifests stored in DB !'); } }).catch(function (err) { return Promise.reject(err); }); } /** * Returns all offline manifests * @returns {Promise} {Object[]} manifests * @instance */ function getAllManifests() { return manifestStore.getItem('manifest').then(function (array) { return Promise.resolve(array ? array : { 'manifests': [] }); }).catch(function (err) { return Promise.reject(err); }); } /** * Return higher manifest id * @returns {Promise} number * @instance */ function getCurrentHigherManifestId() { return getAllManifests().then(function (array) { let higherManifestId = 0; if (array) { for (let i = 0; i &lt; array.manifests.length; i++) { if (array.manifests[i].manifestId &gt; higherManifestId) { higherManifestId = array.manifests[i].manifestId; } } return Promise.resolve(higherManifestId); } else { return Promise.resolve(higherManifestId); } }).catch(function (err) { return Promise.reject(err); }); } /** * Update manifest * @param {Object} manifest updated manifest * @returns {Promise} promise asynchronously resolved * @instance */ function updateManifest(manifest) { return getAllManifests().then(function (array) { try { for (let i = 0; i &lt; array.manifests.length; i++) { if (array.manifests[i].manifestId === manifest.manifestId) { array.manifests[i] = manifest; } } return manifestStore.setItem('manifest', array); } catch (err) { throw new Error('Any results found !'); } }); } /** * save selected representation by user * @param {Object} manifest updated manifest * @param {Object} selected selected representations * @returns {Promise} promise asynchronously resolved * @instance */ function saveSelectedRepresentations(manifest, selected) { return getManifestById(manifest).then(function (item) { if (!item.selected) { item.selected = {}; } item.selected = selected; return updateManifest(item).catch(function () { return Promise.reject('Cannot save selected representations'); }); }).catch(function (err) { return Promise.reject(err); }); } /** * Store a manifest in manifest array * @param {Object} manifest * @instance */ function storeManifest(manifest) { return manifestStore.getItem('manifest').then(function (results) { let array = results ? results : { 'manifests': [] }; array.manifests.push(manifest); return manifestStore.setItem('manifest', array); }); } /** * Store a fragment in fragment store * @param {number} manifestId * @param {number} fragmentId * @param {Object} fragmentData * @returns {Promise} promise asynchronously resolved * @instance */ function storeFragment(manifestId, fragmentId, fragmentData) { let fragmentStore = fragmentStores[manifestId]; if (!fragmentStore) { return Promise.reject(new Error (`No fragment store found for manifest ${manifestId}`)); } return fragmentStore.setItem(fragmentId, fragmentData, function () { return Promise.resolve(); }).catch(function (err) { return Promise.reject(err); }); } ///////////////////////////////////////// // // DROP Methods // //////////////////////////////////////// /** * Remove all manifest and fragment store * @returns {Promise} promise asynchronously resolved * @instance */ function dropAll() { return localforage.clear().then(function () { return Promise.resolve(); }).catch(function (err) { return Promise.reject(err); }); } /** * Remove framgent store given its name * @param {string} storeName * @instance */ function dropFragmentStore(storeName) { localforage.dropInstance({ driver: localforage.INDEXEDDB, name: 'dash_offline_db', version: 1.0, storeName: storeName }).then(function () { delete fragmentStores[storeName]; }).catch(function (err) { console.log('dropFragmentStore failed ' + err); }); return; } /** * Remove download given its id (fragmentStore + manifest entry in manifest array) * @param {number} manifestId * @returns {Promise} promise asynchronously resolved * @instance */ function deleteDownloadById(manifestId) { return manifestStore.getItem('manifest').then(function (array) { if (array) { return deleteFragmentStore(manifestId).then(function () { for (let i = 0; i &lt; array.manifests.length; i++) { if (array.manifests[i].manifestId === parseInt(manifestId)) { array.manifests.splice(i, 1); } } return manifestStore.setItem('manifest', array).then(function () { return Promise.resolve('This stream has been successfull removed !'); }).catch(function () { return Promise.reject('An error occured when trying to delete this manifest'); }); }); } else { return Promise.resolve('Nothing to delete !'); } }).catch(function (err) { return Promise.reject(err); }); } /** * Remove fragment store * @param {string} storeName * @returns {Promise} promise asynchronously resolved * @instance */ function deleteFragmentStore(storeName) { localforage.createInstance({ name: 'dash_offline_db', storeName: storeName }); return localforage.dropInstance({ name: 'dash_offline_db', storeName: storeName }).then(function () { delete fragmentStores[storeName]; return Promise.resolve(); }).catch(function (err) { console.log(err); return Promise.reject(err); }); } setup(); instance = { dropAll: dropAll, getFragmentByKey: getFragmentByKey, getManifestById: getManifestById, storeFragment: storeFragment, storeManifest: storeManifest, updateManifest: updateManifest, saveSelectedRepresentations: saveSelectedRepresentations, createFragmentStore: createFragmentStore, setDownloadingStatus: setDownloadingStatus, setRepresentationCurrentState: setRepresentationCurrentState, getRepresentationCurrentState: getRepresentationCurrentState, getCurrentHigherManifestId: getCurrentHigherManifestId, getAllManifests: getAllManifests, dropFragmentStore: dropFragmentStore, deleteDownloadById: deleteDownloadById }; return instance; } IndexDBStore.__dashjs_factory_name = 'IndexDBStore'; export default dashjs.FactoryMaker.getSingletonFactory(IndexDBStore); /* jshint ignore:line */ × Search results Close "},"streaming_utils_IsoFile.js.html":{"id":"streaming_utils_IsoFile.js.html","title":"Source: streaming/utils/IsoFile.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/IsoFile.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import IsoBox from '../vo/IsoBox'; import FactoryMaker from '../../core/FactoryMaker'; function IsoFile() { let instance, parsedIsoFile; /** * @param {string} type * @returns {IsoBox|null} * @memberof IsoFile# */ function getBox(type) { if (!type || !parsedIsoFile || !parsedIsoFile.boxes || (parsedIsoFile.boxes.length === 0) || typeof parsedIsoFile.fetch !== 'function') return null; return convertToDashIsoBox(parsedIsoFile.fetch(type)); } /** * @param {string} type * @returns {Array|null} array of {@link IsoBox} * @memberof IsoFile# */ function getBoxes(type) { let boxes = []; if (!type || !parsedIsoFile || typeof parsedIsoFile.fetchAll !== 'function') { return boxes; } let boxData = parsedIsoFile.fetchAll(type); let box; for (let i = 0, ln = boxData.length; i &lt; ln; i++) { box = convertToDashIsoBox(boxData[i]); if (box) { boxes.push(box); } } return boxes; } /** * @param {string} value * @memberof IsoFile# */ function setData(value) { parsedIsoFile = value; } /** * @returns {IsoBox|null} * @memberof IsoFile# */ function getLastBox() { if (!parsedIsoFile || !parsedIsoFile.boxes || !parsedIsoFile.boxes.length) return null; let type = parsedIsoFile.boxes[parsedIsoFile.boxes.length - 1].type; let boxes = getBoxes(type); return boxes.length &gt; 0 ? boxes[boxes.length - 1] : null; } function convertToDashIsoBox(boxData) { if (!boxData) return null; let box = new IsoBox(boxData); if (boxData.hasOwnProperty('_incomplete')) { box.isComplete = !boxData._incomplete; } return box; } instance = { getBox: getBox, getBoxes: getBoxes, setData: setData, getLastBox: getLastBox }; return instance; } IsoFile.__dashjs_factory_name = 'IsoFile'; export default FactoryMaker.getClassFactory(IsoFile); × Search results Close "},"streaming_protection_drm_KeySystem.js.html":{"id":"streaming_protection_drm_KeySystem.js.html","title":"Source: streaming/protection/drm/KeySystem.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/drm/KeySystem.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Defines the public interface for all Key Systems (DRMs) supported * by the player. * * @interface KeySystem * @ignore */ /** * Key system name string (e.g. 'org.w3.clearkey') * * @instance * @name systemString * @memberof KeySystem * @readonly * @type String */ /** * Key system UUID in the form '01234567-89ab-cdef-0123-456789abcdef' * * @instance * @name uuid * @memberof KeySystem * @readonly * @type String */ /** * The scheme ID URI for this key system in the form * 'urn:uuid:01234567-89ab-cdef-0123-456789abcdef' as used * in DASH ContentProtection elements * * @instance * @name schemeIdURI * @memberof KeySystem * @readonly * @type String */ /** * Parse DRM-specific init data from the ContentProtection * element. * * @function * @name KeySystem#getInitData * @param {Object} contentProtection the json-style contentProtection * object representing the ContentProtection element parsed from the * MPD XML document. * @param {Object} cencContentProtection the Common Encryption content protection element or * null if not specified. * @returns {ArrayBuffer} EME initialization data */ /** * For some key systems, the CDM message contains HTTP headers that * can be parsed by the application and attached to the license request. * Returns a header object with key/value pairs as object properties/values * * @function * @name KeySystem#getRequestHeadersFromMessage * @param {ArrayBuffer} message the CDM message * @returns {?Object} headers object with header names as the object property * names and header values as the corresponding object property values. Return * null if no such headers were found or if the mechanism is not supported by * this key system */ /** * For some key systems, the CDM message contains more than just the * license request data. This method will pull the license request from * the CDM message, if necessary. * * @function * @name KeySystem#getLicenseRequestFromMessage * @param message {ArrayBuffer} the CDM message * @returns {Uint8Array} the license request message as will be passed to * XMLHttpRequest.send() */ /** * Returns a license server URL as parsed from key system initialization data (PSSH). * * @function * @name KeySystem#getLicenseServerURLFromInitData * @param initData {ArrayBuffer} the initialization data. This is just the \"Data\" field * from the PSSH box definition * @returns {?string} The license server URL or null if URL is not available in initData */ /** * Returns specific CDM (custom) data. * * @function * @name MediaPlayer.dependencies.protection.KeySystem#getCDMData * @returns {ArrayBuffer} the CDM (custom) data */ /** * Returns MediaKeySession session ID. * * @function * @name MediaPlayer.dependencies.protection.KeySystem#getSessionId * @returns {String} the MediaKeySession session ID */ × Search results Close "},"streaming_protection_drm_KeySystemClearKey.js.html":{"id":"streaming_protection_drm_KeySystemClearKey.js.html","title":"Source: streaming/protection/drm/KeySystemClearKey.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/drm/KeySystemClearKey.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import KeyPair from '../vo/KeyPair'; import ClearKeyKeySet from '../vo/ClearKeyKeySet'; import CommonEncryption from '../CommonEncryption'; import ProtectionConstants from '../../constants/ProtectionConstants'; const uuid = 'e2719d58-a985-b3c9-781a-b030af78d30e'; const systemString = ProtectionConstants.CLEARKEY_KEYSTEM_STRING; const schemeIdURI = 'urn:uuid:' + uuid; function KeySystemClearKey(config) { config = config || {}; let instance; const BASE64 = config.BASE64; const LICENSE_SERVER_MANIFEST_CONFIGURATIONS = { attributes: ['Laurl', 'laurl'], prefixes: ['clearkey', 'dashif'] }; /** * Returns desired clearkeys (as specified in the CDM message) from protection data * * @param {ProtectionData} protectionData the protection data * @param {ArrayBuffer} message the ClearKey CDM message * @returns {ClearKeyKeySet} the key set or null if none found * @throws {Error} if a keyID specified in the CDM message was not found in the * protection data * @memberof KeySystemClearKey */ function getClearKeysFromProtectionData(protectionData, message) { let clearkeySet = null; if (protectionData) { // ClearKey is the only system that does not require a license server URL, so we // handle it here when keys are specified in protection data const jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message))); const keyPairs = []; for (let i = 0; i &lt; jsonMsg.kids.length; i++) { const clearkeyID = jsonMsg.kids[i]; const clearkey = (protectionData.clearkeys &amp;&amp; protectionData.clearkeys.hasOwnProperty(clearkeyID)) ? protectionData.clearkeys[clearkeyID] : null; if (!clearkey) { throw new Error('DRM: ClearKey keyID (' + clearkeyID + ') is not known!'); } // KeyIDs from CDM are not base64 padded. Keys may or may not be padded keyPairs.push(new KeyPair(clearkeyID, clearkey)); } clearkeySet = new ClearKeyKeySet(keyPairs); } return clearkeySet; } function getInitData(cp, cencContentProtection) { try { let initData = CommonEncryption.parseInitDataFromContentProtection(cp, BASE64); if (!initData &amp;&amp; cencContentProtection) { const cencDefaultKid = cencDefaultKidToBase64Representation(cencContentProtection['cenc:default_KID']); const data = {kids: [cencDefaultKid]}; initData = new TextEncoder().encode(JSON.stringify(data)); } return initData; } catch (e) { return null; } } function cencDefaultKidToBase64Representation(cencDefaultKid) { try { let kid = cencDefaultKid.replace(/-/g, ''); kid = btoa(kid.match(/\\w{2}/g).map((a) =&gt; { return String.fromCharCode(parseInt(a, 16)); }).join('')); return kid.replace(/=/g, ''); } catch (e) { return null; } } function getRequestHeadersFromMessage(/*message*/) { // Set content type to application/json by default return { 'Content-Type': 'application/json' }; } function getLicenseRequestFromMessage(message) { return JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message))); } function getLicenseServerURLFromInitData(/*initData*/) { return null; } function getLicenseServerUrlFromMediaInfo(mediaInfo) { try { if (!mediaInfo || mediaInfo.length === 0) { return null; } let i = 0; let licenseServer = null; while (i &lt; mediaInfo.length &amp;&amp; !licenseServer) { const info = mediaInfo[i]; if (info &amp;&amp; info.contentProtection &amp;&amp; info.contentProtection.length &gt; 0) { const clearkeyProtData = info.contentProtection.filter((cp) =&gt; { return cp.schemeIdUri &amp;&amp; cp.schemeIdUri === schemeIdURI; }); if (clearkeyProtData &amp;&amp; clearkeyProtData.length &gt; 0) { let j = 0; while (j &lt; clearkeyProtData.length &amp;&amp; !licenseServer) { const ckData = clearkeyProtData[j]; let k = 0; while (k &lt; LICENSE_SERVER_MANIFEST_CONFIGURATIONS.attributes.length &amp;&amp; !licenseServer) { let l = 0; const attribute = LICENSE_SERVER_MANIFEST_CONFIGURATIONS.attributes[k]; while (l &lt; LICENSE_SERVER_MANIFEST_CONFIGURATIONS.prefixes.length &amp;&amp; !licenseServer) { const prefix = LICENSE_SERVER_MANIFEST_CONFIGURATIONS.prefixes[l]; if (ckData[attribute] &amp;&amp; ckData[attribute].__prefix &amp;&amp; ckData[attribute].__prefix === prefix &amp;&amp; ckData[attribute].__text) { licenseServer = ckData[attribute].__text; } l += 1; } k += 1; } j += 1; } } } i += 1; } return licenseServer; } catch (e) { return null; } } function getCDMData() { return null; } function getSessionId(/*cp*/) { return null; } instance = { uuid: uuid, schemeIdURI: schemeIdURI, systemString: systemString, getInitData: getInitData, getRequestHeadersFromMessage: getRequestHeadersFromMessage, getLicenseRequestFromMessage: getLicenseRequestFromMessage, getLicenseServerURLFromInitData: getLicenseServerURLFromInitData, getCDMData: getCDMData, getSessionId: getSessionId, getLicenseServerUrlFromMediaInfo, getClearKeysFromProtectionData: getClearKeysFromProtectionData }; return instance; } KeySystemClearKey.__dashjs_factory_name = 'KeySystemClearKey'; export default dashjs.FactoryMaker.getSingletonFactory(KeySystemClearKey); /* jshint ignore:line */ × Search results Close "},"streaming_protection_drm_KeySystemW3CClearKey.js.html":{"id":"streaming_protection_drm_KeySystemW3CClearKey.js.html","title":"Source: streaming/protection/drm/KeySystemW3CClearKey.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/drm/KeySystemW3CClearKey.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import KeyPair from '../vo/KeyPair'; import ClearKeyKeySet from '../vo/ClearKeyKeySet'; import CommonEncryption from '../CommonEncryption'; import ProtectionConstants from '../../constants/ProtectionConstants'; const uuid = '1077efec-c0b2-4d02-ace3-3c1e52e2fb4b'; const systemString = ProtectionConstants.CLEARKEY_KEYSTEM_STRING; const schemeIdURI = 'urn:uuid:' + uuid; function KeySystemW3CClearKey(config) { let instance; const BASE64 = config.BASE64; const logger = config.debug.getLogger(instance); /** * Returns desired clearkeys (as specified in the CDM message) from protection data * * @param {ProtectionDataSet} protectionData the protection data * @param {ArrayBuffer} message the ClearKey CDM message * @returns {ClearKeyKeySet} the key set or null if none found * @throws {Error} if a keyID specified in the CDM message was not found in the * protection data * @memberof KeySystemClearKey */ function getClearKeysFromProtectionData(protectionData, message) { let clearkeySet = null; if (protectionData) { // ClearKey is the only system that does not require a license server URL, so we // handle it here when keys are specified in protection data const jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message))); const keyPairs = []; for (let i = 0; i &lt; jsonMsg.kids.length; i++) { const clearkeyID = jsonMsg.kids[i]; const clearkey = (protectionData.clearkeys &amp;&amp; protectionData.clearkeys.hasOwnProperty(clearkeyID)) ? protectionData.clearkeys[clearkeyID] : null; if (!clearkey) { throw new Error('DRM: ClearKey keyID (' + clearkeyID + ') is not known!'); } // KeyIDs from CDM are not base64 padded. Keys may or may not be padded keyPairs.push(new KeyPair(clearkeyID, clearkey)); } clearkeySet = new ClearKeyKeySet(keyPairs); logger.warn('ClearKey schemeIdURI is using W3C Common PSSH systemID (1077efec-c0b2-4d02-ace3-3c1e52e2fb4b) in Content Protection. See DASH-IF IOP v4.1 section 7.6.2.4'); } return clearkeySet; } function getInitData(cp) { return CommonEncryption.parseInitDataFromContentProtection(cp, BASE64); } function getRequestHeadersFromMessage(/*message*/) { return null; } function getLicenseRequestFromMessage(message) { return new Uint8Array(message); } function getLicenseServerURLFromInitData(/*initData*/) { return null; } function getCDMData() { return null; } function getSessionId(/*cp*/) { return null; } instance = { uuid: uuid, schemeIdURI: schemeIdURI, systemString: systemString, getInitData: getInitData, getRequestHeadersFromMessage: getRequestHeadersFromMessage, getLicenseRequestFromMessage: getLicenseRequestFromMessage, getLicenseServerURLFromInitData: getLicenseServerURLFromInitData, getCDMData: getCDMData, getSessionId: getSessionId, getClearKeysFromProtectionData: getClearKeysFromProtectionData }; return instance; } KeySystemW3CClearKey.__dashjs_factory_name = 'KeySystemW3CClearKey'; export default dashjs.FactoryMaker.getSingletonFactory(KeySystemW3CClearKey); /* jshint ignore:line */ × Search results Close "},"streaming_protection_drm_KeySystemPlayReady.js.html":{"id":"streaming_protection_drm_KeySystemPlayReady.js.html","title":"Source: streaming/protection/drm/KeySystemPlayReady.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/drm/KeySystemPlayReady.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Microsoft PlayReady DRM * * @class * @implements KeySystem */ import CommonEncryption from '../CommonEncryption'; import ProtectionConstants from '../../constants/ProtectionConstants'; const uuid = '9a04f079-9840-4286-ab92-e65be0885f95'; const systemString = ProtectionConstants.PLAYREADY_KEYSTEM_STRING; const schemeIdURI = 'urn:uuid:' + uuid; const PRCDMData = '&lt;PlayReadyCDMData type=\"LicenseAcquisition\"&gt;&lt;LicenseAcquisition version=\"1.0\" Proactive=\"false\"&gt;&lt;CustomData encoding=\"base64encoded\"&gt;%CUSTOMDATA%&lt;/CustomData&gt;&lt;/LicenseAcquisition&gt;&lt;/PlayReadyCDMData&gt;'; let protData; function KeySystemPlayReady(config) { config = config || {}; let instance; let messageFormat = 'utf-16'; const BASE64 = config.BASE64; function checkConfig() { if (!BASE64 || !BASE64.hasOwnProperty('decodeArray') || !BASE64.hasOwnProperty('decodeArray') ) { throw new Error('Missing config parameter(s)'); } } function getRequestHeadersFromMessage(message) { let msg, xmlDoc; const headers = {}; const parser = new DOMParser(); const dataview = (messageFormat === 'utf-16') ? new Uint16Array(message) : new Uint8Array(message); msg = String.fromCharCode.apply(null, dataview); xmlDoc = parser.parseFromString(msg, 'application/xml'); const headerNameList = xmlDoc.getElementsByTagName('name'); const headerValueList = xmlDoc.getElementsByTagName('value'); for (let i = 0; i &lt; headerNameList.length; i++) { headers[headerNameList[i].childNodes[0].nodeValue] = headerValueList[i].childNodes[0].nodeValue; } // Some versions of the PlayReady CDM return 'Content' instead of 'Content-Type'. // this is NOT w3c conform and license servers may reject the request! // -&gt; rename it to proper w3c definition! if (headers.hasOwnProperty('Content')) { headers['Content-Type'] = headers.Content; delete headers.Content; } // Set Content-Type header by default if not provided in the the CDM message (&lt;PlayReadyKeyMessage/&gt;) // or if the message contains directly the challenge itself (Ex: LG SmartTVs) if (!headers.hasOwnProperty('Content-Type')) { headers['Content-Type'] = 'text/xml; charset=utf-8'; } return headers; } function getLicenseRequestFromMessage(message) { let licenseRequest = null; const parser = new DOMParser(); const dataview = (messageFormat === 'utf-16') ? new Uint16Array(message) : new Uint8Array(message); checkConfig(); const msg = String.fromCharCode.apply(null, dataview); const xmlDoc = parser.parseFromString(msg, 'application/xml'); if (xmlDoc.getElementsByTagName('PlayReadyKeyMessage')[0]) { const Challenge = xmlDoc.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue; if (Challenge) { licenseRequest = BASE64.decode(Challenge); } } else { // The message from CDM is not a wrapped message as on IE11 and Edge, // thus it contains direclty the challenge itself // (note that the xmlDoc at this point may be unreadable since it may have been interpreted as UTF-16) return message; } return licenseRequest; } function getLicenseServerURLFromInitData(initData) { if (initData) { const data = new DataView(initData); const numRecords = data.getUint16(4, true); let offset = 6; const parser = new DOMParser(); for (let i = 0; i &lt; numRecords; i++) { // Parse the PlayReady Record header const recordType = data.getUint16(offset, true); offset += 2; const recordLength = data.getUint16(offset, true); offset += 2; if (recordType !== 0x0001) { offset += recordLength; continue; } const recordData = initData.slice(offset, offset + recordLength); const record = String.fromCharCode.apply(null, new Uint16Array(recordData)); const xmlDoc = parser.parseFromString(record, 'application/xml'); // First try &lt;LA_URL&gt; if (xmlDoc.getElementsByTagName('LA_URL')[0]) { const laurl = xmlDoc.getElementsByTagName('LA_URL')[0].childNodes[0].nodeValue; if (laurl) { return laurl; } } // Optionally, try &lt;LUI_URL&gt; if (xmlDoc.getElementsByTagName('LUI_URL')[0]) { const luiurl = xmlDoc.getElementsByTagName('LUI_URL')[0].childNodes[0].nodeValue; if (luiurl) { return luiurl; } } } } return null; } function getInitData(cpData) { // * desc@ getInitData // * generate PSSH data from PROHeader defined in MPD file // * PSSH format: // * size (4) // * box type(PSSH) (8) // * Protection SystemID (16) // * protection system data size (4) - length of decoded PROHeader // * decoded PROHeader data from MPD file const PSSHBoxType = new Uint8Array([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00]); //'PSSH' 8 bytes const playreadySystemID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]); let byteCursor = 0; let uint8arraydecodedPROHeader = null; let PROSize, PSSHSize, PSSHBoxBuffer, PSSHBox, PSSHData; checkConfig(); if (!cpData) { return null; } // Handle common encryption PSSH if ('pssh' in cpData) { return CommonEncryption.parseInitDataFromContentProtection(cpData, BASE64); } // Handle native MS PlayReady ContentProtection elements if ('pro' in cpData) { uint8arraydecodedPROHeader = BASE64.decodeArray(cpData.pro.__text); } else if ('prheader' in cpData) { uint8arraydecodedPROHeader = BASE64.decodeArray(cpData.prheader.__text); } else { return null; } PROSize = uint8arraydecodedPROHeader.length; PSSHSize = 0x4 + PSSHBoxType.length + playreadySystemID.length + 0x4 + PROSize; PSSHBoxBuffer = new ArrayBuffer(PSSHSize); PSSHBox = new Uint8Array(PSSHBoxBuffer); PSSHData = new DataView(PSSHBoxBuffer); PSSHData.setUint32(byteCursor, PSSHSize); byteCursor += 0x4; PSSHBox.set(PSSHBoxType, byteCursor); byteCursor += PSSHBoxType.length; PSSHBox.set(playreadySystemID, byteCursor); byteCursor += playreadySystemID.length; PSSHData.setUint32(byteCursor, PROSize); byteCursor += 0x4; PSSHBox.set(uint8arraydecodedPROHeader, byteCursor); byteCursor += PROSize; return PSSHBox.buffer; } /** * It seems that some PlayReady implementations return their XML-based CDM * messages using UTF16, while others return them as UTF8. Use this function * to modify the message format to expect when parsing CDM messages. * * @param {string} format the expected message format. Either \"utf-8\" or \"utf-16\". * @throws {Error} Specified message format is not one of \"utf8\" or \"utf16\" */ function setPlayReadyMessageFormat(format) { if (format !== 'utf-8' &amp;&amp; format !== 'utf-16') { throw new Error('Specified message format is not one of \"utf-8\" or \"utf-16\"'); } messageFormat = format; } /** * Initialize the Key system with protection data * @param {Object} protectionData the protection data */ function init(protectionData) { if (protectionData) { protData = protectionData; } } /** * Get Playready Custom data */ function getCDMData() { let customData, cdmData, cdmDataBytes, i; checkConfig(); if (protData &amp;&amp; protData.cdmData) { // Convert custom data into multibyte string customData = []; for (i = 0; i &lt; protData.cdmData.length; ++i) { customData.push(protData.cdmData.charCodeAt(i)); customData.push(0); } customData = String.fromCharCode.apply(null, customData); // Encode in Base 64 the custom data string customData = BASE64.encode(customData); // Initialize CDM data with Base 64 encoded custom data // (see https://msdn.microsoft.com/en-us/library/dn457361.aspx) cdmData = PRCDMData.replace('%CUSTOMDATA%', customData); // Convert CDM data into multibyte characters cdmDataBytes = []; for (i = 0; i &lt; cdmData.length; ++i) { cdmDataBytes.push(cdmData.charCodeAt(i)); cdmDataBytes.push(0); } return new Uint8Array(cdmDataBytes).buffer; } return null; } function getSessionId(cp) { // Get sessionId from protectionData or from manifest if (protData &amp;&amp; protData.sessionId) { return protData.sessionId; } else if (cp &amp;&amp; cp.sessionId) { return cp.sessionId; } return null; } instance = { uuid: uuid, schemeIdURI: schemeIdURI, systemString: systemString, getInitData: getInitData, getRequestHeadersFromMessage: getRequestHeadersFromMessage, getLicenseRequestFromMessage: getLicenseRequestFromMessage, getLicenseServerURLFromInitData: getLicenseServerURLFromInitData, getCDMData: getCDMData, getSessionId: getSessionId, setPlayReadyMessageFormat: setPlayReadyMessageFormat, init: init }; return instance; } KeySystemPlayReady.__dashjs_factory_name = 'KeySystemPlayReady'; export default dashjs.FactoryMaker.getSingletonFactory(KeySystemPlayReady); /* jshint ignore:line */ × Search results Close "},"streaming_protection_servers_LicenseServer.js.html":{"id":"streaming_protection_servers_LicenseServer.js.html","title":"Source: streaming/protection/servers/LicenseServer.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/servers/LicenseServer.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Defines the public interface for license server implementations supported * by the player. * * Different license servers have different requirements regarding the methods * used to request DRM licenses. Things like request headers, license response * formats (for both error and success cases) need to be customized for a * specific server implementation * * License servers handle requests for more than just initial license retrieval. * Each API takes a parameter which describes the message type as supported by * the Encrypted Media Extensions. * * @interface */ /** * Returns a new or updated license server URL based on the requirements of the * license server and possibly from information passed in the CDM license message * * @function * @name LicenseServer#getServerURLFromMessage * @param {?string} url the initially established URL (from ProtectionData or initData) * @param {ArrayBuffer} message the CDM message which may be needed to generate the license * requests URL * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {string} the URL to use in license requests */ /** * Returns the HTTP method to be used (i.e. \"GET\", \"POST\", etc.) in * XMLHttpRequest.open(). * * @function * @name LicenseServer#getHTTPMethod * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {string} the HTTP method */ /** * Returns the response type to set for XMLHttpRequest.responseType * * @function * @name LicenseServer#getResponseType * @param {string} keySystemStr the key system string representing the key system * associated with a license request. Multi-DRM license servers may have different * response types depending on the key system. * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {string} the response type */ /** * Parses the license server response for any message intended for * the CDM. * * @function * @name LicenseServer#getLicenseMessage * @param {Object} serverResponse the response as returned in XMLHttpRequest.response * @param {string} keySystemStr the key system string representing the key system * associated with a license request. * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {ArrayBuffer} message that will be sent to the CDM or null if no CDM message * was present in the response. */ /** * Parses the license server response during error conditions and returns a * string to display for debugging purposes * * @function * @name LicenseServer#getErrorResponse * @param {Object} serverResponse the server response * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {string} an error message that indicates the reason for the failure */ × Search results Close "},"core_Logger.js.html":{"id":"core_Logger.js.html","title":"Source: core/Logger.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: core/Logger.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * The an end place to put fragments after they have been fetched. * @interface Logger * @ignore */ /** * This method allows you to send fatal error messages (fatal errors implies playback interruption) to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#fatal */ /** * This method allows you to send error messages to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#error */ /** * This method allows you to send warning messages to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#warning */ /** * This method allows you to send info messages to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#info */ /** * This method allows you to send debug messages to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#debug */ × Search results Close "},"streaming_vo_metrics_ManifestUpdate.js.html":{"id":"streaming_vo_metrics_ManifestUpdate.js.html","title":"Source: streaming/vo/metrics/ManifestUpdate.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/ManifestUpdate.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc This Object holds reference to the manifest update information. * @ignore */ class ManifestUpdate { /** * @class */ constructor() { /** * Media Type Video | Audio | FragmentedText * @public */ this.mediaType = null; /** * MPD Type static | dynamic * @public */ this.type = null; /** * When this manifest update was requested * @public */ this.requestTime = null; /** * When this manifest update was received * @public */ this.fetchTime = null; /** * Calculated Availability Start time of the stream. * @public */ this.availabilityStartTime = null; /** * the seek point (liveEdge for dynamic, Stream[0].startTime for static) * @public */ this.presentationStartTime = 0; /** * The calculated difference between the server and client wall clock time * @public */ this.clientTimeOffset = 0; /** * Actual element.currentTime * @public */ this.currentTime = null; /** * Actual element.ranges * @public */ this.buffered = null; /** * Static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - elementCurrentTime) * @public */ this.latency = 0; /** * Array holding list of StreamInfo VO Objects * @public */ this.streamInfo = []; /** * Array holding list of RepresentationInfo VO Objects * @public */ this.representationInfo = []; } } /** * @classdesc This Object holds reference to the current period's stream information when the manifest was updated. * @ignore */ class ManifestUpdateStreamInfo { /** * @class */ constructor() { /** * Stream@id * @public */ this.id = null; /** * Period Index * @public */ this.index = null; /** * Stream@start * @public */ this.start = null; /** * Stream@duration * @public */ this.duration = null; } } /** * @classdesc This Object holds reference to the current representation's info when the manifest was updated. * @ignore */ class ManifestUpdateRepresentationInfo { /** * @class */ constructor() { /** * Track@id * @public */ this.id = null; /** * Representation Index * @public */ this.index = null; /** * Media Type Video | Audio | FragmentedText * @public */ this.mediaType = null; /** * Which representation * @public */ this.streamIndex = null; /** * Holds reference to @presentationTimeOffset * @public */ this.presentationTimeOffset = null; /** * Holds reference to @startNumber * @public */ this.startNumber = null; /** * list|template|timeline * @public */ this.fragmentInfoType = null; } } export { ManifestUpdate, ManifestUpdateStreamInfo, ManifestUpdateRepresentationInfo }; × Search results Close "},"streaming_controllers_MediaController.js.html":{"id":"streaming_controllers_MediaController.js.html","title":"Source: streaming/controllers/MediaController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/controllers/MediaController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import Events from '../../core/events/Events'; import EventBus from '../../core/EventBus'; import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; const TRACK_SWITCH_MODE_NEVER_REPLACE = 'neverReplace'; const TRACK_SWITCH_MODE_ALWAYS_REPLACE = 'alwaysReplace'; const TRACK_SELECTION_MODE_HIGHEST_BITRATE = 'highestBitrate'; const TRACK_SELECTION_MODE_WIDEST_RANGE = 'widestRange'; const DEFAULT_INIT_TRACK_SELECTION_MODE = TRACK_SELECTION_MODE_HIGHEST_BITRATE; function MediaController() { const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, tracks, initialSettings, selectionMode, switchMode, domStorage; const validTrackSwitchModes = [ TRACK_SWITCH_MODE_ALWAYS_REPLACE, TRACK_SWITCH_MODE_NEVER_REPLACE ]; const validTrackSelectionModes = [ TRACK_SELECTION_MODE_HIGHEST_BITRATE, TRACK_SELECTION_MODE_WIDEST_RANGE ]; function setup() { logger = Debug(context).getInstance().getLogger(instance); reset(); } /** * @param {string} type * @param {StreamInfo} streamInfo * @memberof MediaController# */ function checkInitialMediaSettingsForType(type, streamInfo) { let settings = getInitialSettings(type); const tracksForType = getTracksFor(type, streamInfo); const tracks = []; if (!settings) { settings = domStorage.getSavedMediaSettings(type); setInitialSettings(type, settings); } if (!tracksForType || (tracksForType.length === 0)) return; if (settings) { tracksForType.forEach(function (track) { if (matchSettings(settings, track)) { tracks.push(track); } }); } if (tracks.length === 0) { setTrack(selectInitialTrack(type, tracksForType), true); } else { if (tracks.length &gt; 1) { setTrack(selectInitialTrack(type, tracks)); } else { setTrack(tracks[0]); } } } /** * @param {MediaInfo} track * @memberof MediaController# */ function addTrack(track) { if (!track) return; const mediaType = track.type; if (!isMultiTrackSupportedByType(mediaType)) return; let streamId = track.streamInfo.id; if (!tracks[streamId]) { tracks[streamId] = createTrackInfo(); } const mediaTracks = tracks[streamId][mediaType].list; for (let i = 0, len = mediaTracks.length; i &lt; len; ++i) { //track is already set. if (isTracksEqual(mediaTracks[i], track)) { return; } } mediaTracks.push(track); let initSettings = getInitialSettings(mediaType); if (initSettings &amp;&amp; (matchSettings(initSettings, track)) &amp;&amp; !getCurrentTrackFor(mediaType, track.streamInfo)) { setTrack(track); } } /** * @param {string} type * @param {StreamInfo} streamInfo * @returns {Array} * @memberof MediaController# */ function getTracksFor(type, streamInfo) { if (!type || !streamInfo) return []; const id = streamInfo.id; if (!tracks[id] || !tracks[id][type]) return []; return tracks[id][type].list; } /** * @param {string} type * @param {StreamInfo} streamInfo * @returns {Object|null} * @memberof MediaController# */ function getCurrentTrackFor(type, streamInfo) { if (!type || !streamInfo || (streamInfo &amp;&amp; !tracks[streamInfo.id])) return null; return tracks[streamInfo.id][type].current; } /** * @param {MediaInfo} track * @returns {boolean} * @memberof MediaController# */ function isCurrentTrack(track) { if (!track) { return false; } const type = track.type; const id = track.streamInfo.id; return (tracks[id] &amp;&amp; tracks[id][type] &amp;&amp; isTracksEqual(tracks[id][type].current, track)); } /** * @param {MediaInfo} track * @param {boolean} noSettingsSave specify if settings must be not be saved * @memberof MediaController# */ function setTrack(track, noSettingsSave) { if (!track || !track.streamInfo) return; const type = track.type; const streamInfo = track.streamInfo; const id = streamInfo.id; const current = getCurrentTrackFor(type, streamInfo); if (!tracks[id] || !tracks[id][type] || isTracksEqual(track, current)) return; tracks[id][type].current = track; if (tracks[id][type].current &amp;&amp; !(noSettingsSave &amp;&amp; type === Constants.FRAGMENTED_TEXT)) { eventBus.trigger(Events.CURRENT_TRACK_CHANGED, {oldMediaInfo: current, newMediaInfo: track, switchMode: switchMode[type]}); } if (!noSettingsSave) { let settings = extractSettings(track); if (!settings || !tracks[id][type].storeLastSettings) return; if (settings.roles) { settings.role = settings.roles[0]; delete settings.roles; } if (settings.accessibility) { settings.accessibility = settings.accessibility[0]; } if (settings.audioChannelConfiguration) { settings.audioChannelConfiguration = settings.audioChannelConfiguration[0]; } domStorage.setSavedMediaSettings(type, settings); } } /** * @param {string} type * @param {Object} value * @memberof MediaController# */ function setInitialSettings(type, value) { if (!type || !value) return; initialSettings[type] = value; } /** * @param {string} type * @returns {Object|null} * @memberof MediaController# */ function getInitialSettings(type) { if (!type) return null; return initialSettings[type]; } /** * @memberof MediaController# */ function saveTextSettingsDisabled() { domStorage.setSavedMediaSettings(Constants.FRAGMENTED_TEXT, null); } /** * @param {string} type * @param {string} mode * @memberof MediaController# */ function setSwitchMode(type, mode) { const isModeSupported = (validTrackSwitchModes.indexOf(mode) !== -1); if (!isModeSupported) { logger.warn('Track switch mode is not supported: ' + mode); return; } switchMode[type] = mode; } /** * @param {string} type * @returns {string} mode * @memberof MediaController# */ function getSwitchMode(type) { return switchMode[type]; } /** * @param {string} mode * @memberof MediaController# */ function setSelectionModeForInitialTrack(mode) { const isModeSupported = (validTrackSelectionModes.indexOf(mode) !== -1); if (!isModeSupported) { logger.warn('Track selection mode is not supported: ' + mode); return; } selectionMode = mode; } /** * @returns {string} mode * @memberof MediaController# */ function getSelectionModeForInitialTrack() { return selectionMode || DEFAULT_INIT_TRACK_SELECTION_MODE; } /** * @param {string} type * @returns {boolean} * @memberof MediaController# */ function isMultiTrackSupportedByType(type) { return (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.IMAGE); } /** * @param {MediaInfo} t1 - first track to compare * @param {MediaInfo} t2 - second track to compare * @returns {boolean} * @memberof MediaController# */ function isTracksEqual(t1, t2) { if (!t1 &amp;&amp; !t2) { return true; } if (!t1 || !t2) { return false; } const sameId = t1.id === t2.id; const sameViewpoint = t1.viewpoint === t2.viewpoint; const sameLang = t1.lang === t2.lang; const sameRoles = t1.roles.toString() === t2.roles.toString(); const sameAccessibility = t1.accessibility.toString() === t2.accessibility.toString(); const sameAudioChannelConfiguration = t1.audioChannelConfiguration.toString() === t2.audioChannelConfiguration.toString(); return (sameId &amp;&amp; sameViewpoint &amp;&amp; sameLang &amp;&amp; sameRoles &amp;&amp; sameAccessibility &amp;&amp; sameAudioChannelConfiguration); } function setConfig(config) { if (!config) return; if (config.domStorage) { domStorage = config.domStorage; } } /** * @memberof MediaController# */ function reset() { tracks = {}; resetInitialSettings(); resetSwitchMode(); } function extractSettings(mediaInfo) { const settings = { lang: mediaInfo.lang, viewpoint: mediaInfo.viewpoint, roles: mediaInfo.roles, accessibility: mediaInfo.accessibility, audioChannelConfiguration: mediaInfo.audioChannelConfiguration }; let notEmpty = settings.lang || settings.viewpoint || (settings.role &amp;&amp; settings.role.length &gt; 0) || (settings.accessibility &amp;&amp; settings.accessibility.length &gt; 0) || (settings.audioChannelConfiguration &amp;&amp; settings.audioChannelConfiguration.length &gt; 0); return notEmpty ? settings : null; } function matchSettings(settings, track) { const matchLang = !settings.lang || (track.lang.match(settings.lang)); const matchViewPoint = !settings.viewpoint || (settings.viewpoint === track.viewpoint); const matchRole = !settings.role || !!track.roles.filter(function (item) { return item === settings.role; })[0]; let matchAccessibility = !settings.accessibility || !!track.accessibility.filter(function (item) { return item === settings.accessibility; })[0]; let matchAudioChannelConfiguration = !settings.audioChannelConfiguration || !!track.audioChannelConfiguration.filter(function (item) { return item === settings.audioChannelConfiguration; })[0]; return (matchLang &amp;&amp; matchViewPoint &amp;&amp; matchRole &amp;&amp; matchAccessibility &amp;&amp; matchAudioChannelConfiguration); } function resetSwitchMode() { switchMode = { audio: TRACK_SWITCH_MODE_ALWAYS_REPLACE, video: TRACK_SWITCH_MODE_NEVER_REPLACE }; } function resetInitialSettings() { initialSettings = { audio: null, video: null, fragmentedText: null }; } function selectInitialTrack(type, tracks) { if (type === Constants.FRAGMENTED_TEXT) return tracks[0]; let mode = getSelectionModeForInitialTrack(); let tmpArr = []; const getTracksWithHighestBitrate = function (trackArr) { let max = 0; let result = []; let tmp; trackArr.forEach(function (track) { tmp = Math.max.apply(Math, track.bitrateList.map(function (obj) { return obj.bandwidth; })); if (tmp &gt; max) { max = tmp; result = [track]; } else if (tmp === max) { result.push(track); } }); return result; }; const getTracksWithWidestRange = function (trackArr) { let max = 0; let result = []; let tmp; trackArr.forEach(function (track) { tmp = track.representationCount; if (tmp &gt; max) { max = tmp; result = [track]; } else if (tmp === max) { result.push(track); } }); return result; }; switch (mode) { case TRACK_SELECTION_MODE_HIGHEST_BITRATE: tmpArr = getTracksWithHighestBitrate(tracks); if (tmpArr.length &gt; 1) { tmpArr = getTracksWithWidestRange(tmpArr); } break; case TRACK_SELECTION_MODE_WIDEST_RANGE: tmpArr = getTracksWithWidestRange(tracks); if (tmpArr.length &gt; 1) { tmpArr = getTracksWithHighestBitrate(tracks); } break; default: logger.warn('Track selection mode is not supported: ' + mode); break; } return tmpArr[0]; } function createTrackInfo() { return { audio: { list: [], storeLastSettings: true, current: null }, video: { list: [], storeLastSettings: true, current: null }, text: { list: [], storeLastSettings: true, current: null }, fragmentedText: { list: [], storeLastSettings: true, current: null }, image: { list: [], storeLastSettings: true, current: null } }; } instance = { checkInitialMediaSettingsForType: checkInitialMediaSettingsForType, addTrack: addTrack, getTracksFor: getTracksFor, getCurrentTrackFor: getCurrentTrackFor, isCurrentTrack: isCurrentTrack, setTrack: setTrack, setInitialSettings: setInitialSettings, getInitialSettings: getInitialSettings, setSwitchMode: setSwitchMode, getSwitchMode: getSwitchMode, setSelectionModeForInitialTrack: setSelectionModeForInitialTrack, getSelectionModeForInitialTrack: getSelectionModeForInitialTrack, isMultiTrackSupportedByType: isMultiTrackSupportedByType, isTracksEqual: isTracksEqual, matchSettings: matchSettings, saveTextSettingsDisabled: saveTextSettingsDisabled, setConfig: setConfig, reset: reset }; setup(); return instance; } MediaController.__dashjs_factory_name = 'MediaController'; const factory = FactoryMaker.getSingletonFactory(MediaController); factory.TRACK_SWITCH_MODE_NEVER_REPLACE = TRACK_SWITCH_MODE_NEVER_REPLACE; factory.TRACK_SWITCH_MODE_ALWAYS_REPLACE = TRACK_SWITCH_MODE_ALWAYS_REPLACE; factory.TRACK_SELECTION_MODE_HIGHEST_BITRATE = TRACK_SELECTION_MODE_HIGHEST_BITRATE; factory.TRACK_SELECTION_MODE_WIDEST_RANGE = TRACK_SELECTION_MODE_WIDEST_RANGE; factory.DEFAULT_INIT_TRACK_SELECTION_MODE = DEFAULT_INIT_TRACK_SELECTION_MODE; FactoryMaker.updateSingletonFactory(MediaController.__dashjs_factory_name, factory); export default factory; × Search results Close "},"streaming_MediaPlayerEvents.js.html":{"id":"streaming_MediaPlayerEvents.js.html","title":"Source: streaming/MediaPlayerEvents.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/MediaPlayerEvents.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import EventsBase from '../core/events/EventsBase'; /** * @class * @implements EventsBase */ class MediaPlayerEvents extends EventsBase { /** * @description Public facing external events to be used when developing a player that implements dash.js. */ constructor() { super(); /** * Triggered when playback will not start yet * as the MPD's availabilityStartTime is in the future. * Check delay property in payload to determine time before playback will start. * @event MediaPlayerEvents#AST_IN_FUTURE */ this.AST_IN_FUTURE = 'astInFuture'; /** * Triggered when the video element's buffer state changes to stalled. * Check mediaType in payload to determine type (Video, Audio, FragmentedText). * @event MediaPlayerEvents#BUFFER_EMPTY */ this.BUFFER_EMPTY = 'bufferStalled'; /** * Triggered when the video element's buffer state changes to loaded. * Check mediaType in payload to determine type (Video, Audio, FragmentedText). * @event MediaPlayerEvents#BUFFER_LOADED */ this.BUFFER_LOADED = 'bufferLoaded'; /** * Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. * @event MediaPlayerEvents#BUFFER_LEVEL_STATE_CHANGED */ this.BUFFER_LEVEL_STATE_CHANGED = 'bufferStateChanged'; /** * Triggered when there is an error from the element or MSE source buffer. * @event MediaPlayerEvents#ERROR */ this.ERROR = 'error'; /** * Triggered when a fragment download has completed. * @event MediaPlayerEvents#FRAGMENT_LOADING_COMPLETED */ this.FRAGMENT_LOADING_COMPLETED = 'fragmentLoadingCompleted'; /** * Triggered when a partial fragment download has completed. * @event MediaPlayerEvents#FRAGMENT_LOADING_PROGRESS */ this.FRAGMENT_LOADING_PROGRESS = 'fragmentLoadingProgress'; /** * Triggered when a fragment download has started. * @event MediaPlayerEvents#FRAGMENT_LOADING_STARTED */ this.FRAGMENT_LOADING_STARTED = 'fragmentLoadingStarted'; /** * Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. * @event MediaPlayerEvents#FRAGMENT_LOADING_ABANDONED */ this.FRAGMENT_LOADING_ABANDONED = 'fragmentLoadingAbandoned'; /** * Triggered when {@link module:Debug} logger methods are called. * @event MediaPlayerEvents#LOG */ this.LOG = 'log'; //TODO refactor with internal event /** * Triggered when the manifest load is complete * @event MediaPlayerEvents#MANIFEST_LOADED */ this.MANIFEST_LOADED = 'manifestLoaded'; /** * Triggered anytime there is a change to the overall metrics. * @event MediaPlayerEvents#METRICS_CHANGED */ this.METRICS_CHANGED = 'metricsChanged'; /** * Triggered when an individual metric is added, updated or cleared. * @event MediaPlayerEvents#METRIC_CHANGED */ this.METRIC_CHANGED = 'metricChanged'; /** * Triggered every time a new metric is added. * @event MediaPlayerEvents#METRIC_ADDED */ this.METRIC_ADDED = 'metricAdded'; /** * Triggered every time a metric is updated. * @event MediaPlayerEvents#METRIC_UPDATED */ this.METRIC_UPDATED = 'metricUpdated'; /** * Triggered at the stream end of a period. * @event MediaPlayerEvents#PERIOD_SWITCH_COMPLETED */ this.PERIOD_SWITCH_COMPLETED = 'periodSwitchCompleted'; /** * Triggered when a new period starts. * @event MediaPlayerEvents#PERIOD_SWITCH_STARTED */ this.PERIOD_SWITCH_STARTED = 'periodSwitchStarted'; /** * Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. * @event MediaPlayerEvents#QUALITY_CHANGE_REQUESTED */ this.QUALITY_CHANGE_REQUESTED = 'qualityChangeRequested'; /** * Triggered when the new ABR quality is being rendered on-screen. * @event MediaPlayerEvents#QUALITY_CHANGE_RENDERED */ this.QUALITY_CHANGE_RENDERED = 'qualityChangeRendered'; /** * Triggered when the new track is being rendered. * @event MediaPlayerEvents#TRACK_CHANGE_RENDERED */ this.TRACK_CHANGE_RENDERED = 'trackChangeRendered'; /** * Triggered when the source is setup and ready. * @event MediaPlayerEvents#SOURCE_INITIALIZED */ this.SOURCE_INITIALIZED = 'sourceInitialized'; /** * Triggered when a stream (period) is being loaded * @event MediaPlayerEvents#STREAM_INITIALIZING */ this.STREAM_INITIALIZING = 'streamInitializing'; /** * Triggered when a stream (period) is loaded * @event MediaPlayerEvents#STREAM_UPDATED */ this.STREAM_UPDATED = 'streamUpdated'; /** * Triggered when a stream (period) is updated * @event MediaPlayerEvents#STREAM_INITIALIZED */ this.STREAM_INITIALIZED = 'streamInitialized'; /** * Triggered when the player has been reset. * @event MediaPlayerEvents#STREAM_TEARDOWN_COMPLETE */ this.STREAM_TEARDOWN_COMPLETE = 'streamTeardownComplete'; /** * Triggered once all text tracks detected in the MPD are added to the video element. * @event MediaPlayerEvents#TEXT_TRACKS_ADDED */ this.TEXT_TRACKS_ADDED = 'allTextTracksAdded'; /** * Triggered when a text track is added to the video element's TextTrackList * @event MediaPlayerEvents#TEXT_TRACK_ADDED */ this.TEXT_TRACK_ADDED = 'textTrackAdded'; /** * Triggered when a ttml chunk is parsed. * @event MediaPlayerEvents#TTML_PARSED */ this.TTML_PARSED = 'ttmlParsed'; /** * Triggered when a ttml chunk has to be parsed. * @event MediaPlayerEvents#TTML_TO_PARSE */ this.TTML_TO_PARSE = 'ttmlToParse'; /** * Triggered when a caption is rendered. * @event MediaPlayerEvents#CAPTION_RENDERED */ this.CAPTION_RENDERED = 'captionRendered'; /** * Triggered when the caption container is resized. * @event MediaPlayerEvents#CAPTION_CONTAINER_RESIZE */ this.CAPTION_CONTAINER_RESIZE = 'captionContainerResize'; /** * Sent when enough data is available that the media can be played, * at least for a couple of frames. This corresponds to the * HAVE_ENOUGH_DATA readyState. * @event MediaPlayerEvents#CAN_PLAY */ this.CAN_PLAY = 'canPlay'; /** * Sent when playback completes. * @event MediaPlayerEvents#PLAYBACK_ENDED */ this.PLAYBACK_ENDED = 'playbackEnded'; /** * Sent when an error occurs. The element's error * attribute contains more information. * @event MediaPlayerEvents#PLAYBACK_ERROR */ this.PLAYBACK_ERROR = 'playbackError'; /** * Sent when playback is not allowed (for example if user gesture is needed). * @event MediaPlayerEvents#PLAYBACK_NOT_ALLOWED */ this.PLAYBACK_NOT_ALLOWED = 'playbackNotAllowed'; /** * The media's metadata has finished loading; all attributes now * contain as much useful information as they're going to. * @event MediaPlayerEvents#PLAYBACK_METADATA_LOADED */ this.PLAYBACK_METADATA_LOADED = 'playbackMetaDataLoaded'; /** * Sent when playback is paused. * @event MediaPlayerEvents#PLAYBACK_PAUSED */ this.PLAYBACK_PAUSED = 'playbackPaused'; /** * Sent when the media begins to play (either for the first time, after having been paused, * or after ending and then restarting). * * @event MediaPlayerEvents#PLAYBACK_PLAYING */ this.PLAYBACK_PLAYING = 'playbackPlaying'; /** * Sent periodically to inform interested parties of progress downloading * the media. Information about the current amount of the media that has * been downloaded is available in the media element's buffered attribute. * @event MediaPlayerEvents#PLAYBACK_PROGRESS */ this.PLAYBACK_PROGRESS = 'playbackProgress'; /** * Sent when the playback speed changes. * @event MediaPlayerEvents#PLAYBACK_RATE_CHANGED */ this.PLAYBACK_RATE_CHANGED = 'playbackRateChanged'; /** * Sent when a seek operation completes. * @event MediaPlayerEvents#PLAYBACK_SEEKED */ this.PLAYBACK_SEEKED = 'playbackSeeked'; /** * Sent when a seek operation begins. * @event MediaPlayerEvents#PLAYBACK_SEEKING */ this.PLAYBACK_SEEKING = 'playbackSeeking'; /** * Sent when a seek operation has been asked. * @event MediaPlayerEvents#PLAYBACK_SEEK_ASKED */ this.PLAYBACK_SEEK_ASKED = 'playbackSeekAsked'; /** * Sent when the video element reports stalled * @event MediaPlayerEvents#PLAYBACK_STALLED */ this.PLAYBACK_STALLED = 'playbackStalled'; /** * Sent when playback of the media starts after having been paused; * that is, when playback is resumed after a prior pause event. * * @event MediaPlayerEvents#PLAYBACK_STARTED */ this.PLAYBACK_STARTED = 'playbackStarted'; /** * The time indicated by the element's currentTime attribute has changed. * @event MediaPlayerEvents#PLAYBACK_TIME_UPDATED */ this.PLAYBACK_TIME_UPDATED = 'playbackTimeUpdated'; /** * Sent when the media playback has stopped because of a temporary lack of data. * * @event MediaPlayerEvents#PLAYBACK_WAITING */ this.PLAYBACK_WAITING = 'playbackWaiting'; /** * Manifest validity changed - As a result of an MPD validity expiration event. * @event MediaPlayerEvents#MANIFEST_VALIDITY_CHANGED */ this.MANIFEST_VALIDITY_CHANGED = 'manifestValidityChanged'; /** * A gap occured in the timeline which requires a seek to the next period * @event MediaPlayerEvents#GAP_CAUSED_SEEK_TO_PERIOD_END */ this.GAP_CAUSED_SEEK_TO_PERIOD_END = 'gapCausedSeekToPeriodEnd'; } } let mediaPlayerEvents = new MediaPlayerEvents(); export default mediaPlayerEvents; × Search results Close "},"streaming_MediaPlayerFactory.js.html":{"id":"streaming_MediaPlayerFactory.js.html","title":"Source: streaming/MediaPlayerFactory.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/MediaPlayerFactory.js import MediaPlayer from './MediaPlayer'; function MediaPlayerFactory() { /** * mime-type identifier for any source content to be accepted as a dash manifest by the create() method. * @type {string} */ const SUPPORTED_MIME_TYPE = 'application/dash+xml'; let logger; /** * A new MediaPlayer is instantiated for the supplied videoElement and optional source and context. If no context is provided, * a default DashContext is used. If no source is provided, the videoElement is interrogated to extract the first source whose * type is application/dash+xml. * The autoplay property of the videoElement is preserved. Any preload attribute is ignored. This method should be called after the page onLoad event is dispatched. * @param {HTMLMediaElement} video * @param {HTMLSourceElement} source * @param {Object} context * @returns {MediaPlayer|null} */ function create(video, source, context) { if (!video || !(/^VIDEO$/i).test(video.nodeName)) return null; if (video._dashjs_player) return video._dashjs_player; let player; let videoID = (video.id || video.name || 'video element'); source = source || [].slice.call(video.querySelectorAll('source')).filter(function (s) { return s.type == SUPPORTED_MIME_TYPE; })[0]; if (!source &amp;&amp; video.src) { source = document.createElement('source'); source.src = video.src; } else if (!source &amp;&amp; !video.src) { return null; } context = context || {}; player = MediaPlayer(context).create(); player.initialize(video, source.src, video.autoplay); if (!logger) { logger = player.getDebug().getLogger(); } logger.debug('Converted ' + videoID + ' to dash.js player and added content: ' + source.src); // Store a reference to the player on the video element so it can be gotten at for debugging and so we know its // already been setup. video._dashjs_player = player; return player; } /** * Searches the provided scope for all instances of the indicated selector. If no scope is provided, document is used. If no selector is * specified, [data-dashjs-player] is used. The declarative setup also looks for source elements with the type attribute set to 'application/dash+xml'. * It then looks for those video elements which have a source element defined with a type matching 'application/dash+xml'. * A new MediaPlayer is instantiated for each matching video element and the appropriate source is assigned. * The autoplay property of the video element is preserved. Any preload attribute is ignored. This method should be called after the page onLoad event is dispatched. * Returns an array holding all the MediaPlayer instances that were added by this method. * @param {string} selector - CSS selector * @param {Object} scope * @returns {Array} an array of MediaPlayer objects */ function createAll(selector, scope) { let aPlayers = []; selector = selector || '[data-dashjs-player]'; scope = scope || document; let videos = scope.querySelectorAll(selector); for (let i = 0; i &lt; videos.length; i++) { let player = create(videos[i], null); aPlayers.push(player); } let sources = scope.querySelectorAll('source[type=\"' + SUPPORTED_MIME_TYPE + '\"]'); for (let i = 0; i &lt; sources.length; i++) { let video = findVideo(sources[i]); let player = create(video, null); aPlayers.push(player); } return aPlayers; } function findVideo(el) { if ((/^VIDEO$/i).test(el.nodeName)) { return el; } else { return findVideo(el.parentNode); } } return { create: create, createAll: createAll }; } let instance = MediaPlayerFactory(); let loadInterval; function loadHandler() { window.removeEventListener('load', loadHandler); instance.createAll(); } function loadIntervalHandler() { if (window.dashjs) { window.clearInterval(loadInterval); instance.createAll(); } } let avoidAutoCreate = typeof window !== 'undefined' &amp;&amp; window &amp;&amp; window.dashjs &amp;&amp; window.dashjs.skipAutoCreate; if (!avoidAutoCreate &amp;&amp; typeof window !== 'undefined' &amp;&amp; window &amp;&amp; window.addEventListener) { if (window.document.readyState === 'complete') { if (window.dashjs) { instance.createAll(); } else { // If loaded asynchronously, window.readyState may be 'complete' even if dashjs hasn't loaded yet loadInterval = window.setInterval(loadIntervalHandler, 500); } } else { window.addEventListener('load', loadHandler); } } export default instance; × Search results Close "},"streaming_MediaPlayer.js.html":{"id":"streaming_MediaPlayer.js.html","title":"Source: streaming/MediaPlayer.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/MediaPlayer.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import cea608parser from '../../externals/cea608-parser'; import Constants from './constants/Constants'; import DashConstants from '../dash/constants/DashConstants'; import MetricsConstants from './constants/MetricsConstants'; import PlaybackController from './controllers/PlaybackController'; import StreamController from './controllers/StreamController'; import GapController from './controllers/GapController'; import MediaController from './controllers/MediaController'; import BaseURLController from './controllers/BaseURLController'; import ManifestLoader from './ManifestLoader'; import ErrorHandler from './utils/ErrorHandler'; import Capabilities from './utils/Capabilities'; import TextTracks from './text/TextTracks'; import RequestModifier from './utils/RequestModifier'; import TextController from './text/TextController'; import URIFragmentModel from './models/URIFragmentModel'; import ManifestModel from './models/ManifestModel'; import MediaPlayerModel from './models/MediaPlayerModel'; import AbrController from './controllers/AbrController'; import SchemeLoaderFactory from './net/SchemeLoaderFactory'; import VideoModel from './models/VideoModel'; import CmcdModel from './models/CmcdModel'; import DOMStorage from './utils/DOMStorage'; import Debug from './../core/Debug'; import Errors from './../core/errors/Errors'; import EventBus from './../core/EventBus'; import Events from './../core/events/Events'; import MediaPlayerEvents from './MediaPlayerEvents'; import FactoryMaker from '../core/FactoryMaker'; import Settings from '../core/Settings'; import { getVersionString } from './../core/Version'; //Dash import SegmentBaseController from '../dash/controllers/SegmentBaseController'; import DashAdapter from '../dash/DashAdapter'; import DashMetrics from '../dash/DashMetrics'; import TimelineConverter from '../dash/utils/TimelineConverter'; import { HTTPRequest } from './vo/metrics/HTTPRequest'; import BASE64 from '../../externals/base64'; import ISOBoxer from 'codem-isoboxer'; import DashJSError from './vo/DashJSError'; import { checkParameterType } from './utils/SupervisorTools'; import ManifestUpdater from './ManifestUpdater'; import URLUtils from '../streaming/utils/URLUtils'; import BoxParser from './utils/BoxParser'; /* jscs:disable */ /** * The media types * @typedef {(\"video\" | \"audio\" | \"text\" | \"fragmentedText\" | \"embeddedText\" | \"image\")} MediaType */ /* jscs:enable */ /** * @module MediaPlayer * @description The MediaPlayer is the primary dash.js Module and a Facade to build your player around. * It will allow you access to all the important dash.js properties/methods via the public API and all the * events to build a robust DASH media player. */ function MediaPlayer() { /** * @constant {string} STREAMING_NOT_INITIALIZED_ERROR error string thrown when a function is called before the dash.js has been fully initialized * @inner */ const STREAMING_NOT_INITIALIZED_ERROR = 'You must first call initialize() and set a source before calling this method'; /** * @constant {string} PLAYBACK_NOT_INITIALIZED_ERROR error string thrown when a function is called before the dash.js has been fully initialized * @inner */ const PLAYBACK_NOT_INITIALIZED_ERROR = 'You must first call initialize() and set a valid source and view before calling this method'; /** * @constant {string} ELEMENT_NOT_ATTACHED_ERROR error string thrown when a function is called before the dash.js has received a reference of an HTML5 video element * @inner */ const ELEMENT_NOT_ATTACHED_ERROR = 'You must first call attachView() to set the video element before calling this method'; /** * @constant {string} SOURCE_NOT_ATTACHED_ERROR error string thrown when a function is called before the dash.js has received a valid source stream. * @inner */ const SOURCE_NOT_ATTACHED_ERROR = 'You must first call attachSource() with a valid source before calling this method'; /** * @constant {string} MEDIA_PLAYER_NOT_INITIALIZED_ERROR error string thrown when a function is called before the dash.js has been fully initialized. * @inner */ const MEDIA_PLAYER_NOT_INITIALIZED_ERROR = 'MediaPlayer not initialized!'; const context = this.context; const eventBus = EventBus(context).getInstance(); let settings = Settings(context).getInstance(); const debug = Debug(context).getInstance({settings: settings}); let instance, logger, source, protectionData, mediaPlayerInitialized, streamingInitialized, playbackInitialized, autoPlay, abrController, schemeLoaderFactory, timelineConverter, mediaController, protectionController, metricsReportingController, mssHandler, offlineController, adapter, mediaPlayerModel, errHandler, baseURLController, capabilities, streamController, gapController, playbackController, dashMetrics, manifestModel, cmcdModel, videoModel, textController, uriFragmentModel, domStorage, segmentBaseController; /* --------------------------------------------------------------------------- INIT FUNCTIONS --------------------------------------------------------------------------- */ function setup() { logger = debug.getLogger(instance); mediaPlayerInitialized = false; playbackInitialized = false; streamingInitialized = false; autoPlay = true; protectionController = null; offlineController = null; protectionData = null; adapter = null; segmentBaseController = null; Events.extend(MediaPlayerEvents); mediaPlayerModel = MediaPlayerModel(context).getInstance(); videoModel = VideoModel(context).getInstance(); uriFragmentModel = URIFragmentModel(context).getInstance(); } /** * Configure media player with customs controllers. Helpful for tests * * @param {object=} config controllers configuration * @memberof module:MediaPlayer * @instance */ function setConfig(config) { if (!config) { return; } if (config.capabilities) { capabilities = config.capabilities; } if (config.streamController) { streamController = config.streamController; } if (config.gapController) { gapController = config.gapController; } if (config.playbackController) { playbackController = config.playbackController; } if (config.mediaPlayerModel) { mediaPlayerModel = config.mediaPlayerModel; } if (config.abrController) { abrController = config.abrController; } if (config.schemeLoaderFactory) { schemeLoaderFactory = config.schemeLoaderFactory; } if (config.mediaController) { mediaController = config.mediaController; } if (config.settings) { settings = config.settings; } } /** * Upon creating the MediaPlayer you must call initialize before you call anything else. * There is one exception to this rule. It is crucial to call {@link module:MediaPlayer#extend extend()} * with all your extensions prior to calling initialize. * * ALL arguments are optional and there are individual methods to set each argument later on. * The args in this method are just for convenience and should only be used for a simple player setup. * * @param {HTML5MediaElement=} view - Optional arg to set the video element. {@link module:MediaPlayer#attachView attachView()} * @param {string=} source - Optional arg to set the media source. {@link module:MediaPlayer#attachSource attachSource()} * @param {boolean=} AutoPlay - Optional arg to set auto play. {@link module:MediaPlayer#setAutoPlay setAutoPlay()} * @see {@link module:MediaPlayer#attachView attachView()} * @see {@link module:MediaPlayer#attachSource attachSource()} * @see {@link module:MediaPlayer#setAutoPlay setAutoPlay()} * @memberof module:MediaPlayer * @instance */ function initialize(view, source, AutoPlay) { if (!capabilities) { capabilities = Capabilities(context).getInstance(); } errHandler = ErrorHandler(context).getInstance(); if (!capabilities.supportsMediaSource()) { errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIASOURCE_ERROR_CODE, Errors.CAPABILITY_MEDIASOURCE_ERROR_MESSAGE)); return; } if (mediaPlayerInitialized) return; mediaPlayerInitialized = true; // init some controllers and models timelineConverter = TimelineConverter(context).getInstance(); if (!abrController) { abrController = AbrController(context).getInstance(); abrController.setConfig({ settings: settings }); } if (!schemeLoaderFactory) { schemeLoaderFactory = SchemeLoaderFactory(context).getInstance(); } if (!playbackController) { playbackController = PlaybackController(context).getInstance(); } if (!mediaController) { mediaController = MediaController(context).getInstance(); } if (!streamController) { streamController = StreamController(context).getInstance(); } if (!gapController) { gapController = GapController(context).getInstance(); } adapter = DashAdapter(context).getInstance(); manifestModel = ManifestModel(context).getInstance(); cmcdModel = CmcdModel(context).getInstance(); dashMetrics = DashMetrics(context).getInstance({ settings: settings }); textController = TextController(context).getInstance(); domStorage = DOMStorage(context).getInstance({ settings: settings }); adapter.setConfig({ constants: Constants, cea608parser: cea608parser, errHandler: errHandler, BASE64: BASE64 }); if (!baseURLController) { baseURLController = BaseURLController(context).create(); } baseURLController.setConfig({ adapter: adapter }); segmentBaseController = SegmentBaseController(context).getInstance({ dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, errHandler: errHandler, baseURLController: baseURLController, events: Events, eventBus: eventBus, debug: debug, boxParser: BoxParser(context).getInstance(), requestModifier: RequestModifier(context).getInstance(), errors: Errors }); segmentBaseController.initialize(); restoreDefaultUTCTimingSources(); setAutoPlay(AutoPlay !== undefined ? AutoPlay : true); // Detect and initialize offline module to support offline contents playback detectOffline(); if (view) { attachView(view); } if (source) { attachSource(source); } logger.info('[dash.js ' + getVersion() + '] ' + 'MediaPlayer has been initialized'); } /** * Sets the MPD source and the video element to null. You can also reset the MediaPlayer by * calling attachSource with a new source file. * * Calling this method is all that is necessary to destroy a MediaPlayer instance. * * @memberof module:MediaPlayer * @instance */ function reset() { attachSource(null); attachView(null); protectionData = null; if (protectionController) { protectionController.reset(); protectionController = null; } if (metricsReportingController) { metricsReportingController.reset(); metricsReportingController = null; } segmentBaseController.reset(); settings.reset(); if (offlineController) { offlineController.reset(); offlineController = null; } } /** * The ready state of the MediaPlayer based on both the video element and MPD source being defined. * * @returns {boolean} The current ready state of the MediaPlayer * @see {@link module:MediaPlayer#attachView attachView()} * @see {@link module:MediaPlayer#attachSource attachSource()} * @memberof module:MediaPlayer * @instance */ function isReady() { return (!!source &amp;&amp; !!videoModel.getElement()); } /** * Use the on method to listen for public events found in MediaPlayer.events. {@link MediaPlayerEvents} * * @param {string} type - {@link MediaPlayerEvents} * @param {Function} listener - callback method when the event fires. * @param {Object} scope - context of the listener so it can be removed properly. * @memberof module:MediaPlayer * @instance */ function on(type, listener, scope) { eventBus.on(type, listener, scope); } /** * Use the off method to remove listeners for public events found in MediaPlayer.events. {@link MediaPlayerEvents} * * @param {string} type - {@link MediaPlayerEvents} * @param {Function} listener - callback method when the event fires. * @param {Object} scope - context of the listener so it can be removed properly. * @memberof module:MediaPlayer * @instance */ function off(type, listener, scope) { eventBus.off(type, listener, scope); } /** * Current version of Dash.js * @returns {string} the current dash.js version string. * @memberof module:MediaPlayer * @instance */ function getVersion() { return getVersionString(); } /** * Use this method to access the dash.js logging class. * * @returns {Debug} * @memberof module:MediaPlayer * @instance */ function getDebug() { return debug; } /* --------------------------------------------------------------------------- PLAYBACK FUNCTIONS --------------------------------------------------------------------------- */ /** * Causes the player to begin streaming the media as set by the {@link module:MediaPlayer#attachSource attachSource()} * method in preparation for playing. It specifically does not require a view to be attached with {@link module:MediaPlayer#attachSource attachView()} to begin preloading. * When a view is attached after preloading, the buffered data is transferred to the attached mediaSource buffers. * * @see {@link module:MediaPlayer#attachSource attachSource()} * @see {@link module:MediaPlayer#attachView attachView()} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~SOURCE_NOT_ATTACHED_ERROR SOURCE_NOT_ATTACHED_ERROR} if called before attachSource function * @instance */ function preload() { if (videoModel.getElement() || streamingInitialized) { return false; } if (source) { initializePlayback(); } else { throw SOURCE_NOT_ATTACHED_ERROR; } } /** * The play method initiates playback of the media defined by the {@link module:MediaPlayer#attachSource attachSource()} method. * This method will call play on the native Video Element. * * @see {@link module:MediaPlayer#attachSource attachSource()} * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function play() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } if (!autoPlay || (isPaused() &amp;&amp; playbackInitialized)) { playbackController.play(); } } /** * This method will call pause on the native Video Element. * * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function pause() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } playbackController.pause(); } /** * Returns a Boolean that indicates whether the Video Element is paused. * @return {boolean} * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function isPaused() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } return playbackController.isPaused(); } /** * Sets the currentTime property of the attached video element. If it is a live stream with a * timeShiftBufferLength, then the DVR window offset will be automatically calculated. * * @param {number} value - A relative time, in seconds, based on the return value of the {@link module:MediaPlayer#duration duration()} method is expected * @see {@link module:MediaPlayer#getDVRSeekOffset getDVRSeekOffset()} * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @throws {@link Constants#BAD_ARGUMENT_ERROR BAD_ARGUMENT_ERROR} if called with an invalid argument, not number type or is NaN. * @memberof module:MediaPlayer * @instance */ function seek(value) { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } checkParameterType(value, 'number'); if (isNaN(value)) { throw Constants.BAD_ARGUMENT_ERROR; } let s = playbackController.getIsDynamic() ? getDVRSeekOffset(value) : value; playbackController.seek(s); } /** * Returns a Boolean that indicates whether the media is in the process of seeking to a new position. * @return {boolean} * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function isSeeking() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } return playbackController.isSeeking(); } /** * Returns a Boolean that indicates whether the media is in the process of dynamic. * @return {boolean} * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function isDynamic() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } return playbackController.getIsDynamic(); } /** * Use this method to set the native Video Element's playback rate. * @param {number} value * @memberof module:MediaPlayer * @instance */ function setPlaybackRate(value) { getVideoElement().playbackRate = value; } /** * Returns the current playback rate. * @returns {number} * @memberof module:MediaPlayer * @instance */ function getPlaybackRate() { return getVideoElement().playbackRate; } /** * Use this method to set the native Video Element's muted state. Takes a Boolean that determines whether audio is muted. true if the audio is muted and false otherwise. * @param {boolean} value * @memberof module:MediaPlayer * @throws {@link Constants#BAD_ARGUMENT_ERROR BAD_ARGUMENT_ERROR} if called with an invalid argument, not boolean type. * @instance */ function setMute(value) { checkParameterType(value, 'boolean'); getVideoElement().muted = value; } /** * A Boolean that determines whether audio is muted. * @returns {boolean} * @memberof module:MediaPlayer * @instance */ function isMuted() { return getVideoElement().muted; } /** * A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest). * @param {number} value * @memberof module:MediaPlayer * @throws {@link Constants#BAD_ARGUMENT_ERROR BAD_ARGUMENT_ERROR} if called with an invalid argument, not number type, or is NaN or not between 0 and 1. * @instance */ function setVolume(value) { if (typeof value !== 'number' || isNaN(value) || value &lt; 0.0 || value &gt; 1.0) { throw Constants.BAD_ARGUMENT_ERROR; } getVideoElement().volume = value; } /** * Returns the current audio volume, from 0.0 (silent) to 1.0 (loudest). * @returns {number} * @memberof module:MediaPlayer * @instance */ function getVolume() { return getVideoElement().volume; } /** * The length of the buffer for a given media type, in seconds. Valid media * types are \"video\", \"audio\" and \"fragmentedText\". If no type is passed * in, then the minimum of video, audio and fragmentedText buffer length is * returned. NaN is returned if an invalid type is requested, the * presentation does not contain that type, or if no arguments are passed * and the presentation does not include any adaption sets of valid media * type. * * @param {MediaType} type - 'video', 'audio' or 'fragmentedText' * @returns {number} The length of the buffer for the given media type, in * seconds, or NaN * @memberof module:MediaPlayer * @instance */ function getBufferLength(type) { const types = [Constants.VIDEO, Constants.AUDIO, Constants.FRAGMENTED_TEXT]; if (!type) { const buffer = types.map( t =&gt; getTracksFor(t).length &gt; 0 ? getDashMetrics().getCurrentBufferLevel(t) : Number.MAX_VALUE ).reduce( (p, c) =&gt; Math.min(p, c) ); return buffer === Number.MAX_VALUE ? NaN : buffer; } else { if (types.indexOf(type) !== -1) { const buffer = getDashMetrics().getCurrentBufferLevel(type); return buffer ? buffer : NaN; } else { logger.warn('getBufferLength requested for invalid type'); return NaN; } } } /** * The timeShiftBufferLength (DVR Window), in seconds. * * @returns {number} The window of allowable play time behind the live point of a live stream. * @memberof module:MediaPlayer * @instance */ function getDVRWindowSize() { let metric = dashMetrics.getCurrentDVRInfo(); if (!metric) { return 0; } return metric.manifestInfo.DVRWindowSize; } /** * This method should only be used with a live stream that has a valid timeShiftBufferLength (DVR Window). * NOTE - If you do not need the raw offset value (i.e. media analytics, tracking, etc) consider using the {@link module:MediaPlayer#seek seek()} method * which will calculate this value for you and set the video element's currentTime property all in one simple call. * * @param {number} value - A relative time, in seconds, based on the return value of the {@link module:MediaPlayer#duration duration()} method is expected. * @returns {number} A value that is relative the available range within the timeShiftBufferLength (DVR Window). * @see {@link module:MediaPlayer#seek seek()} * @memberof module:MediaPlayer * @instance */ function getDVRSeekOffset(value) { let metric = dashMetrics.getCurrentDVRInfo(); if (!metric) { return 0; } let liveDelay = playbackController.getLiveDelay(); let val = metric.range.start + value; if (val &gt; (metric.range.end - liveDelay)) { val = metric.range.end - liveDelay; } return val; } /** * Current time of the playhead, in seconds. * * If called with no arguments then the returned time value is time elapsed since the start point of the first stream, or if it is a live stream, then the time will be based on the return value of the {@link module:MediaPlayer#duration duration()} method. * However if a stream ID is supplied then time is relative to the start of that stream, or is null if there is no such stream id in the manifest. * * @param {string} streamId - The ID of a stream that the returned playhead time must be relative to the start of. If undefined, then playhead time is relative to the first stream. * @returns {number} The current playhead time of the media, or null. * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function time(streamId) { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } let t = getVideoElement().currentTime; if (streamId !== undefined) { t = streamController.getTimeRelativeToStreamId(t, streamId); } else if (playbackController.getIsDynamic()) { let metric = dashMetrics.getCurrentDVRInfo(); t = (metric === null) ? 0 : duration() - (metric.range.end - metric.time); } return t; } /** * Duration of the media's playback, in seconds. * * @returns {number} The current duration of the media. * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function duration() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } let d = getVideoElement().duration; if (playbackController.getIsDynamic()) { let metric = dashMetrics.getCurrentDVRInfo(); let range; if (!metric) { return 0; } range = metric.range.end - metric.range.start; d = range &lt; metric.manifestInfo.DVRWindowSize ? range : metric.manifestInfo.DVRWindowSize; } return d; } /** * Use this method to get the current playhead time as an absolute value, the time in seconds since midnight UTC, Jan 1 1970. * Note - this property only has meaning for live streams. If called before play() has begun, it will return a value of NaN. * * @returns {number} The current playhead time as UTC timestamp. * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function timeAsUTC() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } if (time() &lt; 0) { return NaN; } return getAsUTC(time()); } /** * Use this method to get the current duration as an absolute value, the time in seconds since midnight UTC, Jan 1 1970. * Note - this property only has meaning for live streams. * * @returns {number} The current duration as UTC timestamp. * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function durationAsUTC() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } return getAsUTC(duration()); } /* --------------------------------------------------------------------------- AUTO BITRATE --------------------------------------------------------------------------- */ /** * Gets the top quality BitrateInfo checking portal limit and max allowed. * It calls getTopQualityIndexFor internally * * @param {MediaType} type - 'video' or 'audio' * @memberof module:MediaPlayer * @returns {BitrateInfo | null} * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function getTopBitrateInfoFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } return abrController.getTopBitrateInfoFor(type); } /** * Gets the current download quality for media type video, audio or images. For video and audio types the ABR * rules update this value before every new download unless setAutoSwitchQualityFor(type, false) is called. For 'image' * type, thumbnails, there is no ABR algorithm and quality is set manually. * * @param {MediaType} type - 'video', 'audio' or 'image' (thumbnails) * @returns {number} the quality index, 0 corresponding to the lowest bitrate * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setAutoSwitchQualityFor setAutoSwitchQualityFor()} * @see {@link module:MediaPlayer#setQualityFor setQualityFor()} * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function getQualityFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } if (type === Constants.IMAGE) { const activeStream = getActiveStream(); if (!activeStream) { return -1; } const thumbnailController = activeStream.getThumbnailController(); return !thumbnailController ? -1 : thumbnailController.getCurrentTrackIndex(); } return abrController.getQualityFor(type); } /** * Sets the current quality for media type instead of letting the ABR Heuristics automatically selecting it. * This value will be overwritten by the ABR rules unless setAutoSwitchQualityFor(type, false) is called. * * @param {MediaType} type - 'video', 'audio' or 'image' * @param {number} value - the quality index, 0 corresponding to the lowest bitrate * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setAutoSwitchQualityFor setAutoSwitchQualityFor()} * @see {@link module:MediaPlayer#getQualityFor getQualityFor()} * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function setQualityFor(type, value) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } if (type === Constants.IMAGE) { const activeStream = getActiveStream(); if (!activeStream) { return; } const thumbnailController = activeStream.getThumbnailController(); if (thumbnailController) { thumbnailController.setTrackByIndex(value); } } abrController.setPlaybackQuality(type, streamController.getActiveStreamInfo(), value); } /** * Update the video element size variables * Should be called on window resize (or any other time player is resized). Fullscreen does trigger a window resize event. * * Once windowResizeEventCalled = true, abrController.checkPortalSize() will use element size variables rather than querying clientWidth every time. * * @memberof module:MediaPlayer * @instance */ function updatePortalSize() { abrController.setElementSize(); abrController.setWindowResizeEventCalled(true); } /* --------------------------------------------------------------------------- MEDIA PLAYER CONFIGURATION --------------------------------------------------------------------------- */ /** * &lt;p&gt;Set to false to prevent stream from auto-playing when the view is attached.&lt;/p&gt; * * @param {boolean} value * @default true * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#attachView attachView()} * @throws {@link Constants#BAD_ARGUMENT_ERROR BAD_ARGUMENT_ERROR} if called with an invalid argument, not boolean type. * @instance * */ function setAutoPlay(value) { checkParameterType(value, 'boolean'); autoPlay = value; } /** * @returns {boolean} The current autoPlay state. * @memberof module:MediaPlayer * @instance */ function getAutoPlay() { return autoPlay; } /** * @memberof module:MediaPlayer * @instance * @returns {number|NaN} Current live stream latency in seconds. It is the difference between current time and time position at the playback head. * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function */ function getCurrentLiveLatency() { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } if (!playbackInitialized) { return NaN; } return playbackController.getCurrentLiveLatency(); } /** * Add a custom ABR Rule * Rule will be apply on next stream if a stream is being played * * @param {string} type - rule type (one of ['qualitySwitchRules','abandonFragmentRules']) * @param {string} rulename - name of rule (used to identify custom rule). If one rule of same name has been added, then existing rule will be updated * @param {object} rule - the rule object instance * @memberof module:MediaPlayer * @throws {@link Constants#BAD_ARGUMENT_ERROR BAD_ARGUMENT_ERROR} if called with invalid arguments. * @instance */ function addABRCustomRule(type, rulename, rule) { mediaPlayerModel.addABRCustomRule(type, rulename, rule); } /** * Remove a custom ABR Rule * * @param {string} rulename - name of the rule to be removed * @memberof module:MediaPlayer * @instance */ function removeABRCustomRule(rulename) { mediaPlayerModel.removeABRCustomRule(rulename); } /** * Remove all custom rules * @memberof module:MediaPlayer * @instance */ function removeAllABRCustomRule() { mediaPlayerModel.removeABRCustomRule(); } /** * &lt;p&gt;Allows you to set a scheme and server source for UTC live edge detection for dynamic streams. * If UTCTiming is defined in the manifest, it will take precedence over any time source manually added.&lt;/p&gt; * &lt;p&gt;If you have exposed the Date header, use the method {@link module:MediaPlayer#clearDefaultUTCTimingSources clearDefaultUTCTimingSources()}. * This will allow the date header on the manifest to be used instead of a time server&lt;/p&gt; * @param {string} schemeIdUri - &lt;ul&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-head:2014&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-xsdate:2014&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-iso:2014&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:direct:2014&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt;Some specs referencing early ISO23009-1 drafts incorrectly use * 2012 in the URI, rather than 2014. support these for now.&lt;/p&gt; * &lt;ul&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-head:2012&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-xsdate:2012&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-iso:2012&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:direct:2012&lt;/li&gt; * &lt;/ul&gt; * @param {string} value - Path to a time source. * @default * &lt;ul&gt; * &lt;li&gt;schemeIdUri:urn:mpeg:dash:utc:http-xsdate:2014&lt;/li&gt; * &lt;li&gt;value:http://time.akamai.com/?iso&amp;ms/li&gt; * &lt;/ul&gt; * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#removeUTCTimingSource removeUTCTimingSource()} * @instance */ function addUTCTimingSource(schemeIdUri, value) { mediaPlayerModel.addUTCTimingSource(schemeIdUri, value); } /** * &lt;p&gt;Allows you to remove a UTC time source. Both schemeIdUri and value need to match the Dash.vo.UTCTiming properties in order for the * entry to be removed from the array&lt;/p&gt; * @param {string} schemeIdUri - see {@link module:MediaPlayer#addUTCTimingSource addUTCTimingSource()} * @param {string} value - see {@link module:MediaPlayer#addUTCTimingSource addUTCTimingSource()} * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#clearDefaultUTCTimingSources clearDefaultUTCTimingSources()} * @throws {@link Constants#BAD_ARGUMENT_ERROR BAD_ARGUMENT_ERROR} if called with invalid arguments, schemeIdUri and value are not string type. * @instance */ function removeUTCTimingSource(schemeIdUri, value) { mediaPlayerModel.removeUTCTimingSource(schemeIdUri, value); } /** * &lt;p&gt;Allows you to clear the stored array of time sources.&lt;/p&gt; * &lt;p&gt;Example use: If you have exposed the Date header, calling this method * will allow the date header on the manifest to be used instead of the time server.&lt;/p&gt; * &lt;p&gt;Example use: Calling this method, assuming there is not an exposed date header on the manifest, will default back * to using a binary search to discover the live edge&lt;/p&gt; * * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#restoreDefaultUTCTimingSources restoreDefaultUTCTimingSources()} * @instance */ function clearDefaultUTCTimingSources() { mediaPlayerModel.clearDefaultUTCTimingSources(); } /** * &lt;p&gt;Allows you to restore the default time sources after calling {@link module:MediaPlayer#clearDefaultUTCTimingSources clearDefaultUTCTimingSources()}&lt;/p&gt; * * @default * &lt;ul&gt; * &lt;li&gt;schemeIdUri:urn:mpeg:dash:utc:http-xsdate:2014&lt;/li&gt; * &lt;li&gt;value:http://time.akamai.com/?iso&amp;ms&lt;/li&gt; * &lt;/ul&gt; * * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#addUTCTimingSource addUTCTimingSource()} * @instance */ function restoreDefaultUTCTimingSources() { mediaPlayerModel.restoreDefaultUTCTimingSources(); } /** * Returns the average throughput computed in the ABR logic * * @param {MediaType} type * @return {number} value * @memberof module:MediaPlayer * @instance */ function getAverageThroughput(type) { const throughputHistory = abrController.getThroughputHistory(); return throughputHistory ? throughputHistory.getAverageThroughput(type) : 0; } /** * Sets whether withCredentials on XHR requests for a particular request * type is true or false * * @default false * @param {string} type - one of HTTPRequest.*_TYPE * @param {boolean} value * @memberof module:MediaPlayer * @instance */ function setXHRWithCredentialsForType(type, value) { mediaPlayerModel.setXHRWithCredentialsForType(type, value); } /** * Gets whether withCredentials on XHR requests for a particular request * type is true or false * * @param {string} type - one of HTTPRequest.*_TYPE * @return {boolean} * @memberof module:MediaPlayer * @instance */ function getXHRWithCredentialsForType(type) { return mediaPlayerModel.getXHRWithCredentialsForType(type); } /* --------------------------------------------------------------------------- OFFLINE --------------------------------------------------------------------------- */ /** * Detects if Offline is included and returns an instance of OfflineController.js * @memberof module:MediaPlayer * @instance */ function getOfflineController() { return detectOffline(); } /* --------------------------------------------------------------------------- METRICS --------------------------------------------------------------------------- */ /** * Returns the DashMetrics.js Module. You use this Module to get access to all the public metrics * stored in dash.js * * @see {@link module:DashMetrics} * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getDashMetrics() { return dashMetrics; } /* --------------------------------------------------------------------------- TEXT MANAGEMENT --------------------------------------------------------------------------- */ /** * Set default language for text. If default language is not one of text tracks, dash will choose the first one. * * @param {string} lang - default language * @memberof module:MediaPlayer * @instance * @deprecated will be removed in version 3.2.0. Please use setInitialMediaSettingsFor(\"fragmentedText\", { lang: lang }) instead */ function setTextDefaultLanguage(lang) { logger.warn('setTextDefaultLanguage is deprecated and will be removed in version 3.2.0. Please use setInitialMediaSettingsFor(\"fragmentedText\", { lang: lang }) instead'); if (textController === undefined) { textController = TextController(context).getInstance(); } textController.setTextDefaultLanguage(lang); } /** * Get default language for text. * * @return {string} the default language if it has been set using setTextDefaultLanguage * @memberof module:MediaPlayer * @instance * @deprecated will be removed in version 3.2.0. Please use getInitialMediaSettingsFor(\"fragmentedText\").lang instead */ function getTextDefaultLanguage() { logger.warn('getTextDefaultLanguage is deprecated and will be removed in version 3.2.0. Please use getInitialMediaSettingsFor(\"fragmentedText\").lang instead'); if (textController === undefined) { textController = TextController(context).getInstance(); } return textController.getTextDefaultLanguage(); } /** * Set enabled default state. * This is used to enable/disable text when a file is loaded. * During playback, use enableText to enable text for the file * * @param {boolean} enable - true to enable text, false otherwise * @memberof module:MediaPlayer * @instance */ function setTextDefaultEnabled(enable) { if (textController === undefined) { textController = TextController(context).getInstance(); } textController.setTextDefaultEnabled(enable); } /** * Get enabled default state. * * @return {boolean} default enable state * @memberof module:MediaPlayer * @instance */ function getTextDefaultEnabled() { if (textController === undefined) { textController = TextController(context).getInstance(); } return textController.getTextDefaultEnabled(); } /** * Enable/disable text * When enabling text, dash will choose the previous selected text track * * @param {boolean} enable - true to enable text, false otherwise (same as setTextTrack(-1)) * @memberof module:MediaPlayer * @instance */ function enableText(enable) { if (textController === undefined) { textController = TextController(context).getInstance(); } textController.enableText(enable); } /** * Enable/disable text * When enabling dash will keep downloading and process fragmented text tracks even if all tracks are in mode \"hidden\" * * @param {boolean} enable - true to enable text streaming even if all text tracks are hidden. * @memberof module:MediaPlayer * @instance */ function enableForcedTextStreaming(enable) { if (textController === undefined) { textController = TextController(context).getInstance(); } textController.enableForcedTextStreaming(enable); } /** * Return if text is enabled * * @return {boolean} return true if text is enabled, false otherwise * @memberof module:MediaPlayer * @instance */ function isTextEnabled() { if (textController === undefined) { textController = TextController(context).getInstance(); } return textController.isTextEnabled(); } /** * Use this method to change the current text track for both external time text files and fragmented text tracks. There is no need to * set the track mode on the video object to switch a track when using this method. * @param {number} idx - Index of track based on the order of the order the tracks are added Use -1 to disable all tracks. (turn captions off). Use module:MediaPlayer#dashjs.MediaPlayer.events.TEXT_TRACK_ADDED. * @see {@link MediaPlayerEvents#event:TEXT_TRACK_ADDED dashjs.MediaPlayer.events.TEXT_TRACK_ADDED} * @throws {@link module:MediaPlayer~PLAYBACK_NOT_INITIALIZED_ERROR PLAYBACK_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function setTextTrack(idx) { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } if (textController === undefined) { textController = TextController(context).getInstance(); } textController.setTextTrack(idx); } function getCurrentTextTrackIndex() { let idx = NaN; if (textController) { idx = textController.getCurrentTrackIdx(); } return idx; } /** * This method serves to control captions z-index value. If 'true' is passed, the captions will have the highest z-index and be * displayed on top of other html elements. Default value is 'false' (z-index is not set). * @param {boolean} value * @memberof module:MediaPlayer * @instance */ function displayCaptionsOnTop(value) { let textTracks = TextTracks(context).getInstance(); textTracks.setConfig({ videoModel: videoModel }); textTracks.initialize(); textTracks.setDisplayCConTop(value); } /* --------------------------------------------------------------------------- VIDEO ELEMENT MANAGEMENT --------------------------------------------------------------------------- */ /** * Returns instance of Video Element that was attached by calling attachView() * @returns {Object} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~ELEMENT_NOT_ATTACHED_ERROR ELEMENT_NOT_ATTACHED_ERROR} if called before attachView function * @instance */ function getVideoElement() { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } return videoModel.getElement(); } /** * Use this method to attach an HTML5 VideoElement for dash.js to operate upon. * * @param {Object} element - An HTMLMediaElement that has already been defined in the DOM (or equivalent stub). * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function * @instance */ function attachView(element) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } videoModel.setElement(element); if (element) { detectProtection(); detectMetricsReporting(); detectMss(); if (streamController) { streamController.switchToVideoElement(); } } if (playbackInitialized) { //Reset if we have been playing before, so this is a new element. resetPlaybackControllers(); } initializePlayback(); } /** * Returns instance of Div that was attached by calling attachTTMLRenderingDiv() * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getTTMLRenderingDiv() { return videoModel ? videoModel.getTTMLRenderingDiv() : null; } /** * Use this method to attach an HTML5 div for dash.js to render rich TTML subtitles. * * @param {HTMLDivElement} div - An unstyled div placed after the video element. It will be styled to match the video size and overlay z-order. * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~ELEMENT_NOT_ATTACHED_ERROR ELEMENT_NOT_ATTACHED_ERROR} if called before attachView function * @instance */ function attachTTMLRenderingDiv(div) { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } videoModel.setTTMLRenderingDiv(div); } /* --------------------------------------------------------------------------- STREAM AND TRACK MANAGEMENT --------------------------------------------------------------------------- */ /** * @param {MediaType} type * @returns {Array} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function getBitrateInfoListFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } let stream = getActiveStream(); return stream ? stream.getBitrateListFor(type) : []; } /** * This method returns the list of all available streams from a given manifest * @param {Object} manifest * @returns {Array} list of {@link StreamInfo} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function getStreamsFromManifest(manifest) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } return adapter.getStreamsInfo(manifest); } /** * This method returns the list of all available tracks for a given media type * @param {MediaType} type * @returns {Array} list of {@link MediaInfo} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function getTracksFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } let streamInfo = streamController.getActiveStreamInfo(); return mediaController.getTracksFor(type, streamInfo); } /** * This method returns the list of all available tracks for a given media type and streamInfo from a given manifest * @param {MediaType} type * @param {Object} manifest * @param {Object} streamInfo * @returns {Array} list of {@link MediaInfo} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function getTracksForTypeFromManifest(type, manifest, streamInfo) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } streamInfo = streamInfo || adapter.getStreamsInfo(manifest, 1)[0]; return streamInfo ? adapter.getAllMediaInfoForType(streamInfo, type, manifest) : []; } /** * @param {MediaType} type * @returns {Object|null} {@link MediaInfo} * * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function getCurrentTrackFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } let streamInfo = streamController.getActiveStreamInfo(); return mediaController.getCurrentTrackFor(type, streamInfo); } /** * This method allows to set media settings that will be used to pick the initial track. Format of the settings * is following: &lt;br /&gt; * {lang: langValue (can be either a string or a regex to match), * viewpoint: viewpointValue, * audioChannelConfiguration: audioChannelConfigurationValue, * accessibility: accessibilityValue, * role: roleValue} * * @param {MediaType} type * @param {Object} value * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function * @instance */ function setInitialMediaSettingsFor(type, value) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } mediaController.setInitialSettings(type, value); if (type === Constants.FRAGMENTED_TEXT) { textController.setInitialSettings(value); } } /** * This method returns media settings that is used to pick the initial track. Format of the settings * is following: * {lang: langValue, * viewpoint: viewpointValue, * audioChannelConfiguration: audioChannelConfigurationValue, * accessibility: accessibilityValue, * role: roleValue} * @param {MediaType} type * @returns {Object} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function * @instance */ function getInitialMediaSettingsFor(type) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } return mediaController.getInitialSettings(type); } /** * @param {MediaInfo} track - instance of {@link MediaInfo} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @instance */ function setCurrentTrack(track) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } mediaController.setTrack(track); } /** * This method returns the current track switch mode. * * @param {MediaType} type * @returns {string} mode * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function * @instance */ function getTrackSwitchModeFor(type) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } return mediaController.getSwitchMode(type); } /** * This method sets the current track switch mode. Available options are: * * MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE * (used to forbid clearing the buffered data (prior to current playback position) after track switch. * Defers to fastSwitchEnabled for placement of new data. Default for video) * * MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE * (used to clear the buffered data (prior to current playback position) after track switch. Default for audio) * * @param {MediaType} type * @param {string} mode * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function * @instance */ function setTrackSwitchModeFor(type, mode) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } mediaController.setSwitchMode(type, mode); } /** * This method sets the selection mode for the initial track. This mode defines how the initial track will be selected * if no initial media settings are set. If initial media settings are set this parameter will be ignored. Available options are: * * MediaController.TRACK_SELECTION_MODE_HIGHEST_BITRATE * this mode makes the player select the track with a highest bitrate. This mode is a default mode. * * MediaController.TRACK_SELECTION_MODE_WIDEST_RANGE * this mode makes the player select the track with a widest range of bitrates * * @param {string} mode * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function * @instance */ function setSelectionModeForInitialTrack(mode) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } mediaController.setSelectionModeForInitialTrack(mode); } /** * This method returns the track selection mode. * * @returns {string} mode * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function * @instance */ function getSelectionModeForInitialTrack() { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } return mediaController.getSelectionModeForInitialTrack(); } /* --------------------------------------------------------------------------- PROTECTION MANAGEMENT --------------------------------------------------------------------------- */ /** * Detects if Protection is included and returns an instance of ProtectionController.js * @memberof module:MediaPlayer * @instance */ function getProtectionController() { return detectProtection(); } /** * Will override dash.js protection controller. * @param {ProtectionController} value - valid protection controller instance. * @memberof module:MediaPlayer * @instance */ function attachProtectionController(value) { protectionController = value; } /** * Sets Protection Data required to setup the Protection Module (DRM). Protection Data must * be set before initializing MediaPlayer or, once initialized, before PROTECTION_CREATED event is fired. * @see {@link module:MediaPlayer#initialize initialize()} * @see {@link ProtectionEvents#event:PROTECTION_CREATED dashjs.Protection.events.PROTECTION_CREATED} * @param {ProtectionDataSet} value - object containing * property names corresponding to key system name strings and associated * values being instances of. * @memberof module:MediaPlayer * @instance */ function setProtectionData(value) { protectionData = value; // Propagate changes in case StreamController is already created if (streamController) { streamController.setProtectionData(protectionData); } } /* --------------------------------------------------------------------------- THUMBNAILS MANAGEMENT --------------------------------------------------------------------------- */ /** * Provide the thumbnail at time position. This can be asynchronous, so you must provide a callback ro retrieve thumbnails informations * @param {number} time - A relative time, in seconds, based on the return value of the {@link module:MediaPlayer#duration duration()} method is expected * @param {function} callback - A Callback function provided when retrieving thumbnail the given time position. Thumbnail object is null in case there are is not a thumbnails representation or * if it doesn't contain a thumbnail for the given time position. * @memberof module:MediaPlayer * @instance */ function provideThumbnail(time, callback) { if (typeof callback !== 'function') { return; } if (time &lt; 0) { callback(null); return; } const s = playbackController.getIsDynamic() ? getDVRSeekOffset(time) : time; const stream = streamController.getStreamForTime(s); if (stream === null) { callback(null); return; } const thumbnailController = stream.getThumbnailController(); if (!thumbnailController) { callback(null); return; } const timeInPeriod = streamController.getTimeRelativeToStreamId(s, stream.getId()); return thumbnailController.provide(timeInPeriod, callback); } /* --------------------------------------------------------------------------- TOOLS AND OTHERS FUNCTIONS --------------------------------------------------------------------------- */ /** * Allows application to retrieve a manifest. Manifest loading is asynchro * nous and * requires the app-provided callback function * * @param {string} url - url the manifest url * @param {function} callback - A Callback function provided when retrieving manifests * @memberof module:MediaPlayer * @instance */ function retrieveManifest(url, callback) { let manifestLoader = createManifestLoader(); let self = this; const handler = function (e) { if (!e.error) { callback(e.manifest); } else { callback(null, e.error); } eventBus.off(Events.INTERNAL_MANIFEST_LOADED, handler, self); manifestLoader.reset(); }; eventBus.on(Events.INTERNAL_MANIFEST_LOADED, handler, self); uriFragmentModel.initialize(url); manifestLoader.load(url); } /** * Returns the source string or manifest that was attached by calling attachSource() * @returns {string | manifest} * @memberof module:MediaPlayer * @throws {@link module:MediaPlayer~SOURCE_NOT_ATTACHED_ERROR SOURCE_NOT_ATTACHED_ERROR} if called before attachSource function * @instance */ function getSource() { if (!source) { throw SOURCE_NOT_ATTACHED_ERROR; } return source; } /** * Use this method to set a source URL to a valid MPD manifest file OR * a previously downloaded and parsed manifest object. Optionally, can * also provide protection information * * @param {string|Object} urlOrManifest - A URL to a valid MPD manifest file, or a * parsed manifest object. * * * @throws {@link module:MediaPlayer~MEDIA_PLAYER_NOT_INITIALIZED_ERROR MEDIA_PLAYER_NOT_INITIALIZED_ERROR} if called before initialize function * * @memberof module:MediaPlayer * @instance */ function attachSource(urlOrManifest) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } if (typeof urlOrManifest === 'string') { uriFragmentModel.initialize(urlOrManifest); } source = urlOrManifest; if (streamingInitialized || playbackInitialized) { resetPlaybackControllers(); } if (isReady()) { initializePlayback(); } } /** * Get the current settings object being used on the player. * @returns {PlayerSettings} The settings object being used. * * @memberof module:MediaPlayer * @instance */ function getSettings() { return settings.get(); } /** * @summary Update the current settings object being used on the player. Anything left unspecified is not modified. * @param {PlayerSettings} settingsObj - An object corresponding to the settings definition. * @description This function does not update the entire object, only properties in the passed in object are updated. * * This means that updateSettings({a: x}) and updateSettings({b: y}) are functionally equivalent to * updateSettings({a: x, b: y}). If the default values are required again, @see{@link resetSettings}. * @example * player.updateSettings({ * streaming: { * liveDelayFragmentCount: 8 * abr: { * maxBitrate: { audio: 100, video: 1000 } * } * } * }); * @memberof module:MediaPlayer * @instance */ function updateSettings(settingsObj) { settings.update(settingsObj); } /** * Resets the settings object back to the default. * * @memberof module:MediaPlayer * @instance */ function resetSettings() { settings.reset(); } /** * A utility methods which converts UTC timestamp value into a valid time and date string. * * @param {number} time - UTC timestamp to be converted into date and time. * @param {string} locales - a region identifier (i.e. en_US). * @param {boolean} hour12 - 12 vs 24 hour. Set to true for 12 hour time formatting. * @param {boolean} withDate - default is false. Set to true to append current date to UTC time format. * @returns {string} A formatted time and date string. * @memberof module:MediaPlayer * @instance */ function formatUTC(time, locales, hour12, withDate = false) { const dt = new Date(time * 1000); const d = dt.toLocaleDateString(locales); const t = dt.toLocaleTimeString(locales, { hour12: hour12 }); return withDate ? t + ' ' + d : t; } /** * A utility method which converts seconds into TimeCode (i.e. 300 --&gt; 05:00). * * @param {number} value - A number in seconds to be converted into a formatted time code. * @returns {string} A formatted time code string. * @memberof module:MediaPlayer * @instance */ function convertToTimeCode(value) { value = Math.max(value, 0); let h = Math.floor(value / 3600); let m = Math.floor((value % 3600) / 60); let s = Math.floor((value % 3600) % 60); return (h === 0 ? '' : (h &lt; 10 ? '0' + h.toString() + ':' : h.toString() + ':')) + (m &lt; 10 ? '0' + m.toString() : m.toString()) + ':' + (s &lt; 10 ? '0' + s.toString() : s.toString()); } /** * This method should be used to extend or replace internal dash.js objects. * There are two ways to extend dash.js (determined by the override argument): * &lt;ol&gt; * &lt;li&gt;If you set override to true any public method or property in your custom object will * override the dash.js parent object's property(ies) and will be used instead but the * dash.js parent module will still be created.&lt;/li&gt; * * &lt;li&gt;If you set override to false your object will completely replace the dash.js object. * (Note: This is how it was in 1.x of Dash.js with Dijon).&lt;/li&gt; * &lt;/ol&gt; * &lt;b&gt;When you extend you get access to this.context, this.factory and this.parent to operate with in your custom object.&lt;/b&gt; * &lt;ul&gt; * &lt;li&gt;&lt;b&gt;this.context&lt;/b&gt; - can be used to pass context for singleton access.&lt;/li&gt; * &lt;li&gt;&lt;b&gt;this.factory&lt;/b&gt; - can be used to call factory.getSingletonInstance().&lt;/li&gt; * &lt;li&gt;&lt;b&gt;this.parent&lt;/b&gt; - is the reference of the parent object to call other public methods. (this.parent is excluded if you extend with override set to false or option 2)&lt;/li&gt; * &lt;/ul&gt; * &lt;b&gt;You must call extend before you call initialize&lt;/b&gt; * @see {@link module:MediaPlayer#initialize initialize()} * @param {string} parentNameString - name of parent module * @param {Object} childInstance - overriding object * @param {boolean} override - replace only some methods (true) or the whole object (false) * @memberof module:MediaPlayer * @instance */ function extend(parentNameString, childInstance, override) { FactoryMaker.extend(parentNameString, childInstance, override, context); } /** * This method returns the active stream * * @throws {@link module:MediaPlayer~STREAMING_NOT_INITIALIZED_ERROR STREAMING_NOT_INITIALIZED_ERROR} if called before initializePlayback function * @memberof module:MediaPlayer * @instance */ function getActiveStream() { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } let streamInfo = streamController.getActiveStreamInfo(); return streamInfo ? streamController.getStreamById(streamInfo.id) : null; } //*********************************** // PRIVATE METHODS //*********************************** function resetPlaybackControllers() { playbackInitialized = false; streamingInitialized = false; adapter.reset(); streamController.reset(); gapController.reset(); playbackController.reset(); abrController.reset(); mediaController.reset(); textController.reset(); if (protectionController) { if (settings.get().streaming.keepProtectionMediaKeys) { protectionController.stop(); } else { protectionController.reset(); protectionController = null; detectProtection(); } } cmcdModel.reset(); } function createPlaybackControllers() { // creates or get objects instances const manifestLoader = createManifestLoader(); if (!streamController) { streamController = StreamController(context).getInstance(); } // configure controllers mediaController.setConfig({ domStorage: domStorage }); streamController.setConfig({ capabilities: capabilities, manifestLoader: manifestLoader, manifestModel: manifestModel, mediaPlayerModel: mediaPlayerModel, protectionController: protectionController, adapter: adapter, dashMetrics: dashMetrics, errHandler: errHandler, timelineConverter: timelineConverter, videoModel: videoModel, playbackController: playbackController, abrController: abrController, mediaController: mediaController, textController: textController, settings: settings, baseURLController: baseURLController }); gapController.setConfig({ settings, playbackController, streamController, videoModel, timelineConverter, adapter }); playbackController.setConfig({ streamController: streamController, dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, adapter: adapter, videoModel: videoModel, timelineConverter: timelineConverter, uriFragmentModel: uriFragmentModel, settings: settings }); abrController.setConfig({ streamController: streamController, domStorage: domStorage, mediaPlayerModel: mediaPlayerModel, dashMetrics: dashMetrics, adapter: adapter, videoModel: videoModel, settings: settings }); abrController.createAbrRulesCollection(); textController.setConfig({ errHandler: errHandler, manifestModel: manifestModel, adapter: adapter, mediaController: mediaController, streamController: streamController, videoModel: videoModel }); cmcdModel.setConfig({ abrController, dashMetrics, playbackController }); // initialises controller streamController.initialize(autoPlay, protectionData); gapController.initialize(); cmcdModel.initialize(); } function createManifestLoader() { return ManifestLoader(context).create({ debug: debug, errHandler: errHandler, dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, requestModifier: RequestModifier(context).getInstance(), mssHandler: mssHandler, settings: settings }); } function detectProtection() { if (protectionController) { return protectionController; } // do not require Protection as dependencies as this is optional and intended to be loaded separately let Protection = dashjs.Protection; /* jshint ignore:line */ if (typeof Protection === 'function') { //TODO need a better way to register/detect plugin components let protection = Protection(context).create(); Events.extend(Protection.events); MediaPlayerEvents.extend(Protection.events, { publicOnly: true }); Errors.extend(Protection.errors); if (!capabilities) { capabilities = Capabilities(context).getInstance(); } protectionController = protection.createProtectionSystem({ debug: debug, errHandler: errHandler, videoModel: videoModel, capabilities: capabilities, eventBus: eventBus, events: Events, BASE64: BASE64, constants: Constants }); return protectionController; } return null; } function detectMetricsReporting() { if (metricsReportingController) { return; } // do not require MetricsReporting as dependencies as this is optional and intended to be loaded separately let MetricsReporting = dashjs.MetricsReporting; /* jshint ignore:line */ if (typeof MetricsReporting === 'function') { //TODO need a better way to register/detect plugin components let metricsReporting = MetricsReporting(context).create(); metricsReportingController = metricsReporting.createMetricsReporting({ debug: debug, eventBus: eventBus, mediaElement: getVideoElement(), adapter: adapter, dashMetrics: dashMetrics, events: Events, constants: Constants, metricsConstants: MetricsConstants }); } } function detectMss() { if (mssHandler) { return; } // do not require MssHandler as dependencies as this is optional and intended to be loaded separately let MssHandler = dashjs.MssHandler; /* jshint ignore:line */ if (typeof MssHandler === 'function') { //TODO need a better way to register/detect plugin components Errors.extend(MssHandler.errors); mssHandler = MssHandler(context).create({ eventBus: eventBus, mediaPlayerModel: mediaPlayerModel, dashMetrics: dashMetrics, manifestModel: manifestModel, playbackController: playbackController, streamController: streamController, protectionController: protectionController, baseURLController: baseURLController, errHandler: errHandler, events: Events, constants: Constants, debug: debug, initSegmentType: HTTPRequest.INIT_SEGMENT_TYPE, BASE64: BASE64, ISOBoxer: ISOBoxer, settings: settings }); } } function detectOffline() { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } if (offlineController) { return offlineController; } // do not require Offline as dependencies as this is optional and intended to be loaded separately let OfflineController = dashjs.OfflineController; /* jshint ignore:line */ if (typeof OfflineController === 'function') { //TODO need a better way to register/detect plugin components Events.extend(OfflineController.events); MediaPlayerEvents.extend(OfflineController.events, { publicOnly: true }); Errors.extend(OfflineController.errors); const manifestLoader = createManifestLoader(); const manifestUpdater = ManifestUpdater(context).create(); manifestUpdater.setConfig({ manifestModel: manifestModel, adapter: adapter, manifestLoader: manifestLoader, errHandler: errHandler }); offlineController = OfflineController(context).create({ debug: debug, manifestUpdater: manifestUpdater, baseURLController: baseURLController, manifestLoader: manifestLoader, manifestModel: manifestModel, mediaPlayerModel: mediaPlayerModel, abrController: abrController, playbackController: playbackController, adapter: adapter, errHandler: errHandler, dashMetrics: dashMetrics, timelineConverter: timelineConverter, schemeLoaderFactory: schemeLoaderFactory, eventBus: eventBus, events: Events, errors: Errors, constants: Constants, settings: settings, dashConstants: DashConstants, urlUtils: URLUtils(context).getInstance() }); return offlineController; } return null; } function getAsUTC(valToConvert) { let metric = dashMetrics.getCurrentDVRInfo(); let availableFrom, utcValue; if (!metric) { return 0; } availableFrom = metric.manifestInfo.availableFrom.getTime() / 1000; utcValue = valToConvert + (availableFrom + metric.range.start); return utcValue; } function initializePlayback() { if (offlineController) { offlineController.resetRecords(); } if (!streamingInitialized &amp;&amp; source) { streamingInitialized = true; logger.info('Streaming Initialized'); createPlaybackControllers(); if (typeof source === 'string') { streamController.load(source); } else { streamController.loadWithManifest(source); } } if (!playbackInitialized &amp;&amp; isReady()) { playbackInitialized = true; logger.info('Playback Initialized'); } } /** * Returns the DashAdapter.js Module. * * @see {@link module:DashAdapter} * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getDashAdapter() { return adapter; } instance = { initialize: initialize, setConfig: setConfig, on: on, off: off, extend: extend, attachView: attachView, attachSource: attachSource, isReady: isReady, preload: preload, play: play, isPaused: isPaused, pause: pause, isSeeking: isSeeking, isDynamic: isDynamic, seek: seek, setPlaybackRate: setPlaybackRate, getPlaybackRate: getPlaybackRate, setMute: setMute, isMuted: isMuted, setVolume: setVolume, getVolume: getVolume, time: time, duration: duration, timeAsUTC: timeAsUTC, durationAsUTC: durationAsUTC, getActiveStream: getActiveStream, getDVRWindowSize: getDVRWindowSize, getDVRSeekOffset: getDVRSeekOffset, convertToTimeCode: convertToTimeCode, formatUTC: formatUTC, getVersion: getVersion, getDebug: getDebug, getBufferLength: getBufferLength, getTTMLRenderingDiv: getTTMLRenderingDiv, getVideoElement: getVideoElement, getSource: getSource, getCurrentLiveLatency: getCurrentLiveLatency, getTopBitrateInfoFor: getTopBitrateInfoFor, setAutoPlay: setAutoPlay, getAutoPlay: getAutoPlay, getDashMetrics: getDashMetrics, getQualityFor: getQualityFor, setQualityFor: setQualityFor, updatePortalSize: updatePortalSize, setTextDefaultLanguage: setTextDefaultLanguage, getTextDefaultLanguage: getTextDefaultLanguage, setTextDefaultEnabled: setTextDefaultEnabled, getTextDefaultEnabled: getTextDefaultEnabled, enableText: enableText, enableForcedTextStreaming: enableForcedTextStreaming, isTextEnabled: isTextEnabled, setTextTrack: setTextTrack, getBitrateInfoListFor: getBitrateInfoListFor, getStreamsFromManifest: getStreamsFromManifest, getTracksFor: getTracksFor, getTracksForTypeFromManifest: getTracksForTypeFromManifest, getCurrentTrackFor: getCurrentTrackFor, setInitialMediaSettingsFor: setInitialMediaSettingsFor, getInitialMediaSettingsFor: getInitialMediaSettingsFor, setCurrentTrack: setCurrentTrack, getTrackSwitchModeFor: getTrackSwitchModeFor, setTrackSwitchModeFor: setTrackSwitchModeFor, setSelectionModeForInitialTrack: setSelectionModeForInitialTrack, getSelectionModeForInitialTrack: getSelectionModeForInitialTrack, addABRCustomRule: addABRCustomRule, removeABRCustomRule: removeABRCustomRule, removeAllABRCustomRule: removeAllABRCustomRule, getAverageThroughput: getAverageThroughput, retrieveManifest: retrieveManifest, addUTCTimingSource: addUTCTimingSource, removeUTCTimingSource: removeUTCTimingSource, clearDefaultUTCTimingSources: clearDefaultUTCTimingSources, restoreDefaultUTCTimingSources: restoreDefaultUTCTimingSources, setXHRWithCredentialsForType: setXHRWithCredentialsForType, getXHRWithCredentialsForType: getXHRWithCredentialsForType, getProtectionController: getProtectionController, attachProtectionController: attachProtectionController, setProtectionData: setProtectionData, displayCaptionsOnTop: displayCaptionsOnTop, attachTTMLRenderingDiv: attachTTMLRenderingDiv, getCurrentTextTrackIndex: getCurrentTextTrackIndex, provideThumbnail: provideThumbnail, getDashAdapter: getDashAdapter, getOfflineController: getOfflineController, getSettings: getSettings, updateSettings: updateSettings, resetSettings: resetSettings, reset: reset }; setup(); return instance; } MediaPlayer.__dashjs_factory_name = 'MediaPlayer'; const factory = FactoryMaker.getClassFactory(MediaPlayer); factory.events = MediaPlayerEvents; factory.errors = Errors; FactoryMaker.updateClassFactory(MediaPlayer.__dashjs_factory_name, factory); export default factory; × Search results Close "},"streaming_metrics_MetricsReporting.js.html":{"id":"streaming_metrics_MetricsReporting.js.html","title":"Source: streaming/metrics/MetricsReporting.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/metrics/MetricsReporting.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import DVBErrorsTranslator from './utils/DVBErrorsTranslator'; import MetricsReportingEvents from './MetricsReportingEvents'; import MetricsCollectionController from './controllers/MetricsCollectionController'; import MetricsHandlerFactory from './metrics/MetricsHandlerFactory'; import ReportingFactory from './reporting/ReportingFactory'; function MetricsReporting() { let context = this.context; let instance, dvbErrorsTranslator; /** * Create a MetricsCollectionController, and a DVBErrorsTranslator * @param {Object} config - dependancies from owner * @return {MetricsCollectionController} Metrics Collection Controller */ function createMetricsReporting(config) { dvbErrorsTranslator = DVBErrorsTranslator(context).getInstance({ eventBus: config.eventBus, dashMetrics: config.dashMetrics, metricsConstants: config.metricsConstants, events: config.events }); return MetricsCollectionController(context).create(config); } /** * Get the ReportingFactory to allow new reporters to be registered * @return {ReportingFactory} Reporting Factory */ function getReportingFactory() { return ReportingFactory(context).getInstance(); } /** * Get the MetricsHandlerFactory to allow new handlers to be registered * @return {MetricsHandlerFactory} Metrics Handler Factory */ function getMetricsHandlerFactory() { return MetricsHandlerFactory(context).getInstance(); } instance = { createMetricsReporting: createMetricsReporting, getReportingFactory: getReportingFactory, getMetricsHandlerFactory: getMetricsHandlerFactory }; return instance; } MetricsReporting.__dashjs_factory_name = 'MetricsReporting'; const factory = dashjs.FactoryMaker.getClassFactory(MetricsReporting); /* jshint ignore:line */ factory.events = MetricsReportingEvents; dashjs.FactoryMaker.updateClassFactory(MetricsReporting.__dashjs_factory_name, factory); /* jshint ignore:line */ export default factory; × Search results Close "},"dash_DashAdapter.js.html":{"id":"dash_DashAdapter.js.html","title":"Source: dash/DashAdapter.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: dash/DashAdapter.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import DashConstants from './constants/DashConstants'; import RepresentationInfo from './vo/RepresentationInfo'; import MediaInfo from './vo/MediaInfo'; import StreamInfo from './vo/StreamInfo'; import ManifestInfo from './vo/ManifestInfo'; import Event from './vo/Event'; import FactoryMaker from '../core/FactoryMaker'; import DashManifestModel from './models/DashManifestModel'; /** * @module DashAdapter */ function DashAdapter() { let instance, dashManifestModel, voPeriods, voAdaptations, currentMediaInfo, constants, cea608parser; const context = this.context; const PROFILE_DVB = 'urn:dvb:dash:profile:dvb-dash:2014'; function setup() { dashManifestModel = DashManifestModel(context).getInstance(); reset(); } // #region PUBLIC FUNCTIONS // -------------------------------------------------- function getVoAdaptations() { return voAdaptations; } function getVoPeriods() { return voPeriods; } function setConfig(config) { if (!config) return; if (config.constants) { constants = config.constants; } if (config.cea608parser) { cea608parser = config.cea608parser; } if (config.errHandler) { dashManifestModel.setConfig({errHandler: config.errHandler}); } if (config.BASE64) { dashManifestModel.setConfig({BASE64: config.BASE64}); } } /** * Creates an instance of RepresentationInfo based on a representation value object * @param {object} voRepresentation * @returns {RepresentationInfo|null} representationInfo * @memberOf module:DashAdapter * @instance * @ignore */ function convertRepresentationToRepresentationInfo(voRepresentation) { if (voRepresentation) { let representationInfo = new RepresentationInfo(); const realAdaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index]; const realRepresentation = dashManifestModel.getRepresentationFor(voRepresentation.index, realAdaptation); representationInfo.id = voRepresentation.id; representationInfo.quality = voRepresentation.index; representationInfo.bandwidth = dashManifestModel.getBandwidth(realRepresentation); representationInfo.DVRWindow = voRepresentation.segmentAvailabilityRange; representationInfo.fragmentDuration = voRepresentation.segmentDuration || (voRepresentation.segments &amp;&amp; voRepresentation.segments.length &gt; 0 ? voRepresentation.segments[0].duration : NaN); representationInfo.MSETimeOffset = voRepresentation.MSETimeOffset; representationInfo.mediaInfo = convertAdaptationToMediaInfo(voRepresentation.adaptation); return representationInfo; } else { return null; } } /** * Returns a MediaInfo object for a given media type. * @param {object} streamInfo * @param {MediaType }type * @returns {null|MediaInfo} mediaInfo * @memberOf module:DashAdapter * @instance */ function getMediaInfoForType(streamInfo, type) { if (voPeriods.length === 0 || !streamInfo) { return null; } let selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods); if (!selectedVoPeriod) return null; let periodId = selectedVoPeriod.id; voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod); let realAdaptation = getAdaptationForType(streamInfo.index, type, streamInfo); if (!realAdaptation) return null; let idx = dashManifestModel.getIndexForAdaptation(realAdaptation, voPeriods[0].mpd.manifest, streamInfo.index); return convertAdaptationToMediaInfo(voAdaptations[periodId][idx]); } /** * Checks if the role of the specified AdaptationSet is set to main * @param {object} adaptation * @returns {boolean} * @memberOf module:DashAdapter * @instance */ function getIsMain(adaptation) { return dashManifestModel.getRolesForAdaptation(adaptation).filter(function (role) { return role.value === DashConstants.MAIN; })[0]; } /** * Returns the AdaptationSet for a given period and a given mediaType. * @param {number} periodIndex * @param {MediaType} type * @param {object} streamInfo * @returns {null|object} adaptation * @memberOf module:DashAdapter * @instance */ function getAdaptationForType(periodIndex, type, streamInfo) { const adaptations = dashManifestModel.getAdaptationsForType(voPeriods[0].mpd.manifest, periodIndex, type); if (!adaptations || adaptations.length === 0) return null; if (adaptations.length &gt; 1 &amp;&amp; streamInfo) { const allMediaInfoForType = getAllMediaInfoForType(streamInfo, type); if (currentMediaInfo[streamInfo.id] &amp;&amp; currentMediaInfo[streamInfo.id][type]) { for (let i = 0, ln = adaptations.length; i &lt; ln; i++) { if (currentMediaInfo[streamInfo.id][type].isMediaInfoEqual(allMediaInfoForType[i])) { return adaptations[i]; } } } for (let i = 0, ln = adaptations.length; i &lt; ln; i++) { if (getIsMain(adaptations[i])) { return adaptations[i]; } } } return adaptations[0]; } /** * Returns the mediaInfo for a given mediaType * @param {object} streamInfo * @param {MediaType} type * @param {object} externalManifest Set to null or undefined if no external manifest is to be used * @returns {Array} mediaArr * @memberOf module:DashAdapter * @instance */ function getAllMediaInfoForType(streamInfo, type, externalManifest) { let voLocalPeriods = voPeriods; let manifest = externalManifest; let mediaArr = []; let data, media, idx, i, j, ln, periodId; if (manifest) { checkConfig(); voLocalPeriods = getRegularPeriods(manifest); } else { if (voPeriods.length &gt; 0) { manifest = voPeriods[0].mpd.manifest; } else { return mediaArr; } } const selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voLocalPeriods); if (selectedVoPeriod) { periodId = selectedVoPeriod.id; } const adaptationsForType = dashManifestModel.getAdaptationsForType(manifest, streamInfo ? streamInfo.index : null, type !== constants.EMBEDDED_TEXT ? type : constants.VIDEO); if (!adaptationsForType || adaptationsForType.length === 0) return mediaArr; voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod); for (i = 0, ln = adaptationsForType.length; i &lt; ln; i++) { data = adaptationsForType[i]; idx = dashManifestModel.getIndexForAdaptation(data, manifest, streamInfo.index); media = convertAdaptationToMediaInfo(voAdaptations[periodId][idx]); if (type === constants.EMBEDDED_TEXT) { let accessibilityLength = media.accessibility.length; for (j = 0; j &lt; accessibilityLength; j++) { if (!media) { continue; } let accessibility = media.accessibility[j]; if (accessibility.indexOf('cea-608:') === 0) { let value = accessibility.substring(8); let parts = value.split(';'); if (parts[0].substring(0, 2) === 'CC') { for (j = 0; j &lt; parts.length; j++) { if (!media) { media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]); } convertVideoInfoToEmbeddedTextInfo(media, parts[j].substring(0, 3), parts[j].substring(4)); mediaArr.push(media); media = null; } } else { for (j = 0; j &lt; parts.length; j++) { // Only languages for CC1, CC2, ... if (!media) { media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]); } convertVideoInfoToEmbeddedTextInfo(media, 'CC' + (j + 1), parts[j]); mediaArr.push(media); media = null; } } } else if (accessibility.indexOf('cea-608') === 0) { // Nothing known. We interpret it as CC1=eng convertVideoInfoToEmbeddedTextInfo(media, constants.CC1, 'eng'); mediaArr.push(media); media = null; } } } else if (type === constants.IMAGE) { convertVideoInfoToThumbnailInfo(media); mediaArr.push(media); media = null; } else if (media) { mediaArr.push(media); } } return mediaArr; } /** * @param {object} newManifest * @returns {*} * @memberOf module:DashAdapter * @instance * @ignore */ function updatePeriods(newManifest) { if (!newManifest) return null; checkConfig(); voPeriods = getRegularPeriods(newManifest); voAdaptations = {}; } /** * @param {object} externalManifest * @param {number} maxStreamsInfo * @returns {Array} streams * @memberOf module:DashAdapter * @instance * @ignore */ function getStreamsInfo(externalManifest, maxStreamsInfo) { const streams = []; let voLocalPeriods = voPeriods; //if manifest is defined, getStreamsInfo is for an outside manifest, not the current one if (externalManifest) { checkConfig(); voLocalPeriods = getRegularPeriods(externalManifest); } if (voLocalPeriods.length &gt; 0) { if (!maxStreamsInfo || maxStreamsInfo &gt; voLocalPeriods.length) { maxStreamsInfo = voLocalPeriods.length; } for (let i = 0; i &lt; maxStreamsInfo; i++) { streams.push(convertPeriodToStreamInfo(voLocalPeriods[i])); } } return streams; } /** * * @param {object} streamInfo * @param {object} mediaInfo * @returns {object} realAdaptation * @memberOf module:DashAdapter * @instance */ function getRealAdaptation(streamInfo, mediaInfo) { let id, realAdaptation; const selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods); id = mediaInfo ? mediaInfo.id : null; if (voPeriods.length &gt; 0 &amp;&amp; selectedVoPeriod) { realAdaptation = id ? dashManifestModel.getAdaptationForId(id, voPeriods[0].mpd.manifest, selectedVoPeriod.index) : dashManifestModel.getAdaptationForIndex(mediaInfo ? mediaInfo.index : null, voPeriods[0].mpd.manifest, selectedVoPeriod.index); } return realAdaptation; } /** * Returns all voRepresentations for a given mediaInfo * @param {object} mediaInfo * @returns {Array} voReps * @memberOf module:DashAdapter * @instance */ function getVoRepresentations(mediaInfo) { let voReps; const voAdaptation = getAdaptationForMediaInfo(mediaInfo); voReps = dashManifestModel.getRepresentationsForAdaptation(voAdaptation); return voReps; } /** * * @param {object} eventBox * @param {Array} eventStreams * @param {number} startTime * @returns {null|Event} * @memberOf module:DashAdapter * @instance * @ignore */ function getEvent(eventBox, eventStreams, startTime) { if (!eventBox || !eventStreams) { return null; } const event = new Event(); const schemeIdUri = eventBox.scheme_id_uri; const value = eventBox.value; const timescale = eventBox.timescale; let presentationTimeDelta; let calculatedPresentationTime; if (eventBox.version === 0) { presentationTimeDelta = eventBox.presentation_time_delta; calculatedPresentationTime = startTime * timescale + presentationTimeDelta; } else { presentationTimeDelta = 0; calculatedPresentationTime = eventBox.presentation_time_delta; } const duration = eventBox.event_duration; const id = eventBox.id; const messageData = eventBox.message_data; if (!eventStreams[schemeIdUri + '/' + value]) return null; event.eventStream = eventStreams[schemeIdUri + '/' + value]; event.eventStream.value = value; event.eventStream.timescale = timescale; event.duration = duration; event.id = id; event.calculatedPresentationTime = calculatedPresentationTime; event.messageData = messageData; event.presentationTimeDelta = presentationTimeDelta; return event; } /** * * @param {object} info * @param {object} voRepresentation * @returns {Array} * @memberOf module:DashAdapter * @instance * @ignore */ function getEventsFor(info, voRepresentation) { let events = []; if (voPeriods.length &gt; 0) { const manifest = voPeriods[0].mpd.manifest; if (info instanceof StreamInfo) { events = dashManifestModel.getEventsForPeriod(getPeriodForStreamInfo(info, voPeriods)); } else if (info instanceof MediaInfo) { events = dashManifestModel.getEventStreamForAdaptationSet(manifest, getAdaptationForMediaInfo(info)); } else if (info instanceof RepresentationInfo) { events = dashManifestModel.getEventStreamForRepresentation(manifest, voRepresentation); } } return events; } /** * * @param {number} streamId * @param {MediaType} type * @param {object} mediaInfo * @memberOf module:DashAdapter * @instance * @ignore */ function setCurrentMediaInfo(streamId, type, mediaInfo) { currentMediaInfo[streamId] = currentMediaInfo[streamId] || {}; currentMediaInfo[streamId][type] = currentMediaInfo[streamId][type] || {}; currentMediaInfo[streamId][type] = mediaInfo; } /** * * @param {String} type * @returns {boolean} * @memberOf module:DashAdapter * @instance * @ignore */ function getIsTextTrack(type) { return dashManifestModel.getIsTextTrack(type); } /** * Returns the UTC Timing Sources specified in the manifest * @returns {Array} utcTimingSources * @memberOf module:DashAdapter * @instance */ function getUTCTimingSources() { const manifest = getManifest(); return dashManifestModel.getUTCTimingSources(manifest); } /** * Returns the suggestedPresentationDelay as specified in the manifest * @returns {String} suggestedPresentationDelay * @memberOf module:DashAdapter * @instance */ function getSuggestedPresentationDelay() { const mpd = voPeriods.length &gt; 0 ? voPeriods[0].mpd : null; return dashManifestModel.getSuggestedPresentationDelay(mpd); } /** * Returns the availabilityStartTime as specified in the manifest * @param {object} externalManifest Omit this value if no external manifest should be used * @returns {string} availabilityStartTime * @memberOf module:DashAdapter * @instance */ function getAvailabilityStartTime(externalManifest) { const mpd = getMpd(externalManifest); return dashManifestModel.getAvailabilityStartTime(mpd); } /** * Returns a boolean indicating if the manifest is dynamic or not * @param {object} externalManifest Omit this value if no external manifest should be used * @returns {boolean} * @memberOf module:DashAdapter * @instance */ function getIsDynamic(externalManifest) { const manifest = getManifest(externalManifest); return dashManifestModel.getIsDynamic(manifest); } /** * Returns the duration of the MPD * @param {object} externalManifest Omit this value if no external manifest should be used * @returns {number} duration * @memberOf module:DashAdapter * @instance */ function getDuration(externalManifest) { const manifest = getManifest(externalManifest); return dashManifestModel.getDuration(manifest); } /** * Returns all periods of the MPD * @param {object} externalManifest Omit this value if no external manifest should be used * @returns {Array} periods * @memberOf module:DashAdapter * @instance */ function getRegularPeriods(externalManifest) { const mpd = getMpd(externalManifest); return dashManifestModel.getRegularPeriods(mpd); } /** * Returns an MPD object * @param {object} externalManifest Omit this value if no external manifest should be used * @returns {object} MPD * @memberOf module:DashAdapter * @instance */ function getMpd(externalManifest) { const manifest = getManifest(externalManifest); return dashManifestModel.getMpd(manifest); } /** * Returns the location element of the MPD * @param {object} manifest * @returns {String} location * @memberOf module:DashAdapter * @instance */ function getLocation(manifest) { return dashManifestModel.getLocation(manifest); } /** * Returns the manifest update period used for dynamic manifests * @param {object} manifest * @param {number} latencyOfLastUpdate * @returns {NaN|number} manifestUpdatePeriod * @memberOf module:DashAdapter * @instance */ function getManifestUpdatePeriod(manifest, latencyOfLastUpdate = 0) { return dashManifestModel.getManifestUpdatePeriod(manifest, latencyOfLastUpdate); } /** * Checks if the manifest has a DVB profile * @param {object} manifest * @returns {boolean} * @memberOf module:DashAdapter * @instance * @ignore */ function getIsDVB(manifest) { return dashManifestModel.hasProfile(manifest, PROFILE_DVB); } /** * * @param {object} node * @returns {Array} * @memberOf module:DashAdapter * @instance * @ignore */ function getBaseURLsFromElement(node) { return dashManifestModel.getBaseURLsFromElement(node); } /** * * @returns {*} * @memberOf module:DashAdapter * @instance * @ignore */ function getRepresentationSortFunction() { return dashManifestModel.getRepresentationSortFunction(); } /** * Returns the codec for a given adaptation set and a given representation id. * @param {object} adaptation * @param {number} representationId * @param {boolean} addResolutionInfo Defines whether to include resolution information in the output * @returns {String} codec * @memberOf module:DashAdapter * @instance */ function getCodec(adaptation, representationId, addResolutionInfo) { return dashManifestModel.getCodec(adaptation, representationId, addResolutionInfo); } /** * Returns the bandwidth for a given representation id * @param {number} representationId * @param {number} periodIdx * @returns {number} bandwidth * @memberOf module:DashAdapter * @instance */ function getBandwidthForRepresentation(representationId, periodIdx) { let representation; let period = getPeriod(periodIdx); representation = findRepresentation(period, representationId); return representation ? representation.bandwidth : null; } /** * Returns the index for a given representation id * @param {string} representationId * @param {number} periodIdx * @returns {number} index * @memberOf module:DashAdapter * @instance */ function getIndexForRepresentation(representationId, periodIdx) { let period = getPeriod(periodIdx); return findRepresentationIndex(period, representationId); } /** * This method returns the current max index based on what is defined in the MPD. * * @param {string} bufferType - String 'audio' or 'video', * @param {number} periodIdx - Make sure this is the period index not id * @return {number} * @memberof module:DashAdapter * @instance */ function getMaxIndexForBufferType(bufferType, periodIdx) { let period = getPeriod(periodIdx); return findMaxBufferIndex(period, bufferType); } /** * Returns the voPeriod object for a given id * @param {String} id * @returns {object|null} */ function getPeriodById(id) { if (!id || voPeriods.length === 0) { return null; } const periods = voPeriods.filter((p) =&gt; { return p.id === id; }); if (periods &amp;&amp; periods.length &gt; 0) { return periods[0]; } return null; } function reset() { voPeriods = []; voAdaptations = {}; currentMediaInfo = {}; } // #endregion PUBLIC FUNCTIONS // #region PRIVATE FUNCTIONS // -------------------------------------------------- function getManifest(externalManifest) { return externalManifest ? externalManifest : voPeriods.length &gt; 0 ? voPeriods[0].mpd.manifest : null; } function getAdaptationForMediaInfo(mediaInfo) { if (!mediaInfo || !mediaInfo.streamInfo || mediaInfo.streamInfo.id === undefined || !voAdaptations[mediaInfo.streamInfo.id]) return null; return voAdaptations[mediaInfo.streamInfo.id][mediaInfo.index]; } function getPeriodForStreamInfo(streamInfo, voPeriodsArray) { const ln = voPeriodsArray.length; for (let i = 0; i &lt; ln; i++) { let voPeriod = voPeriodsArray[i]; if (streamInfo &amp;&amp; streamInfo.id === voPeriod.id) return voPeriod; } return null; } function convertAdaptationToMediaInfo(adaptation) { if (!adaptation) { return null; } let mediaInfo = new MediaInfo(); const realAdaptation = adaptation.period.mpd.manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index]; let viewpoint; mediaInfo.id = adaptation.id; mediaInfo.index = adaptation.index; mediaInfo.type = adaptation.type; mediaInfo.streamInfo = convertPeriodToStreamInfo(adaptation.period); mediaInfo.representationCount = dashManifestModel.getRepresentationCount(realAdaptation); mediaInfo.labels = dashManifestModel.getLabelsForAdaptation(realAdaptation); mediaInfo.lang = dashManifestModel.getLanguageForAdaptation(realAdaptation); viewpoint = dashManifestModel.getViewpointForAdaptation(realAdaptation); mediaInfo.viewpoint = viewpoint ? viewpoint.value : undefined; mediaInfo.accessibility = dashManifestModel.getAccessibilityForAdaptation(realAdaptation).map(function (accessibility) { let accessibilityValue = accessibility.value; let accessibilityData = accessibilityValue; if (accessibility.schemeIdUri &amp;&amp; (accessibility.schemeIdUri.search('cea-608') &gt;= 0) &amp;&amp; typeof (cea608parser) !== 'undefined') { if (accessibilityValue) { accessibilityData = 'cea-608:' + accessibilityValue; } else { accessibilityData = 'cea-608'; } mediaInfo.embeddedCaptions = true; } return accessibilityData; }); mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForAdaptation(realAdaptation).map(function (audioChannelConfiguration) { return audioChannelConfiguration.value; }); if (mediaInfo.audioChannelConfiguration.length === 0 &amp;&amp; Array.isArray(realAdaptation.Representation_asArray) &amp;&amp; realAdaptation.Representation_asArray.length &gt; 0) { mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForRepresentation(realAdaptation.Representation_asArray[0]).map(function (audioChannelConfiguration) { return audioChannelConfiguration.value; }); } mediaInfo.roles = dashManifestModel.getRolesForAdaptation(realAdaptation).map(function (role) { return role.value; }); mediaInfo.codec = dashManifestModel.getCodec(realAdaptation); mediaInfo.mimeType = dashManifestModel.getMimeType(realAdaptation); mediaInfo.contentProtection = dashManifestModel.getContentProtectionData(realAdaptation); mediaInfo.bitrateList = dashManifestModel.getBitrateListForAdaptation(realAdaptation); if (mediaInfo.contentProtection) { mediaInfo.contentProtection.forEach(function (item) { item.KID = dashManifestModel.getKID(item); }); } mediaInfo.isText = dashManifestModel.getIsTextTrack(mediaInfo.mimeType); mediaInfo.supplementalProperties = dashManifestModel.getSupplementalPropperties(realAdaptation); return mediaInfo; } function convertVideoInfoToEmbeddedTextInfo(mediaInfo, channel, lang) { mediaInfo.id = channel; // CC1, CC2, CC3, or CC4 mediaInfo.index = 100 + parseInt(channel.substring(2, 3)); mediaInfo.type = constants.EMBEDDED_TEXT; mediaInfo.codec = 'cea-608-in-SEI'; mediaInfo.isText = true; mediaInfo.isEmbedded = true; mediaInfo.lang = lang; mediaInfo.roles = ['caption']; } function convertVideoInfoToThumbnailInfo(mediaInfo) { mediaInfo.type = constants.IMAGE; } function convertPeriodToStreamInfo(period) { let streamInfo = new StreamInfo(); const THRESHOLD = 1; streamInfo.id = period.id; streamInfo.index = period.index; streamInfo.start = period.start; streamInfo.duration = period.duration; streamInfo.manifestInfo = convertMpdToManifestInfo(period.mpd); streamInfo.isLast = period.mpd.manifest.Period_asArray.length === 1 || Math.abs((streamInfo.start + streamInfo.duration) - streamInfo.manifestInfo.duration) &lt; THRESHOLD; return streamInfo; } function convertMpdToManifestInfo(mpd) { let manifestInfo = new ManifestInfo(); manifestInfo.DVRWindowSize = mpd.timeShiftBufferDepth; manifestInfo.loadedTime = mpd.manifest.loadedTime; manifestInfo.availableFrom = mpd.availabilityStartTime; manifestInfo.minBufferTime = mpd.manifest.minBufferTime; manifestInfo.maxFragmentDuration = mpd.maxSegmentDuration; manifestInfo.duration = dashManifestModel.getDuration(mpd.manifest); manifestInfo.isDynamic = dashManifestModel.getIsDynamic(mpd.manifest); manifestInfo.serviceDescriptions = dashManifestModel.getServiceDescriptions(mpd.manifest); manifestInfo.protocol = mpd.manifest.protocol; return manifestInfo; } function checkConfig() { if (!constants) { throw new Error('setConfig function has to be called previously'); } } function getPeriod(periodIdx) { return voPeriods.length &gt; 0 ? voPeriods[0].mpd.manifest.Period_asArray[periodIdx] : null; } function findRepresentationIndex(period, representationId) { const index = findRepresentation(period, representationId, true); return index !== null ? index : -1; } function findRepresentation(period, representationId, returnIndex) { let adaptationSet, adaptationSetArray, representation, representationArray, adaptationSetArrayIndex, representationArrayIndex; if (period) { adaptationSetArray = period.AdaptationSet_asArray; for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex &lt; adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) { adaptationSet = adaptationSetArray[adaptationSetArrayIndex]; representationArray = adaptationSet.Representation_asArray; for (representationArrayIndex = 0; representationArrayIndex &lt; representationArray.length; representationArrayIndex = representationArrayIndex + 1) { representation = representationArray[representationArrayIndex]; if (representationId === representation.id) { if (returnIndex) { return representationArrayIndex; } else { return representation; } } } } } return null; } function findMaxBufferIndex(period, bufferType) { let adaptationSet, adaptationSetArray, representationArray, adaptationSetArrayIndex; if (!period || !bufferType) return -1; adaptationSetArray = period.AdaptationSet_asArray; for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex &lt; adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) { adaptationSet = adaptationSetArray[adaptationSetArrayIndex]; representationArray = adaptationSet.Representation_asArray; if (dashManifestModel.getIsTypeOf(adaptationSet, bufferType)) { return representationArray.length; } } return -1; } // #endregion PRIVATE FUNCTIONS instance = { getBandwidthForRepresentation: getBandwidthForRepresentation, getIndexForRepresentation: getIndexForRepresentation, getMaxIndexForBufferType: getMaxIndexForBufferType, convertDataToRepresentationInfo: convertRepresentationToRepresentationInfo, getDataForMedia: getAdaptationForMediaInfo, getStreamsInfo: getStreamsInfo, getMediaInfoForType: getMediaInfoForType, getAllMediaInfoForType: getAllMediaInfoForType, getAdaptationForType: getAdaptationForType, getRealAdaptation: getRealAdaptation, getVoRepresentations: getVoRepresentations, getEventsFor: getEventsFor, getEvent: getEvent, getMpd, setConfig: setConfig, updatePeriods: updatePeriods, getIsTextTrack: getIsTextTrack, getUTCTimingSources: getUTCTimingSources, getSuggestedPresentationDelay: getSuggestedPresentationDelay, getAvailabilityStartTime: getAvailabilityStartTime, getIsDynamic: getIsDynamic, getDuration: getDuration, getRegularPeriods: getRegularPeriods, getLocation: getLocation, getManifestUpdatePeriod: getManifestUpdatePeriod, getIsDVB: getIsDVB, getBaseURLsFromElement: getBaseURLsFromElement, getRepresentationSortFunction: getRepresentationSortFunction, getCodec: getCodec, getVoAdaptations: getVoAdaptations, getVoPeriods: getVoPeriods, getPeriodById, setCurrentMediaInfo: setCurrentMediaInfo, reset: reset }; setup(); return instance; } DashAdapter.__dashjs_factory_name = 'DashAdapter'; export default FactoryMaker.getSingletonFactory(DashAdapter); × Search results Close "},"dash_DashMetrics.js.html":{"id":"dash_DashMetrics.js.html","title":"Source: dash/DashMetrics.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: dash/DashMetrics.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../streaming/constants/Constants'; import { HTTPRequest } from '../streaming/vo/metrics/HTTPRequest'; import FactoryMaker from '../core/FactoryMaker'; import MetricsConstants from '../streaming/constants/MetricsConstants'; import Round10 from './utils/Round10'; import MetricsModel from '../streaming/models/MetricsModel'; import { PlayList, PlayListTrace } from '../streaming/vo/metrics/PlayList'; /** * @module DashMetrics * @param {object} config */ function DashMetrics(config) { config = config || {}; const context = this.context; let instance, playListTraceMetricsClosed, playListTraceMetrics, playListMetrics; let metricsModel = config.metricsModel; function setup() { metricsModel = metricsModel || MetricsModel(context).getInstance({settings: config.settings}); resetInitialSettings(); } function resetInitialSettings() { playListTraceMetricsClosed = true; playListTraceMetrics = null; playListMetrics = null; } /** * @param {MediaType} mediaType * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentRepresentationSwitch(mediaType) { const metrics = metricsModel.getMetricsFor(mediaType, true); return getCurrent(metrics, MetricsConstants.TRACK_SWITCH); } /** * @param {MediaType} mediaType * @param {Date} t time of the switch event * @param {Date} mt media presentation time * @param {string} to id of representation * @param {string} lto if present, subrepresentation reference * @memberof module:DashMetrics * @instance * @ignore */ function addRepresentationSwitch(mediaType, t, mt, to, lto) { metricsModel.addRepresentationSwitch(mediaType, t, mt, to, lto); } /** * @param {MediaType} type * @returns {number} * @memberof module:DashMetrics * @instance */ function getCurrentBufferState(type) { const metrics = metricsModel.getMetricsFor(type, true); return getCurrent(metrics, MetricsConstants.BUFFER_STATE); } /** * @param {MediaType} type * @returns {number} * @memberof module:DashMetrics * @instance */ function getCurrentBufferLevel(type) { const metrics = metricsModel.getMetricsFor(type, true); const metric = getCurrent(metrics, MetricsConstants.BUFFER_LEVEL); if (metric) { return Round10.round10(metric.level / 1000, -3); } return 0; } /** * @param {MediaType} mediaType * @param {number} t * @param {number} level * @memberof module:DashMetrics * @instance * @ignore */ function addBufferLevel(mediaType, t, level) { metricsModel.addBufferLevel(mediaType, t, level); } /** * @param {MediaType} mediaType * @param {string} state * @param {number} target * @memberof module:DashMetrics * @instance * @ignore */ function addBufferState(mediaType, state, target) { metricsModel.addBufferState(mediaType, state, target); } /** * @memberof module:DashMetrics * @instance * @ignore */ function clearAllCurrentMetrics () { metricsModel.clearAllCurrentMetrics(); } /** * @param {MediaType} mediaType * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentHttpRequest(mediaType) { const metrics = metricsModel.getMetricsFor(mediaType, true); if (!metrics) { return null; } const httpList = metrics.HttpList; let currentHttpList = null; let httpListLastIndex; if (!httpList || httpList.length &lt;= 0) { return null; } httpListLastIndex = httpList.length - 1; while (httpListLastIndex &gt;= 0) { if (httpList[httpListLastIndex].responsecode) { currentHttpList = httpList[httpListLastIndex]; break; } httpListLastIndex--; } return currentHttpList; } /** * @param {MediaType} mediaType * @returns {*} * @memberof module:DashMetrics * @instance */ function getHttpRequests(mediaType) { const metrics = metricsModel.getMetricsFor(mediaType, true); if (!metrics) { return []; } return !!metrics.HttpList ? metrics.HttpList : []; } /** * @param {MediaType} mediaType * @param {Array} loadingRequests * @param {Array} executedRequests * @memberof module:DashMetrics * @instance * @ignore */ function addRequestsQueue(mediaType, loadingRequests, executedRequests) { metricsModel.addRequestsQueue(mediaType, loadingRequests, executedRequests); } /** * @param {MetricsList} metrics * @param {string} metricName * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrent(metrics, metricName) { if (!metrics) { return null; } const list = metrics[metricName]; return (!list || list.length === 0) ? null : list[list.length - 1]; } /** * @returns {*} * @memberof module:DashMetrics * @instance * @ignore */ function getCurrentDroppedFrames() { const metrics = metricsModel.getMetricsFor(Constants.VIDEO, true); return getCurrent(metrics, MetricsConstants.DROPPED_FRAMES); } /** * @param {number} quality * @memberof module:DashMetrics * @instance * @ignore */ function addDroppedFrames(quality) { metricsModel.addDroppedFrames(Constants.VIDEO, quality); } /** * @param {MediaType} mediaType * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentSchedulingInfo(mediaType) { const metrics = metricsModel.getMetricsFor(mediaType, true); return getCurrent(metrics, MetricsConstants.SCHEDULING_INFO); } /** * @param {object} request * @param {string} state * @memberof module:DashMetrics * @instance * @ignore */ function addSchedulingInfo(request, state) { metricsModel.addSchedulingInfo( request.mediaType, new Date(), request.type, request.startTime, request.availabilityStartTime, request.duration, request.quality, request.range, state); } /** * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentManifestUpdate() { const streamMetrics = metricsModel.getMetricsFor(Constants.STREAM); return getCurrent(streamMetrics, MetricsConstants.MANIFEST_UPDATE); } /** * @param {object} updatedFields fields to be updated * @memberof module:DashMetrics * @instance * @ignore */ function updateManifestUpdateInfo(updatedFields) { const manifestUpdate = this.getCurrentManifestUpdate(); metricsModel.updateManifestUpdateInfo(manifestUpdate, updatedFields); } /** * @param {object} streamInfo * @memberof module:DashMetrics * @instance * @ignore */ function addManifestUpdateStreamInfo(streamInfo) { if (streamInfo) { const manifestUpdate = this.getCurrentManifestUpdate(); metricsModel.addManifestUpdateStreamInfo(manifestUpdate, streamInfo.id, streamInfo.index, streamInfo.start, streamInfo.duration); } } /** * @param {object} request * @memberof module:DashMetrics * @instance * @ignore */ function addManifestUpdate(request) { metricsModel.addManifestUpdate(Constants.STREAM, request.type, request.requestStartDate, request.requestEndDate); } /** * @param {object} request * @param {string} responseURL * @param {number} responseStatus * @param {object} responseHeaders * @param {object} traces * @memberof module:DashMetrics * @instance * @ignore */ function addHttpRequest(request, responseURL, responseStatus, responseHeaders, traces) { metricsModel.addHttpRequest(request.mediaType, null, request.type, request.url, request.quality, responseURL, request.serviceLocation || null, request.range || null, request.requestStartDate, request.firstByteDate, request.requestEndDate, responseStatus, request.duration, responseHeaders, traces); } /** * @param {object} representation * @param {MediaType} mediaType * @memberof module:DashMetrics * @instance * @ignore */ function addManifestUpdateRepresentationInfo(representation, mediaType) { if (representation) { const manifestUpdateInfo = this.getCurrentManifestUpdate(); metricsModel.addManifestUpdateRepresentationInfo(manifestUpdateInfo, representation.id, representation.index, representation.streamIndex, mediaType, representation.presentationTimeOffset, representation.startNumber, representation.fragmentInfoType); } } /** * @param {MediaType} mediaType * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentDVRInfo(mediaType) { const metrics = mediaType ? metricsModel.getMetricsFor(mediaType, true) : metricsModel.getMetricsFor(Constants.VIDEO, true) || metricsModel.getMetricsFor(Constants.AUDIO, true); return getCurrent(metrics, MetricsConstants.DVR_INFO); } /** * @param {MediaType} mediaType * @param {Date} currentTime time of the switch event * @param {object} mpd mpd reference * @param {object} range range of the dvr info * @memberof module:DashMetrics * @instance * @ignore */ function addDVRInfo(mediaType, currentTime, mpd, range) { metricsModel.addDVRInfo(mediaType, currentTime, mpd, range); } /** * @param {string} id * @returns {*} * @memberof module:DashMetrics * @instance */ function getLatestMPDRequestHeaderValueByID(id) { let headers = {}; let httpRequestList, httpRequest, i; httpRequestList = getHttpRequests(Constants.STREAM); for (i = httpRequestList.length - 1; i &gt;= 0; i--) { httpRequest = httpRequestList[i]; if (httpRequest.type === HTTPRequest.MPD_TYPE) { headers = parseResponseHeaders(httpRequest._responseHeaders); break; } } return headers[id] === undefined ? null : headers[id]; } /** * @param {string} type * @param {string} id * @returns {*} * @memberof module:DashMetrics * @instance */ function getLatestFragmentRequestHeaderValueByID(type, id) { let headers = {}; let httpRequest = getCurrentHttpRequest(type, true); if (httpRequest) { headers = parseResponseHeaders(httpRequest._responseHeaders); } return headers[id] === undefined ? null : headers[id]; } function parseResponseHeaders(headerStr) { let headers = {}; if (!headerStr) { return headers; } // Trim headerStr to fix a MS Edge bug with xhr.getAllResponseHeaders method // which send a string starting with a \"\\n\" character let headerPairs = headerStr.trim().split('\\u000d\\u000a'); for (let i = 0, ilen = headerPairs.length; i &lt; ilen; i++) { let headerPair = headerPairs[i]; let index = headerPair.indexOf('\\u003a\\u0020'); if (index &gt; 0) { headers[headerPair.substring(0, index)] = headerPair.substring(index + 2); } } return headers; } /** * @memberof module:DashMetrics * @instance * @ignore */ function addPlayList() { if (playListMetrics) { metricsModel.addPlayList(playListMetrics); playListMetrics = null; } } function createPlaylistMetrics(mediaStartTime, startReason) { playListMetrics = new PlayList(); playListMetrics.start = new Date(); playListMetrics.mstart = mediaStartTime; playListMetrics.starttype = startReason; } function createPlaylistTraceMetrics(representationId, mediaStartTime, speed) { if (playListTraceMetricsClosed === true ) { playListTraceMetricsClosed = false; playListTraceMetrics = new PlayListTrace(); playListTraceMetrics.representationid = representationId; playListTraceMetrics.start = new Date(); playListTraceMetrics.mstart = mediaStartTime; playListTraceMetrics.playbackspeed = speed !== null ? speed.toString() : null; } } function updatePlayListTraceMetrics(traceToUpdate) { if (playListTraceMetrics) { for (let field in playListTraceMetrics) { playListTraceMetrics[field] = traceToUpdate[field]; } } } function pushPlayListTraceMetrics(endTime, reason) { if (playListTraceMetricsClosed === false &amp;&amp; playListMetrics &amp;&amp; playListTraceMetrics &amp;&amp; playListTraceMetrics.start) { const startTime = playListTraceMetrics.start; const duration = endTime.getTime() - startTime.getTime(); playListTraceMetrics.duration = duration; playListTraceMetrics.stopreason = reason; playListMetrics.trace.push(playListTraceMetrics); playListTraceMetricsClosed = true; } } /** * @param {object} errors * @memberof module:DashMetrics * @instance * @ignore */ function addDVBErrors(errors) { metricsModel.addDVBErrors(errors); } instance = { getCurrentRepresentationSwitch: getCurrentRepresentationSwitch, getCurrentBufferState: getCurrentBufferState, getCurrentBufferLevel: getCurrentBufferLevel, getCurrentHttpRequest: getCurrentHttpRequest, getHttpRequests: getHttpRequests, getCurrentDroppedFrames: getCurrentDroppedFrames, getCurrentSchedulingInfo: getCurrentSchedulingInfo, getCurrentDVRInfo: getCurrentDVRInfo, getCurrentManifestUpdate: getCurrentManifestUpdate, getLatestFragmentRequestHeaderValueByID: getLatestFragmentRequestHeaderValueByID, getLatestMPDRequestHeaderValueByID: getLatestMPDRequestHeaderValueByID, addRepresentationSwitch: addRepresentationSwitch, addDVRInfo: addDVRInfo, updateManifestUpdateInfo: updateManifestUpdateInfo, addManifestUpdateStreamInfo: addManifestUpdateStreamInfo, addManifestUpdateRepresentationInfo: addManifestUpdateRepresentationInfo, addManifestUpdate: addManifestUpdate, addHttpRequest: addHttpRequest, addSchedulingInfo: addSchedulingInfo, addRequestsQueue: addRequestsQueue, addBufferLevel: addBufferLevel, addBufferState: addBufferState, addDroppedFrames: addDroppedFrames, addPlayList: addPlayList, addDVBErrors: addDVBErrors, createPlaylistMetrics: createPlaylistMetrics, createPlaylistTraceMetrics: createPlaylistTraceMetrics, updatePlayListTraceMetrics: updatePlayListTraceMetrics, pushPlayListTraceMetrics: pushPlayListTraceMetrics, clearAllCurrentMetrics: clearAllCurrentMetrics }; setup(); return instance; } DashMetrics.__dashjs_factory_name = 'DashMetrics'; export default FactoryMaker.getSingletonFactory(DashMetrics); × Search results Close "},"core_Debug.js.html":{"id":"core_Debug.js.html","title":"Source: core/Debug.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: core/Debug.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import EventBus from './EventBus'; import Events from './events/Events'; import FactoryMaker from './FactoryMaker'; const LOG_LEVEL_NONE = 0; const LOG_LEVEL_FATAL = 1; const LOG_LEVEL_ERROR = 2; const LOG_LEVEL_WARNING = 3; const LOG_LEVEL_INFO = 4; const LOG_LEVEL_DEBUG = 5; /** * @module Debug * @param {object} config * @ignore */ function Debug(config) { config = config || {}; const context = this.context; const eventBus = EventBus(context).getInstance(); const settings = config.settings; const logFn = []; let instance, showLogTimestamp, showCalleeName, startTime; function setup() { showLogTimestamp = true; showCalleeName = true; startTime = new Date().getTime(); if (typeof window !== 'undefined' &amp;&amp; window.console) { logFn[LOG_LEVEL_FATAL] = getLogFn(window.console.error); logFn[LOG_LEVEL_ERROR] = getLogFn(window.console.error); logFn[LOG_LEVEL_WARNING] = getLogFn(window.console.warn); logFn[LOG_LEVEL_INFO] = getLogFn(window.console.info); logFn[LOG_LEVEL_DEBUG] = getLogFn(window.console.debug); } } function getLogFn(fn) { if (fn &amp;&amp; fn.bind) { return fn.bind(window.console); } // if not define, return the default function for reporting logs return window.console.log.bind(window.console); } /** * Retrieves a logger which can be used to write logging information in browser console. * @param {object} instance Object for which the logger is created. It is used * to include calle object information in log messages. * @memberof module:Debug * @returns {Logger} * @instance */ function getLogger(instance) { return { fatal: fatal.bind(instance), error: error.bind(instance), warn: warn.bind(instance), info: info.bind(instance), debug: debug.bind(instance) }; } /** * Prepends a timestamp in milliseconds to each log message. * @param {boolean} value Set to true if you want to see a timestamp in each log message. * @default LOG_LEVEL_WARNING * @memberof module:Debug * @instance */ function setLogTimestampVisible(value) { showLogTimestamp = value; } /** * Prepends the callee object name, and media type if available, to each log message. * @param {boolean} value Set to true if you want to see the callee object name and media type in each log message. * @default true * @memberof module:Debug * @instance */ function setCalleeNameVisible(value) { showCalleeName = value; } function fatal(...params) { doLog(LOG_LEVEL_FATAL, this, ...params); } function error(...params) { doLog(LOG_LEVEL_ERROR, this, ...params); } function warn(...params) { doLog(LOG_LEVEL_WARNING, this, ...params); } function info(...params) { doLog(LOG_LEVEL_INFO, this, ...params); } function debug(...params) { doLog(LOG_LEVEL_DEBUG, this, ...params); } function doLog(level, _this, ...params) { let message = ''; let logTime = null; if (showLogTimestamp) { logTime = new Date().getTime(); message += '[' + (logTime - startTime) + ']'; } if (showCalleeName &amp;&amp; _this &amp;&amp; _this.getClassName) { message += '[' + _this.getClassName() + ']'; if (_this.getType) { message += '[' + _this.getType() + ']'; } } if (message.length &gt; 0) { message += ' '; } Array.apply(null, params).forEach(function (item) { message += item + ' '; }); // log to console if the log level is high enough if (logFn[level] &amp;&amp; settings.get().debug.logLevel &gt;= level) { logFn[level](message); } // send log event regardless of log level eventBus.trigger(Events.LOG, {message: message, level: level}); } instance = { getLogger: getLogger, setLogTimestampVisible: setLogTimestampVisible, setCalleeNameVisible: setCalleeNameVisible }; setup(); return instance; } Debug.__dashjs_factory_name = 'Debug'; const factory = FactoryMaker.getSingletonFactory(Debug); factory.LOG_LEVEL_NONE = LOG_LEVEL_NONE; factory.LOG_LEVEL_FATAL = LOG_LEVEL_FATAL; factory.LOG_LEVEL_ERROR = LOG_LEVEL_ERROR; factory.LOG_LEVEL_WARNING = LOG_LEVEL_WARNING; factory.LOG_LEVEL_INFO = LOG_LEVEL_INFO; factory.LOG_LEVEL_DEBUG = LOG_LEVEL_DEBUG; FactoryMaker.updateSingletonFactory(Debug.__dashjs_factory_name, factory); export default factory; × Search results Close "},"streaming_utils_DefaultURLUtils.js.html":{"id":"streaming_utils_DefaultURLUtils.js.html","title":"Source: streaming/utils/DefaultURLUtils.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/DefaultURLUtils.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; /** * @module DefaultURLUtils * @description Provides utility functions for operating on URLs. * Initially this is simply a method to determine the Base URL of a URL, but * should probably include other things provided all over the place such as * determining whether a URL is relative/absolute, resolving two paths etc. * @ignore */ function DefaultURLUtils() { let resolveFunction; const schemeRegex = /^[a-z][a-z0-9+\\-_.]*:/i; const httpUrlRegex = /^https?:\\/\\//i; const httpsUrlRegex = /^https:\\/\\//i; const originRegex = /^([a-z][a-z0-9+\\-_.]*:\\/\\/[^\\/]+)\\/?/i; /** * Resolves a url given an optional base url * Uses window.URL to do the resolution. * * @param {string} url * @param {string} [baseUrl] * @return {string} * @memberof module:DefaultURLUtils * @instance * @private */ const nativeURLResolver = (url, baseUrl) =&gt; { try { return new window.URL(url, baseUrl).toString(); } catch (e) { return url; } }; /** * Resolves a url given an optional base url * Does not resolve ./, ../ etc but will do enough to construct something * which will satisfy XHR etc when window.URL is not available ie * IE11/node etc. * * @param {string} url * @param {string} [baseUrl] * @return {string} * @memberof module:DefaultURLUtils * @instance * @private */ const dumbURLResolver = (url, baseUrl) =&gt; { let baseUrlParseFunc = parseBaseUrl; if (!baseUrl) { return url; } if (!isRelative(url)) { return url; } if (isPathAbsolute(url)) { baseUrlParseFunc = parseOrigin; } if (isSchemeRelative(url)) { baseUrlParseFunc = parseScheme; } const base = baseUrlParseFunc(baseUrl); const joinChar = base.charAt(base.length - 1) !== '/' &amp;&amp; url.charAt(0) !== '/' ? '/' : ''; return [base, url].join(joinChar); }; function setup() { try { const u = new window.URL('x', 'http://y'); //jshint ignore:line resolveFunction = nativeURLResolver; } catch (e) { // must be IE11/Node etc } finally { resolveFunction = resolveFunction || dumbURLResolver; } } /** * Returns a string that contains the Base URL of a URL, if determinable. * @param {string} url - full url * @return {string} * @memberof module:DefaultURLUtils * @instance */ function parseBaseUrl(url) { const slashIndex = url.indexOf('/'); const lastSlashIndex = url.lastIndexOf('/'); if (slashIndex !== -1) { // if there is only '//' if (lastSlashIndex === slashIndex + 1) { return url; } if (url.indexOf('?') !== -1) { url = url.substring(0, url.indexOf('?')); } return url.substring(0, lastSlashIndex + 1); } return ''; } /** * Returns a string that contains the scheme and origin of a URL, * if determinable. * @param {string} url - full url * @return {string} * @memberof module:DefaultURLUtils * @instance */ function parseOrigin(url) { const matches = url.match(originRegex); if (matches) { return matches[1]; } return ''; } /** * Returns a string that contains the fragment of a URL without scheme, * if determinable. * @param {string} url - full url * @return {string} * @memberof module:DefaultURLUtils * @instance */ function removeHostname(url) { let urlParts = /^(?:\\w+\\:\\/\\/)?([^\\/]+)(.*)$/.exec(url); //[1] = host / [2] = path return urlParts[2].substring(1); } /** * Returns a string that contains the scheme of a URL, if determinable. * @param {string} url - full url * @return {string} * @memberof module:DefaultURLUtils * @instance */ function parseScheme(url) { const matches = url.match(schemeRegex); if (matches) { return matches[0]; } return ''; } /** * Determines whether the url is relative. * @return {boolean} * @param {string} url * @memberof module:DefaultURLUtils * @instance */ function isRelative(url) { return !schemeRegex.test(url); } /** * Determines whether the url is path-absolute. * @return {bool} * @param {string} url * @memberof module:DefaultURLUtils * @instance */ function isPathAbsolute(url) { return isRelative(url) &amp;&amp; url.charAt(0) === '/'; } /** * Determines whether the url is scheme-relative. * @return {bool} * @param {string} url * @memberof module:DefaultURLUtils * @instance */ function isSchemeRelative(url) { return url.indexOf('//') === 0; } /** * Determines whether the url is an HTTP-URL as defined in ISO/IEC * 23009-1:2014 3.1.15. ie URL with a fixed scheme of http or https * @return {bool} * @param {string} url * @memberof module:DefaultURLUtils * @instance */ function isHTTPURL(url) { return httpUrlRegex.test(url); } /** * Determines whether the supplied url has https scheme * @return {bool} * @param {string} url * @memberof module:DefaultURLUtils * @instance */ function isHTTPS(url) { return httpsUrlRegex.test(url); } /** * Resolves a url given an optional base url * @return {string} * @param {string} url * @param {string} [baseUrl] * @memberof module:DefaultURLUtils * @instance */ function resolve(url, baseUrl) { return resolveFunction(url, baseUrl); } setup(); const instance = { parseBaseUrl: parseBaseUrl, parseOrigin: parseOrigin, parseScheme: parseScheme, isRelative: isRelative, isPathAbsolute: isPathAbsolute, isSchemeRelative: isSchemeRelative, isHTTPURL: isHTTPURL, isHTTPS: isHTTPS, removeHostname: removeHostname, resolve: resolve }; return instance; } DefaultURLUtils.__dashjs_factory_name = 'DefaultURLUtils'; export default FactoryMaker.getSingletonFactory(DefaultURLUtils); × Search results Close "},"streaming_utils_ErrorHandler.js.html":{"id":"streaming_utils_ErrorHandler.js.html","title":"Source: streaming/utils/ErrorHandler.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/ErrorHandler.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; /** * @module ErrorHandler * @ignore */ function ErrorHandler() { let instance; const context = this.context; const eventBus = EventBus(context).getInstance(); /** * @param {object} err DashJSError with code, message and data attributes * @memberof module:ErrorHandler */ function error(err) { eventBus.trigger(Events.ERROR, {error: err}); } instance = { error: error }; return instance; } ErrorHandler.__dashjs_factory_name = 'ErrorHandler'; export default FactoryMaker.getSingletonFactory(ErrorHandler); × Search results Close "},"core_FactoryMaker.js.html":{"id":"core_FactoryMaker.js.html","title":"Source: core/FactoryMaker.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: core/FactoryMaker.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @module FactoryMaker * @ignore */ const FactoryMaker = (function () { let instance; const singletonContexts = []; const singletonFactories = {}; const classFactories = {}; function extend(name, childInstance, override, context) { if (!context[name] &amp;&amp; childInstance) { context[name] = { instance: childInstance, override: override }; } } /** * Use this method from your extended object. this.factory is injected into your object. * this.factory.getSingletonInstance(this.context, 'VideoModel') * will return the video model for use in the extended object. * * @param {Object} context - injected into extended object as this.context * @param {string} className - string name found in all dash.js objects * with name __dashjs_factory_name Will be at the bottom. Will be the same as the object's name. * @returns {*} Context aware instance of specified singleton name. * @memberof module:FactoryMaker * @instance */ function getSingletonInstance(context, className) { for (const i in singletonContexts) { const obj = singletonContexts[i]; if (obj.context === context &amp;&amp; obj.name === className) { return obj.instance; } } return null; } /** * Use this method to add an singleton instance to the system. Useful for unit testing to mock objects etc. * * @param {Object} context * @param {string} className * @param {Object} instance * @memberof module:FactoryMaker * @instance */ function setSingletonInstance(context, className, instance) { for (const i in singletonContexts) { const obj = singletonContexts[i]; if (obj.context === context &amp;&amp; obj.name === className) { singletonContexts[i].instance = instance; return; } } singletonContexts.push({ name: className, context: context, instance: instance }); } /*------------------------------------------------------------------------------------------*/ // Factories storage Management /*------------------------------------------------------------------------------------------*/ function getFactoryByName(name, factoriesArray) { return factoriesArray[name]; } function updateFactory(name, factory, factoriesArray) { if (name in factoriesArray) { factoriesArray[name] = factory; } } /*------------------------------------------------------------------------------------------*/ // Class Factories Management /*------------------------------------------------------------------------------------------*/ function updateClassFactory(name, factory) { updateFactory(name, factory, classFactories); } function getClassFactoryByName(name) { return getFactoryByName(name, classFactories); } function getClassFactory(classConstructor) { let factory = getFactoryByName(classConstructor.__dashjs_factory_name, classFactories); if (!factory) { factory = function (context) { if (context === undefined) { context = {}; } return { create: function () { return merge(classConstructor, context, arguments); } }; }; classFactories[classConstructor.__dashjs_factory_name] = factory; // store factory } return factory; } /*------------------------------------------------------------------------------------------*/ // Singleton Factory MAangement /*------------------------------------------------------------------------------------------*/ function updateSingletonFactory(name, factory) { updateFactory(name, factory, singletonFactories); } function getSingletonFactoryByName(name) { return getFactoryByName(name, singletonFactories); } function getSingletonFactory(classConstructor) { let factory = getFactoryByName(classConstructor.__dashjs_factory_name, singletonFactories); if (!factory) { factory = function (context) { let instance; if (context === undefined) { context = {}; } return { getInstance: function () { // If we don't have an instance yet check for one on the context if (!instance) { instance = getSingletonInstance(context, classConstructor.__dashjs_factory_name); } // If there's no instance on the context then create one if (!instance) { instance = merge(classConstructor, context, arguments); singletonContexts.push({ name: classConstructor.__dashjs_factory_name, context: context, instance: instance }); } return instance; } }; }; singletonFactories[classConstructor.__dashjs_factory_name] = factory; // store factory } return factory; } function merge(classConstructor, context, args) { let classInstance; const className = classConstructor.__dashjs_factory_name; const extensionObject = context[className]; if (extensionObject) { let extension = extensionObject.instance; if (extensionObject.override) { //Override public methods in parent but keep parent. classInstance = classConstructor.apply({context}, args); extension = extension.apply({ context, factory: instance, parent: classInstance }, args); for (const prop in extension) { if (classInstance.hasOwnProperty(prop)) { classInstance[prop] = extension[prop]; } } } else { //replace parent object completely with new object. Same as dijon. return extension.apply({ context, factory: instance }, args); } } else { // Create new instance of the class classInstance = classConstructor.apply({context}, args); } // Add getClassName function to class instance prototype (used by Debug) classInstance.getClassName = function () {return className;}; return classInstance; } instance = { extend: extend, getSingletonInstance: getSingletonInstance, setSingletonInstance: setSingletonInstance, getSingletonFactory: getSingletonFactory, getSingletonFactoryByName: getSingletonFactoryByName, updateSingletonFactory: updateSingletonFactory, getClassFactory: getClassFactory, getClassFactoryByName: getClassFactoryByName, updateClassFactory: updateClassFactory }; return instance; }()); export default FactoryMaker; × Search results Close "},"streaming_net_HTTPLoader.js.html":{"id":"streaming_net_HTTPLoader.js.html","title":"Source: streaming/net/HTTPLoader.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/net/HTTPLoader.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import XHRLoader from './XHRLoader'; import FetchLoader from './FetchLoader'; import {HTTPRequest} from '../vo/metrics/HTTPRequest'; import FactoryMaker from '../../core/FactoryMaker'; import DashJSError from '../vo/DashJSError'; import CmcdModel from '../models/CmcdModel'; import Utils from '../../core/Utils'; /** * @module HTTPLoader * @ignore * @description Manages download of resources via HTTP. * @param {Object} cfg - dependancies from parent */ function HTTPLoader(cfg) { cfg = cfg || {}; const context = this.context; const errHandler = cfg.errHandler; const dashMetrics = cfg.dashMetrics; const mediaPlayerModel = cfg.mediaPlayerModel; const requestModifier = cfg.requestModifier; const boxParser = cfg.boxParser; const useFetch = cfg.useFetch || false; const errors = cfg.errors; let instance, requests, delayedRequests, retryRequests, downloadErrorToRequestTypeMap, cmcdModel; function setup() { requests = []; delayedRequests = []; retryRequests = []; cmcdModel = CmcdModel(context).getInstance(); downloadErrorToRequestTypeMap = { [HTTPRequest.MPD_TYPE]: errors.DOWNLOAD_ERROR_ID_MANIFEST_CODE, [HTTPRequest.XLINK_EXPANSION_TYPE]: errors.DOWNLOAD_ERROR_ID_XLINK_CODE, [HTTPRequest.INIT_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE, [HTTPRequest.MEDIA_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE, [HTTPRequest.INDEX_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE, [HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE, [HTTPRequest.OTHER_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE }; } function internalLoad(config, remainingAttempts) { const request = config.request; const traces = []; let firstProgress = true; let needFailureReport = true; let requestStartTime = new Date(); let lastTraceTime = requestStartTime; let lastTraceReceivedCount = 0; let httpRequest; if (!requestModifier || !dashMetrics || !errHandler) { throw new Error('config object is not correct or missing'); } const handleLoaded = function (success) { needFailureReport = false; request.requestStartDate = requestStartTime; request.requestEndDate = new Date(); request.firstByteDate = request.firstByteDate || requestStartTime; if (!request.checkExistenceOnly) { dashMetrics.addHttpRequest(request, httpRequest.response ? httpRequest.response.responseURL : null, httpRequest.response ? httpRequest.response.status : null, httpRequest.response &amp;&amp; httpRequest.response.getAllResponseHeaders ? httpRequest.response.getAllResponseHeaders() : httpRequest.response ? httpRequest.response.responseHeaders : [], success ? traces : null); if (request.type === HTTPRequest.MPD_TYPE) { dashMetrics.addManifestUpdate(request.type, request.requestStartDate, request.requestEndDate); } } }; const onloadend = function () { if (requests.indexOf(httpRequest) === -1) { return; } else { requests.splice(requests.indexOf(httpRequest), 1); } if (needFailureReport) { handleLoaded(false); if (remainingAttempts &gt; 0) { remainingAttempts--; let retryRequest = {config: config}; retryRequests.push(retryRequest); retryRequest.timeout = setTimeout(function () { if (retryRequests.indexOf(retryRequest) === -1) { return; } else { retryRequests.splice(retryRequests.indexOf(retryRequest), 1); } internalLoad(config, remainingAttempts); }, mediaPlayerModel.getRetryIntervalsForType(request.type)); } else { errHandler.error(new DashJSError(downloadErrorToRequestTypeMap[request.type], request.url + ' is not available', { request: request, response: httpRequest.response })); if (config.error) { config.error(request, 'error', httpRequest.response.statusText); } if (config.complete) { config.complete(request, httpRequest.response.statusText); } } } }; const progress = function (event) { const currentTime = new Date(); if (firstProgress) { firstProgress = false; if (!event.lengthComputable || (event.lengthComputable &amp;&amp; event.total !== event.loaded)) { request.firstByteDate = currentTime; } } if (event.lengthComputable) { request.bytesLoaded = event.loaded; request.bytesTotal = event.total; } if (!event.noTrace) { traces.push({ s: lastTraceTime, d: event.time ? event.time : currentTime.getTime() - lastTraceTime.getTime(), b: [event.loaded ? event.loaded - lastTraceReceivedCount : 0] }); lastTraceTime = currentTime; lastTraceReceivedCount = event.loaded; } if (config.progress &amp;&amp; event) { config.progress(event); } }; const onload = function () { if (httpRequest.response.status &gt;= 200 &amp;&amp; httpRequest.response.status &lt;= 299) { handleLoaded(true); if (config.success) { config.success(httpRequest.response.response, httpRequest.response.statusText, httpRequest.response.responseURL); } if (config.complete) { config.complete(request, httpRequest.response.statusText); } } }; const onabort = function () { if (config.abort) { config.abort(request); } }; let loader; if (useFetch &amp;&amp; window.fetch &amp;&amp; request.responseType === 'arraybuffer' &amp;&amp; request.type === HTTPRequest.MEDIA_SEGMENT_TYPE) { loader = FetchLoader(context).create({ requestModifier: requestModifier, boxParser: boxParser }); } else { loader = XHRLoader(context).create({ requestModifier: requestModifier }); } let modifiedUrl = requestModifier.modifyRequestURL(request.url); const additionalQueryParameter = _getAdditionalQueryParameter(request); modifiedUrl = Utils.addAditionalQueryParameterToUrl(modifiedUrl, additionalQueryParameter); const verb = request.checkExistenceOnly ? HTTPRequest.HEAD : HTTPRequest.GET; const withCredentials = mediaPlayerModel.getXHRWithCredentialsForType(request.type); httpRequest = { url: modifiedUrl, method: verb, withCredentials: withCredentials, request: request, onload: onload, onend: onloadend, onerror: onloadend, progress: progress, onabort: onabort, loader: loader }; // Adds the ability to delay single fragment loading time to control buffer. let now = new Date().getTime(); if (isNaN(request.delayLoadingTime) || now &gt;= request.delayLoadingTime) { // no delay - just send requests.push(httpRequest); loader.load(httpRequest); } else { // delay let delayedRequest = {httpRequest: httpRequest}; delayedRequests.push(delayedRequest); delayedRequest.delayTimeout = setTimeout(function () { if (delayedRequests.indexOf(delayedRequest) === -1) { return; } else { delayedRequests.splice(delayedRequests.indexOf(delayedRequest), 1); } try { requestStartTime = new Date(); lastTraceTime = requestStartTime; requests.push(delayedRequest.httpRequest); loader.load(delayedRequest.httpRequest); } catch (e) { delayedRequest.httpRequest.onerror(); } }, (request.delayLoadingTime - now)); } } function _getAdditionalQueryParameter(request) { try { const additionalQueryParameter = []; const cmcdQueryParameter = cmcdModel.getQueryParameter(request); if (cmcdQueryParameter) { additionalQueryParameter.push(cmcdQueryParameter); } return additionalQueryParameter; } catch (e) { return []; } } /** * Initiates a download of the resource described by config.request * @param {Object} config - contains request (FragmentRequest or derived type), and callbacks * @memberof module:HTTPLoader * @instance */ function load(config) { if (config.request) { internalLoad( config, mediaPlayerModel.getRetryAttemptsForType( config.request.type ) ); } else { if (config.error) { config.error(config.request, 'error'); } } } /** * Aborts any inflight downloads * @memberof module:HTTPLoader * @instance */ function abort() { retryRequests.forEach(t =&gt; { clearTimeout(t.timeout); // abort request in order to trigger LOADING_ABANDONED event if (t.config.request &amp;&amp; t.config.abort) { t.config.abort(t.config.request); } }); retryRequests = []; delayedRequests.forEach(x =&gt; clearTimeout(x.delayTimeout)); delayedRequests = []; requests.forEach(x =&gt; { // abort will trigger onloadend which we don't want // when deliberately aborting inflight requests - // set them to undefined so they are not called x.onloadend = x.onerror = x.onprogress = undefined; x.loader.abort(x); }); requests = []; } instance = { load: load, abort: abort }; setup(); return instance; } HTTPLoader.__dashjs_factory_name = 'HTTPLoader'; const factory = FactoryMaker.getClassFactory(HTTPLoader); export default factory; × Search results Close "},"streaming_utils_ObjectUtils.js.html":{"id":"streaming_utils_ObjectUtils.js.html","title":"Source: streaming/utils/ObjectUtils.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/ObjectUtils.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import deepEqual from 'fast-deep-equal'; /** * @module ObjectUtils * @ignore * @description Provides utility functions for objects */ function ObjectUtils() { let instance; /** * Returns true if objects are equal * @return {boolean} * @param {object} obj1 * @param {object} obj2 * @memberof module:ObjectUtils * @instance */ function areEqual(obj1, obj2) { return deepEqual(obj1, obj2); } instance = { areEqual: areEqual }; return instance; } ObjectUtils.__dashjs_factory_name = 'ObjectUtils'; export default FactoryMaker.getSingletonFactory(ObjectUtils); × Search results Close "},"offline_controllers_OfflineController.js.html":{"id":"offline_controllers_OfflineController.js.html","title":"Source: offline/controllers/OfflineController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/controllers/OfflineController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import OfflineConstants from '../constants/OfflineConstants'; import OfflineStoreController from './OfflineStoreController'; import OfflineDownload from '../OfflineDownload'; import IndexDBOfflineLoader from '../net/IndexDBOfflineLoader'; import OfflineUrlUtils from '../utils/OfflineUrlUtils'; import OfflineEvents from '../events/OfflineEvents'; import OfflineErrors from '../errors/OfflineErrors'; import OfflineRecord from '../vo/OfflineDownloadVo'; /** * @module OfflineController * @param {Object} config - dependencies * @description Provides access to offline stream recording and playback functionality. */ function OfflineController(config) { const context = this.context; const errHandler = config.errHandler; const events = config.events; const errors = config.errors; const settings = config.settings; const eventBus = config.eventBus; const debug = config.debug; const manifestLoader = config.manifestLoader; const manifestModel = config.manifestModel; const mediaPlayerModel = config.mediaPlayerModel; const abrController = config.abrController; const playbackController = config.playbackController; const dashMetrics = config.dashMetrics; const timelineConverter = config.timelineConverter; const adapter = config.adapter; const manifestUpdater = config.manifestUpdater; const baseURLController = config.baseURLController; const schemeLoaderFactory = config.schemeLoaderFactory; const constants = config.constants; const dashConstants = config.dashConstants; const urlUtils = config.urlUtils; let instance, downloads, logger, offlineStoreController, offlineUrlUtils; function setup() { logger = debug.getLogger(instance); offlineStoreController = OfflineStoreController(context).create({ eventBus: config.eventBus, errHandler: errHandler }); offlineUrlUtils = OfflineUrlUtils(context).getInstance(); urlUtils.registerUrlRegex(offlineUrlUtils.getRegex(), offlineUrlUtils); schemeLoaderFactory.registerLoader(OfflineConstants.OFFLINE_SCHEME, IndexDBOfflineLoader); downloads = []; } /* --------------------------------------------------------------------------- DOWNLOAD LIST FUNCTIONS --------------------------------------------------------------------------- */ function getDownloadFromId(id) { let download = downloads.find((item) =&gt; { return item.getId() === id; }); return download; } function createDownloadFromId(id) { let download; download = getDownloadFromId(id); if (!download) { // create download controller download = OfflineDownload(context).create({ id: id, eventBus: eventBus, events: events, errors: errors, settings: settings, manifestLoader: manifestLoader, manifestModel: manifestModel, mediaPlayerModel: mediaPlayerModel, manifestUpdater: manifestUpdater, baseURLController: baseURLController, abrController: abrController, playbackController: playbackController, adapter: adapter, dashMetrics: dashMetrics, timelineConverter: timelineConverter, errHandler: errHandler, offlineStoreController: offlineStoreController, debug: debug, constants: constants, dashConstants: dashConstants, urlUtils: urlUtils }); downloads.push(download); } return download; } function createDownloadFromStorage(offline) { let download = getDownloadFromId(offline.manifestId); if (!download) { download = createDownloadFromId(offline.manifestId); let status = offline.status; if (status === OfflineConstants.OFFLINE_STATUS_STARTED) { status = OfflineConstants.OFFLINE_STATUS_STOPPED; } download.setInitialState({ url: offline.url, progress: offline.progress, originalUrl: offline.originalURL, status: status }); } return download; } function removeDownloadFromId(id) { return new Promise(function (resolve, reject) { let download = getDownloadFromId(id); let waitForStatusChanged = false; if (download) { //is download running? if (download.isDownloading()) { //register status changed event waitForStatusChanged = true; const downloadStopped = function () { eventBus.off(events.OFFLINE_RECORD_STOPPED, downloadStopped, instance); return offlineStoreController.deleteDownloadById(id).then(function () { resolve(); }).catch(function (err) { reject(err); }); }; eventBus.on(events.OFFLINE_RECORD_STOPPED, downloadStopped, instance); } download.deleteDownload(); let index = downloads.indexOf(download); downloads.splice(index, 1); } if (!waitForStatusChanged) { resolve(); } }); } function generateManifestId() { let timestamp = new Date().getTime(); return timestamp; } /* --------------------------------------------------------------------------- OFFLINE CONTROLLER API --------------------------------------------------------------------------- */ /** * Loads records from storage * This methods has to be called first, to be sure that all downloads have been loaded * * @return {Promise} asynchronously resolved * @memberof module:OfflineController */ function loadRecordsFromStorage() { return new Promise(function (resolve, reject) { offlineStoreController.getAllManifests().then((items) =&gt; { items.manifests.forEach((offline) =&gt; { createDownloadFromStorage(offline); }); resolve(); }).catch((e) =&gt; { logger.error('Failed to load downloads ' + e); reject(e); }); }); } /** * Get all records from storage * * @return {Promise} asynchronously resolved with records * @memberof module:OfflineController * @instance */ function getAllRecords() { let records = []; downloads.forEach((download) =&gt; { const record = new OfflineRecord(); record.id = download.getId(); record.progress = download.getDownloadProgression(); record.url = download.getOfflineUrl(); record.originalUrl = download.getManifestUrl(); record.status = download.getStatus(); records.push(record); }); return records; } /** * Create a new content record in storage and download manifest from url * * @param {string} manifestURL - the content manifest url * @return {Promise} asynchronously resolved with record identifier * @memberof module:OfflineController * @instance */ function createRecord(manifestURL) { return new Promise(function (resolve, reject) { let id = generateManifestId(); // create download controller let download = createDownloadFromId(id); download.downloadFromUrl(manifestURL).then(() =&gt; { download.initDownload(); resolve(id); }) .catch((e) =&gt; { logger.error('Failed to download ' + e); removeDownloadFromId(id).then(function () { reject(e); }); }); }); } /** * Start downloading the record with selected tracks representations * * @param {string} id - record identifier * @param {MediaInfo[]} mediaInfos - the selected tracks representations * @memberof module:OfflineController * @instance */ function startRecord(id, mediaInfos) { let download = getDownloadFromId(id); if (download) { download.startDownload(mediaInfos); } } /** * Stop downloading of the record * * @param {string} id - record identifier * @memberof module:OfflineController * @instance */ function stopRecord(id) { let download = getDownloadFromId(id); if (download) { download.stopDownload(); } } /** * Resume downloading of the record * * @param {string} id - record identifier * @memberof module:OfflineController * @instance */ function resumeRecord(id) { let download = getDownloadFromId(id); if (download) { download.resumeDownload(); } } /** * Deletes a record from storage * * @param {string} id - record identifier * @memberof module:OfflineController * @instance */ function deleteRecord(id) { return removeDownloadFromId(id).then(function () { return offlineStoreController.deleteDownloadById(id); }); } /** * Get download progression of a record * * @param {string} id - record identifier * @return {number} percentage progression * @memberof module:OfflineController * @instance */ function getRecordProgression(id) { let download = getDownloadFromId(id); if (download) { return download.getDownloadProgression(); } return 0; } /** * Reset all records * @memberof module:OfflineController * @instance */ function resetRecords() { downloads.forEach((download) =&gt; { download.resetDownload(); }); } /** * Reset * @instance */ function reset() { resetRecords(); schemeLoaderFactory.unregisterLoader(OfflineConstants.OFFLINE_SCHEME); } instance = { loadRecordsFromStorage: loadRecordsFromStorage, createRecord: createRecord, startRecord: startRecord, stopRecord: stopRecord, resumeRecord: resumeRecord, deleteRecord: deleteRecord, getRecordProgression: getRecordProgression, getAllRecords: getAllRecords, resetRecords: resetRecords, reset: reset }; setup(); return instance; } OfflineController.__dashjs_factory_name = 'OfflineController'; const factory = dashjs.FactoryMaker.getClassFactory(OfflineController); /* jshint ignore:line */ factory.events = OfflineEvents; factory.errors = OfflineErrors; dashjs.FactoryMaker.updateClassFactory(OfflineController.__dashjs_factory_name, factory); /* jshint ignore:line */ export default factory; × Search results Close "},"streaming_protection_controllers_ProtectionController.js.html":{"id":"streaming_protection_controllers_ProtectionController.js.html","title":"Source: streaming/protection/controllers/ProtectionController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/controllers/ProtectionController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import CommonEncryption from '../CommonEncryption'; import MediaCapability from '../vo/MediaCapability'; import KeySystemConfiguration from '../vo/KeySystemConfiguration'; import ProtectionErrors from '../errors/ProtectionErrors'; import DashJSError from '../../vo/DashJSError'; const NEEDKEY_BEFORE_INITIALIZE_RETRIES = 5; const NEEDKEY_BEFORE_INITIALIZE_TIMEOUT = 500; const LICENSE_SERVER_REQUEST_RETRIES = 3; const LICENSE_SERVER_REQUEST_RETRY_INTERVAL = 1000; const LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT = 8000; /** * @module ProtectionController * @description Provides access to media protection information and functionality. Each * ProtectionController manages a single {@link MediaPlayer.models.ProtectionModel} * which encapsulates a set of protection information (EME APIs, selected key system, * key sessions). The APIs of ProtectionController mostly align with the latest EME * APIs. Key system selection is mostly automated when combined with app-overrideable * functionality provided in {@link ProtectionKeyController}. * @todo ProtectionController does almost all of its tasks automatically after init() is * called. Applications might want more control over this process and want to go through * each step manually (key system selection, session creation, session maintenance). * @param {Object} config */ function ProtectionController(config) { config = config || {}; const protectionKeyController = config.protectionKeyController; let protectionModel = config.protectionModel; const eventBus = config.eventBus; const events = config.events; const debug = config.debug; const BASE64 = config.BASE64; const constants = config.constants; let needkeyRetries = []; let instance, logger, pendingNeedKeyData, mediaInfoArr, protDataSet, sessionType, robustnessLevel, keySystem; function setup() { logger = debug.getLogger(instance); pendingNeedKeyData = []; mediaInfoArr = []; sessionType = 'temporary'; robustnessLevel = ''; } function checkConfig() { if (!eventBus || !eventBus.hasOwnProperty('on') || !protectionKeyController || !protectionKeyController.hasOwnProperty('getSupportedKeySystemsFromContentProtection')) { throw new Error('Missing config parameter(s)'); } } /** * Initialize this protection system with a given audio * or video stream information. * * @param {StreamInfo} [mediaInfo] Media information * @memberof module:ProtectionController * @instance * @todo This API will change when we have better support for allowing applications * to select different adaptation sets for playback. Right now it is clunky for * applications to create {@link StreamInfo} with the right information, * @ignore */ function initializeForMedia(mediaInfo) { // Not checking here if a session for similar KS/KID combination is already created // because still don't know which keysystem will be selected. // Once Keysystem is selected and before creating the session, we will do that check // so we create the strictly necessary DRM sessions if (!mediaInfo) { throw new Error('mediaInfo can not be null or undefined'); } checkConfig(); eventBus.on(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this); eventBus.on(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this); mediaInfoArr.push(mediaInfo); // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio // and video will be the same. Just use one valid MediaInfo object const supportedKS = protectionKeyController.getSupportedKeySystemsFromContentProtection(mediaInfo.contentProtection); if (supportedKS &amp;&amp; supportedKS.length &gt; 0) { selectKeySystem(supportedKS, true); } } /** * Returns a set of supported key systems and CENC initialization data * from the given array of ContentProtection elements. Only * key systems that are supported by this player will be returned. * Key systems are returned in priority order (highest first). * * @param {Array.&lt;Object&gt;} cps - array of content protection elements parsed * from the manifest * @returns {Array.&lt;Object&gt;} array of objects indicating which supported key * systems were found. Empty array is returned if no * supported key systems were found * @memberof module:ProtectionKeyController * @instance * @ignore */ function getSupportedKeySystemsFromContentProtection(cps) { checkConfig(); return protectionKeyController.getSupportedKeySystemsFromContentProtection(cps); } /** * Create a new key session associated with the given initialization data from * the MPD or from the PSSH box in the media * * @param {ArrayBuffer} initData the initialization data * @param {Uint8Array} cdmData the custom data to provide to licenser * @memberof module:ProtectionController * @instance * @fires ProtectionController#KeySessionCreated * @todo In older versions of the EME spec, there was a one-to-one relationship between * initialization data and key sessions. That is no longer true in the latest APIs. This * API will need to modified (and a new \"generateRequest(keySession, initData)\" API created) * to come up to speed with the latest EME standard * @ignore */ function createKeySession(initData, cdmData) { const initDataForKS = CommonEncryption.getPSSHForKeySystem(keySystem, initData); const protData = getProtData(keySystem); if (initDataForKS) { // Check for duplicate initData const currentInitData = protectionModel.getAllInitData(); for (let i = 0; i &lt; currentInitData.length; i++) { if (protectionKeyController.initDataEquals(initDataForKS, currentInitData[i])) { logger.warn('DRM: Ignoring initData because we have already seen it!'); return; } } try { protectionModel.createKeySession(initDataForKS, protData, getSessionType(keySystem), cdmData); } catch (error) { eventBus.trigger(events.KEY_SESSION_CREATED, { data: null, error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + error.message) }); } } else if (initData) { protectionModel.createKeySession(initData, protData, getSessionType(keySystem), cdmData); } else { eventBus.trigger(events.KEY_SESSION_CREATED, { data: null, error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Selected key system is ' + (keySystem ? keySystem.systemString : null) + '. needkey/encrypted event contains no initData corresponding to that key system!') }); } } /** * Loads a key session with the given session ID from persistent storage. This * essentially creates a new key session * * @param {string} sessionID * @param {string} initData * @memberof module:ProtectionController * @instance * @fires ProtectionController#KeySessionCreated * @ignore */ function loadKeySession(sessionID, initData) { checkConfig(); protectionModel.loadKeySession(sessionID, initData, getSessionType(keySystem)); } /** * Removes the given key session from persistent storage and closes the session * as if {@link ProtectionController#closeKeySession} * was called * * @param {SessionToken} sessionToken the session * token * @memberof module:ProtectionController * @instance * @fires ProtectionController#KeySessionRemoved * @fires ProtectionController#KeySessionClosed * @ignore */ function removeKeySession(sessionToken) { checkConfig(); protectionModel.removeKeySession(sessionToken); } /** * Closes the key session and releases all associated decryption keys. These * keys will no longer be available for decrypting media * * @param {SessionToken} sessionToken the session * token * @memberof module:ProtectionController * @instance * @fires ProtectionController#KeySessionClosed * @ignore */ function closeKeySession(sessionToken) { checkConfig(); protectionModel.closeKeySession(sessionToken); } /** * Sets a server certificate for use by the CDM when signing key messages * intended for a particular license server. This will fire * an error event if a key system has not yet been selected. * * @param {ArrayBuffer} serverCertificate a CDM-specific license server * certificate * @memberof module:ProtectionController * @instance * @fires ProtectionController#ServerCertificateUpdated */ function setServerCertificate(serverCertificate) { checkConfig(); protectionModel.setServerCertificate(serverCertificate); } /** * Associate this protection system with the given HTMLMediaElement. This * causes the system to register for needkey/encrypted events from the given * element and provides a destination for setting of MediaKeys * * @param {HTMLMediaElement} element the media element to which the protection * system should be associated * @memberof module:ProtectionController * @instance */ function setMediaElement(element) { checkConfig(); if (element) { protectionModel.setMediaElement(element); eventBus.on(events.NEED_KEY, onNeedKey, this); } else if (element === null) { protectionModel.setMediaElement(element); eventBus.off(events.NEED_KEY, onNeedKey, this); } } /** * Sets the session type to use when creating key sessions. Either \"temporary\" or * \"persistent-license\". Default is \"temporary\". * * @param {string} value the session type * @memberof module:ProtectionController * @instance */ function setSessionType(value) { sessionType = value; } /** * Sets the robustness level for video and audio capabilities. Optional to remove Chrome warnings. * Possible values are SW_SECURE_CRYPTO, SW_SECURE_DECODE, HW_SECURE_CRYPTO, HW_SECURE_CRYPTO, HW_SECURE_DECODE, HW_SECURE_ALL. * * @param {string} level the robustness level * @memberof module:ProtectionController * @instance */ function setRobustnessLevel(level) { robustnessLevel = level; } /** * Attach KeySystem-specific data to use for license acquisition with EME * * @param {Object} data an object containing property names corresponding to * key system name strings (e.g. \"org.w3.clearkey\") and associated values * being instances of {@link ProtectionData} * @memberof module:ProtectionController * @instance * @ignore */ function setProtectionData(data) { protDataSet = data; protectionKeyController.setProtectionData(data); } /** * Stop method is called when current playback is stopped/resetted. * * @memberof module:ProtectionController * @instance */ function stop() { if (protectionModel) { protectionModel.stop(); } } /** * Destroys all protection data associated with this protection set. This includes * deleting all key sessions. In the case of persistent key sessions, the sessions * will simply be unloaded and not deleted. Additionally, if this protection set is * associated with a HTMLMediaElement, it will be detached from that element. * * @memberof module:ProtectionController * @instance * @ignore */ function reset() { checkConfig(); eventBus.off(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this); eventBus.off(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this); setMediaElement(null); keySystem = undefined;//TODO-Refactor look at why undefined is needed for this. refactor if (protectionModel) { protectionModel.reset(); protectionModel = null; } needkeyRetries.forEach(retryTimeout =&gt; clearTimeout(retryTimeout)); needkeyRetries = []; mediaInfoArr = []; } /////////////// // Private /////////////// function getProtData(keySystem) { let protData = null; if (keySystem) { const keySystemString = keySystem.systemString; if (protDataSet) { protData = (keySystemString in protDataSet) ? protDataSet[keySystemString] : null; } } return protData; } function getKeySystemConfiguration(keySystem) { const protData = getProtData(keySystem); const audioCapabilities = []; const videoCapabilities = []; const audioRobustness = (protData &amp;&amp; protData.audioRobustness &amp;&amp; protData.audioRobustness.length &gt; 0) ? protData.audioRobustness : robustnessLevel; const videoRobustness = (protData &amp;&amp; protData.videoRobustness &amp;&amp; protData.videoRobustness.length &gt; 0) ? protData.videoRobustness : robustnessLevel; const ksSessionType = getSessionType(keySystem); const distinctiveIdentifier = (protData &amp;&amp; protData.distinctiveIdentifier) ? protData.distinctiveIdentifier : 'optional'; const persistentState = (protData &amp;&amp; protData.persistentState) ? protData.persistentState : (ksSessionType === 'temporary') ? 'optional' : 'required'; mediaInfoArr.forEach((media) =&gt; { if (media.type === constants.AUDIO) { audioCapabilities.push(new MediaCapability(media.codec, audioRobustness)); } else if (media.type === constants.VIDEO) { videoCapabilities.push(new MediaCapability(media.codec, videoRobustness)); } }); return new KeySystemConfiguration( audioCapabilities, videoCapabilities, distinctiveIdentifier, persistentState, [ksSessionType]); } function getSessionType(keySystem) { const protData = getProtData(keySystem); const ksSessionType = (protData &amp;&amp; protData.sessionType) ? protData.sessionType : sessionType; return ksSessionType; } function selectKeySystem(supportedKS, fromManifest) { const self = this; const requestedKeySystems = []; // Reorder key systems according to priority order provided in protectionData supportedKS = supportedKS.sort((ksA, ksB) =&gt; { let indexA = (protDataSet &amp;&amp; protDataSet[ksA.ks.systemString] &amp;&amp; protDataSet[ksA.ks.systemString].priority &gt;= 0) ? protDataSet[ksA.ks.systemString].priority : supportedKS.length; let indexB = (protDataSet &amp;&amp; protDataSet[ksB.ks.systemString] &amp;&amp; protDataSet[ksB.ks.systemString].priority &gt;= 0) ? protDataSet[ksB.ks.systemString].priority : supportedKS.length; return indexA - indexB; }); let ksIdx; if (keySystem) { // We have a key system for (ksIdx = 0; ksIdx &lt; supportedKS.length; ksIdx++) { if (keySystem === supportedKS[ksIdx].ks) { requestedKeySystems.push({ ks: supportedKS[ksIdx].ks, configs: [getKeySystemConfiguration(keySystem)] }); // Ensure that we would be granted key system access using the key // system and codec information const onKeySystemAccessComplete = function (event) { eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); if (event.error) { if (!fromManifest) { eventBus.trigger(events.KEY_SYSTEM_SELECTED, {error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error)}); } } else { logger.info('DRM: KeySystem Access Granted'); eventBus.trigger(events.KEY_SYSTEM_SELECTED, {data: event.data}); const protData = getProtData(keySystem); if (protectionKeyController.isClearKey(keySystem)) { // For Clearkey: if parameters for generating init data was provided by the user, use them for generating // initData and overwrite possible initData indicated in encrypted event (EME) if (protData &amp;&amp; protData.hasOwnProperty('clearkeys')) { const initData = {kids: Object.keys(protData.clearkeys)}; supportedKS[ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData)); } } if (supportedKS[ksIdx].sessionId) { // Load MediaKeySession with sessionId loadKeySession(supportedKS[ksIdx].sessionId, supportedKS[ksIdx].initData); } else if (supportedKS[ksIdx].initData) { // Create new MediaKeySession with initData createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData); } } }; eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); protectionModel.requestKeySystemAccess(requestedKeySystems); break; } } } else if (keySystem === undefined) { // First time through, so we need to select a key system keySystem = null; pendingNeedKeyData.push(supportedKS); // Add all key systems to our request list since we have yet to select a key system for (let i = 0; i &lt; supportedKS.length; i++) { requestedKeySystems.push({ ks: supportedKS[i].ks, configs: [getKeySystemConfiguration(supportedKS[i].ks)] }); } let keySystemAccess; const onKeySystemAccessComplete = function (event) { eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); if (event.error) { keySystem = undefined; eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self); if (!fromManifest) { eventBus.trigger(events.KEY_SYSTEM_SELECTED, { data: null, error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error) }); } } else { keySystemAccess = event.data; logger.info('DRM: KeySystem Access Granted (' + keySystemAccess.keySystem.systemString + ')! Selecting key system...'); protectionModel.selectKeySystem(keySystemAccess); } }; var onKeySystemSelected = function (event) { eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self); eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); if (!event.error) { if (!protectionModel) { return; } keySystem = protectionModel.getKeySystem(); eventBus.trigger(events.KEY_SYSTEM_SELECTED, {data: keySystemAccess}); // Set server certificate from protData const protData = getProtData(keySystem); if (protData &amp;&amp; protData.serverCertificate &amp;&amp; protData.serverCertificate.length &gt; 0) { protectionModel.setServerCertificate(BASE64.decodeArray(protData.serverCertificate).buffer); } for (let i = 0; i &lt; pendingNeedKeyData.length; i++) { for (ksIdx = 0; ksIdx &lt; pendingNeedKeyData[i].length; ksIdx++) { if (keySystem === pendingNeedKeyData[i][ksIdx].ks) { if (protectionKeyController.isClearKey(keySystem)) { // For Clearkey: if parameters for generating init data was provided by the user, use them for generating // initData and overwrite possible initData indicated in encrypted event (EME) if (protData &amp;&amp; protData.hasOwnProperty('clearkeys')) { const initData = {kids: Object.keys(protData.clearkeys)}; pendingNeedKeyData[i][ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData)); } } if (pendingNeedKeyData[i][ksIdx].sessionId) { // Load MediaKeySession with sessionId loadKeySession(pendingNeedKeyData[i][ksIdx].sessionId, pendingNeedKeyData[i][ksIdx].initData); } else if (pendingNeedKeyData[i][ksIdx].initData !== null) { // Create new MediaKeySession with initData createKeySession(pendingNeedKeyData[i][ksIdx].initData, pendingNeedKeyData[i][ksIdx].cdmData); } break; } } } } else { keySystem = undefined; if (!fromManifest) { eventBus.trigger(events.KEY_SYSTEM_SELECTED, { data: null, error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + 'Error selecting key system! -- ' + event.error) }); } } }; eventBus.on(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self); eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); protectionModel.requestKeySystemAccess(requestedKeySystems); } else { // We are in the process of selecting a key system, so just save the data pendingNeedKeyData.push(supportedKS); } } function sendLicenseRequestCompleteEvent(data, error) { eventBus.trigger(events.LICENSE_REQUEST_COMPLETE, {data: data, error: error}); } function onKeyStatusChanged(e) { if (e.error) { eventBus.trigger(events.KEY_STATUSES_CHANGED, {data: null, error: e.error}); } else { logger.debug('DRM: key status = ' + e.status); } } function onKeyMessage(e) { logger.debug('DRM: onKeyMessage'); // Dispatch event to applications indicating we received a key message const keyMessage = e.data; eventBus.trigger(events.KEY_MESSAGE, {data: keyMessage}); const messageType = (keyMessage.messageType) ? keyMessage.messageType : 'license-request'; const message = keyMessage.message; const sessionToken = keyMessage.sessionToken; const protData = getProtData(keySystem); const keySystemString = keySystem ? keySystem.systemString : null; const licenseServerData = protectionKeyController.getLicenseServer(keySystem, protData, messageType); const eventData = {sessionToken: sessionToken, messageType: messageType}; // Ensure message from CDM is not empty if (!message || message.byteLength === 0) { sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE)); return; } // Message not destined for license server if (!licenseServerData) { logger.debug('DRM: License server request not required for this message (type = ' + e.data.messageType + '). Session ID = ' + sessionToken.getSessionID()); sendLicenseRequestCompleteEvent(eventData); return; } // Perform any special handling for ClearKey if (protectionKeyController.isClearKey(keySystem)) { const clearkeys = protectionKeyController.processClearKeyLicenseRequest(keySystem, protData, message); if (clearkeys) { logger.debug('DRM: ClearKey license request handled by application!'); sendLicenseRequestCompleteEvent(eventData); protectionModel.updateKeySession(sessionToken, clearkeys); return; } } // All remaining key system scenarios require a request to a remote license server // Determine license server URL let url = null; if (protData &amp;&amp; protData.serverURL) { const serverURL = protData.serverURL; if (typeof serverURL === 'string' &amp;&amp; serverURL !== '') { url = serverURL; } else if (typeof serverURL === 'object' &amp;&amp; serverURL.hasOwnProperty(messageType)) { url = serverURL[messageType]; } } else if (protData &amp;&amp; protData.laURL &amp;&amp; protData.laURL !== '') { // TODO: Deprecated! url = protData.laURL; } else { // For clearkey use the url defined in the manifest if (protectionKeyController.isClearKey(keySystem)) { url = keySystem.getLicenseServerUrlFromMediaInfo(mediaInfoArr); } else { const psshData = CommonEncryption.getPSSHData(sessionToken.initData); url = keySystem.getLicenseServerURLFromInitData(psshData); if (!url) { url = e.data.laURL; } } } // Possibly update or override the URL based on the message url = licenseServerData.getServerURLFromMessage(url, message, messageType); // Ensure valid license server URL if (!url) { sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE)); return; } // Set optional XMLHttpRequest headers from protection data and message const reqHeaders = {}; let withCredentials = false; const updateHeaders = function (headers) { if (headers) { for (const key in headers) { if ('authorization' === key.toLowerCase()) { withCredentials = true; } reqHeaders[key] = headers[key]; } } }; if (protData) { updateHeaders(protData.httpRequestHeaders); } updateHeaders(keySystem.getRequestHeadersFromMessage(message)); // Overwrite withCredentials property from protData if present if (protData &amp;&amp; typeof protData.withCredentials == 'boolean') { withCredentials = protData.withCredentials; } const reportError = function (xhr, eventData, keySystemString, messageType) { const errorMsg = ((xhr.response) ? licenseServerData.getErrorResponse(xhr.response, keySystemString, messageType) : 'NONE'); sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR complete. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState + '. Response is ' + errorMsg)); }; const onLoad = function (xhr) { if (!protectionModel) { return; } if (xhr.status === 200) { const licenseMessage = licenseServerData.getLicenseMessage(xhr.response, keySystemString, messageType); if (licenseMessage !== null) { sendLicenseRequestCompleteEvent(eventData); protectionModel.updateKeySession(sessionToken, licenseMessage); } else { reportError(xhr, eventData, keySystemString, messageType); } } else { reportError(xhr, eventData, keySystemString, messageType); } }; const onAbort = function (xhr) { sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR aborted. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState)); }; const onError = function (xhr) { sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR error. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState)); }; //const reqPayload = keySystem.getLicenseRequestFromMessage(message); const reqPayload = keySystem.getLicenseRequestFromMessage(message); const reqMethod = licenseServerData.getHTTPMethod(messageType); const responseType = licenseServerData.getResponseType(keySystemString, messageType); const timeout = protData &amp;&amp; !isNaN(protData.httpTimeout) ? protData.httpTimeout : LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT; doLicenseRequest(url, reqHeaders, reqMethod, responseType, withCredentials, reqPayload, LICENSE_SERVER_REQUEST_RETRIES, timeout, onLoad, onAbort, onError); } // Implement license requests with a retry mechanism to avoid temporary network issues to affect playback experience function doLicenseRequest(url, headers, method, responseType, withCredentials, payload, retriesCount, timeout, onLoad, onAbort, onError) { const xhr = new XMLHttpRequest(); xhr.open(method, url, true); xhr.responseType = responseType; xhr.withCredentials = withCredentials; if (timeout &gt; 0) { xhr.timeout = timeout; } for (const key in headers) { xhr.setRequestHeader(key, headers[key]); } const retryRequest = function () { // fail silently and retry retriesCount--; setTimeout(function () { doLicenseRequest(url, headers, method, responseType, withCredentials, payload, retriesCount, timeout, onLoad, onAbort, onError); }, LICENSE_SERVER_REQUEST_RETRY_INTERVAL); }; xhr.onload = function () { if (this.status === 200 || retriesCount &lt;= 0) { onLoad(this); } else { logger.warn('License request failed (' + this.status + '). Retrying it... Pending retries: ' + retriesCount); retryRequest(); } }; xhr.ontimeout = xhr.onerror = function () { if (retriesCount &lt;= 0) { onError(this); } else { logger.warn('License request network request failed . Retrying it... Pending retries: ' + retriesCount); retryRequest(); } }; xhr.onabort = function () { onAbort(this); }; xhr.send(payload); } function onNeedKey(event, retry) { logger.debug('DRM: onNeedKey'); // Ignore non-cenc initData if (event.key.initDataType !== 'cenc') { logger.warn('DRM: Only \\'cenc\\' initData is supported! Ignoring initData of type: ' + event.key.initDataType); return; } if (mediaInfoArr.length === 0) { logger.warn('DRM: onNeedKey called before initializeForMedia, wait until initialized'); retry = typeof retry === 'undefined' ? 1 : retry + 1; if (retry &lt; NEEDKEY_BEFORE_INITIALIZE_RETRIES) { needkeyRetries.push(setTimeout(() =&gt; { onNeedKey(event, retry); }, NEEDKEY_BEFORE_INITIALIZE_TIMEOUT)); return; } } // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome). // Convert to ArrayBuffer let abInitData = event.key.initData; if (ArrayBuffer.isView(abInitData)) { abInitData = abInitData.buffer; } // If key system has already been selected and initData already seen, then do nothing if (keySystem) { const initDataForKS = CommonEncryption.getPSSHForKeySystem(keySystem, abInitData); if (initDataForKS) { // Check for duplicate initData const currentInitData = protectionModel.getAllInitData(); for (let i = 0; i &lt; currentInitData.length; i++) { if (protectionKeyController.initDataEquals(initDataForKS, currentInitData[i])) { logger.warn('DRM: Ignoring initData because we have already seen it!'); return; } } } } logger.debug('DRM: initData:', String.fromCharCode.apply(null, new Uint8Array(abInitData))); const supportedKS = protectionKeyController.getSupportedKeySystems(abInitData, protDataSet); if (supportedKS.length === 0) { logger.debug('DRM: Received needkey event with initData, but we don\\'t support any of the key systems!'); return; } selectKeySystem(supportedKS, false); } function getKeySystems() { return protectionKeyController ? protectionKeyController.getKeySystems() : []; } function setKeySystems(keySystems) { if (protectionKeyController) { protectionKeyController.setKeySystems(keySystems); } } instance = { initializeForMedia: initializeForMedia, createKeySession: createKeySession, loadKeySession: loadKeySession, removeKeySession: removeKeySession, closeKeySession: closeKeySession, setServerCertificate: setServerCertificate, setMediaElement: setMediaElement, setSessionType: setSessionType, setRobustnessLevel: setRobustnessLevel, setProtectionData: setProtectionData, getSupportedKeySystemsFromContentProtection: getSupportedKeySystemsFromContentProtection, getKeySystems: getKeySystems, setKeySystems: setKeySystems, stop: stop, reset: reset }; setup(); return instance; } ProtectionController.__dashjs_factory_name = 'ProtectionController'; export default dashjs.FactoryMaker.getClassFactory(ProtectionController); /* jshint ignore:line */ × Search results Close "},"streaming_protection_controllers_ProtectionKeyController.js.html":{"id":"streaming_protection_controllers_ProtectionKeyController.js.html","title":"Source: streaming/protection/controllers/ProtectionKeyController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/controllers/ProtectionKeyController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import CommonEncryption from './../CommonEncryption'; import KeySystemClearKey from './../drm/KeySystemClearKey'; import KeySystemW3CClearKey from './../drm/KeySystemW3CClearKey'; import KeySystemWidevine from './../drm/KeySystemWidevine'; import KeySystemPlayReady from './../drm/KeySystemPlayReady'; import DRMToday from './../servers/DRMToday'; import PlayReady from './../servers/PlayReady'; import Widevine from './../servers/Widevine'; import ClearKey from './../servers/ClearKey'; import ProtectionConstants from '../../constants/ProtectionConstants'; /** * @module ProtectionKeyController * @ignore * @description Media protection key system functionality that can be modified/overridden by applications */ function ProtectionKeyController() { let context = this.context; let instance, debug, logger, keySystems, BASE64, clearkeyKeySystem, clearkeyW3CKeySystem; function setConfig(config) { if (!config) return; if (config.debug) { debug = config.debug; logger = debug.getLogger(instance); } if (config.BASE64) { BASE64 = config.BASE64; } } function initialize() { keySystems = []; let keySystem; // PlayReady keySystem = KeySystemPlayReady(context).getInstance({BASE64: BASE64}); keySystems.push(keySystem); // Widevine keySystem = KeySystemWidevine(context).getInstance({BASE64: BASE64}); keySystems.push(keySystem); // ClearKey keySystem = KeySystemClearKey(context).getInstance({BASE64: BASE64}); keySystems.push(keySystem); clearkeyKeySystem = keySystem; // W3C ClearKey keySystem = KeySystemW3CClearKey(context).getInstance({BASE64: BASE64, debug: debug}); keySystems.push(keySystem); clearkeyW3CKeySystem = keySystem; } /** * Returns a prioritized list of key systems supported * by this player (not necessarily those supported by the * user agent) * * @returns {Array.&lt;KeySystem&gt;} a prioritized * list of key systems * @memberof module:ProtectionKeyController * @instance */ function getKeySystems() { return keySystems; } /** * Sets the prioritized list of key systems to be supported * by this player. * * @param {Array.&lt;KeySystem&gt;} newKeySystems the new prioritized * list of key systems * @memberof module:ProtectionKeyController * @instance */ function setKeySystems(newKeySystems) { keySystems = newKeySystems; } /** * Returns the key system associated with the given key system string * name (i.e. 'org.w3.clearkey') * * @param {string} systemString the system string * @returns {KeySystem|null} the key system * or null if no supported key system is associated with the given key * system string * @memberof module:ProtectionKeyController * @instance */ function getKeySystemBySystemString(systemString) { for (let i = 0; i &lt; keySystems.length; i++) { if (keySystems[i].systemString === systemString) { return keySystems[i]; } } return null; } /** * Determines whether the given key system is ClearKey. This is * necessary because the EME spec defines ClearKey and its method * for providing keys to the key session; and this method has changed * between the various API versions. Our EME-specific ProtectionModels * must know if the system is ClearKey so that it can format the keys * according to the particular spec version. * * @param {Object} keySystem the key * @returns {boolean} true if this is the ClearKey key system, false * otherwise * @memberof module:ProtectionKeyController * @instance */ function isClearKey(keySystem) { return (keySystem === clearkeyKeySystem || keySystem === clearkeyW3CKeySystem); } /** * Check equality of initData array buffers. * * @param {ArrayBuffer} initData1 - first initData * @param {ArrayBuffer} initData2 - second initData * @returns {boolean} true if the initData arrays are equal in size and * contents, false otherwise * @memberof module:ProtectionKeyController * @instance */ function initDataEquals(initData1, initData2) { if (initData1.byteLength === initData2.byteLength) { let data1 = new Uint8Array(initData1); let data2 = new Uint8Array(initData2); for (let j = 0; j &lt; data1.length; j++) { if (data1[j] !== data2[j]) { return false; } } return true; } return false; } /** * Returns a set of supported key systems and CENC initialization data * from the given array of ContentProtection elements. Only * key systems that are supported by this player will be returned. * Key systems are returned in priority order (highest first). * * @param {Array.&lt;Object&gt;} cps - array of content protection elements parsed * from the manifest * @returns {Array.&lt;Object&gt;} array of objects indicating which supported key * systems were found. Empty array is returned if no * supported key systems were found * @memberof module:ProtectionKeyController * @instance */ function getSupportedKeySystemsFromContentProtection(cps) { let cp, ks, ksIdx, cpIdx; let supportedKS = []; if (cps) { const cencContentProtection = CommonEncryption.findCencContentProtection(cps); for (ksIdx = 0; ksIdx &lt; keySystems.length; ++ksIdx) { ks = keySystems[ksIdx]; for (cpIdx = 0; cpIdx &lt; cps.length; ++cpIdx) { cp = cps[cpIdx]; if (cp.schemeIdUri.toLowerCase() === ks.schemeIdURI) { // Look for DRM-specific ContentProtection let initData = ks.getInitData(cp, cencContentProtection); supportedKS.push({ ks: keySystems[ksIdx], initData: initData, cdmData: ks.getCDMData(), sessionId: ks.getSessionId(cp) }); } } } } return supportedKS; } /** * Returns key systems supported by this player for the given PSSH * initializationData. Only key systems supported by this player * that have protection data present will be returned. Key systems are returned in priority order * (highest priority first) * * @param {ArrayBuffer} initData Concatenated PSSH data for all DRMs * supported by the content * @param {ProtectionData} protDataSet user specified protection data - license server url etc * supported by the content * @returns {Array.&lt;Object&gt;} array of objects indicating which supported key * systems were found. Empty array is returned if no * supported key systems were found * @memberof module:ProtectionKeyController * @instance */ function getSupportedKeySystems(initData, protDataSet) { let supportedKS = []; let pssh = CommonEncryption.parsePSSHList(initData); let ks, keySystemString, shouldNotFilterOutKeySystem; for (let ksIdx = 0; ksIdx &lt; keySystems.length; ++ksIdx) { ks = keySystems[ksIdx]; keySystemString = ks.systemString; shouldNotFilterOutKeySystem = (protDataSet) ? keySystemString in protDataSet : true; if (ks.uuid in pssh &amp;&amp; shouldNotFilterOutKeySystem) { supportedKS.push({ ks: ks, initData: pssh[ks.uuid], cdmData: ks.getCDMData(), sessionId: ks.getSessionId() }); } } return supportedKS; } /** * Returns the license server implementation data that should be used for this request. * * @param {KeySystem} keySystem the key system * associated with this license request * @param {ProtectionData} protData protection data to use for the * request * @param {string} [messageType=\"license-request\"] the message type associated with this * request. Supported message types can be found * {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {LicenseServer|null} the license server * implementation that should be used for this request or null if the player should not * pass messages of the given type to a license server * @memberof module:ProtectionKeyController * @instance * */ function getLicenseServer(keySystem, protData, messageType) { // Our default server implementations do not do anything with \"license-release\" or // \"individualization-request\" messages, so we just send a success event if (messageType === 'license-release' || messageType === 'individualization-request') { return null; } let licenseServerData = null; if (protData &amp;&amp; protData.hasOwnProperty('drmtoday')) { licenseServerData = DRMToday(context).getInstance({BASE64: BASE64}); } else if (keySystem.systemString === ProtectionConstants.WIDEVINE_KEYSTEM_STRING) { licenseServerData = Widevine(context).getInstance(); } else if (keySystem.systemString === ProtectionConstants.PLAYREADY_KEYSTEM_STRING) { licenseServerData = PlayReady(context).getInstance(); } else if (keySystem.systemString === ProtectionConstants.CLEARKEY_KEYSTEM_STRING) { licenseServerData = ClearKey(context).getInstance(); } return licenseServerData; } /** * Allows application-specific retrieval of ClearKey keys. * * @param {KeySystem} clearkeyKeySystem They exact ClearKey System to be used * @param {ProtectionData} protData protection data to use for the * request * @param {ArrayBuffer} message the key message from the CDM * @return {ClearKeyKeySet|null} the clear keys associated with * the request or null if no keys can be returned by this function * @memberof module:ProtectionKeyController * @instance */ function processClearKeyLicenseRequest(clearkeyKeySystem, protData, message) { try { return clearkeyKeySystem.getClearKeysFromProtectionData(protData, message); } catch (error) { logger.error('Failed to retrieve clearkeys from ProtectionData'); return null; } } function setProtectionData(protectionDataSet) { var getProtectionData = function (keySystemString) { var protData = null; if (protectionDataSet) { protData = (keySystemString in protectionDataSet) ? protectionDataSet[keySystemString] : null; } return protData; }; for (var i = 0; i &lt; keySystems.length; i++) { var keySystem = keySystems[i]; if (keySystem.hasOwnProperty('init')) { keySystem.init(getProtectionData(keySystem.systemString)); } } } instance = { initialize: initialize, setProtectionData: setProtectionData, isClearKey: isClearKey, initDataEquals: initDataEquals, getKeySystems: getKeySystems, setKeySystems: setKeySystems, getKeySystemBySystemString: getKeySystemBySystemString, getSupportedKeySystemsFromContentProtection: getSupportedKeySystemsFromContentProtection, getSupportedKeySystems: getSupportedKeySystems, getLicenseServer: getLicenseServer, processClearKeyLicenseRequest: processClearKeyLicenseRequest, setConfig: setConfig }; return instance; } ProtectionKeyController.__dashjs_factory_name = 'ProtectionKeyController'; export default dashjs.FactoryMaker.getSingletonFactory(ProtectionKeyController); /* jshint ignore:line */ × Search results Close "},"core_Settings.js.html":{"id":"core_Settings.js.html","title":"Source: core/Settings.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: core/Settings.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from './FactoryMaker'; import Utils from './Utils.js'; import Debug from '../core/Debug'; import Constants from '../streaming/constants/Constants'; import {HTTPRequest} from '../streaming/vo/metrics/HTTPRequest'; /** @module Settings * @description Define the configuration parameters of Dash.js MediaPlayer. * @see {@link module:Settings~PlayerSettings PlayerSettings} for further information about the supported configuration properties */ /** * @typedef {Object} PlayerSettings * @property {module:Settings~DebugSettings} [debug] Debug related settings * @property {module:Settings~StreamingSettings} [streaming] Streaming related settings * @example * * // Full settings object * settings = { * debug: { * logLevel: Debug.LOG_LEVEL_WARNING * }, * streaming: { * metricsMaxListDepth: 1000, * abandonLoadTimeout: 10000, * liveDelayFragmentCount: NaN, * liveDelay: null, * scheduleWhilePaused: true, * fastSwitchEnabled: false, * flushBufferAtTrackSwitch: false, * bufferPruningInterval: 10, * bufferToKeep: 20, * jumpGaps: true, * jumpLargeGaps: true, * smallGapLimit: 1.5, * stableBufferTime: 12, * bufferTimeAtTopQuality: 30, * bufferTimeAtTopQualityLongForm: 60, * longFormContentDurationThreshold: 600, * wallclockTimeUpdateInterval: 50, * lowLatencyEnabled: false, * keepProtectionMediaKeys: false, * useManifestDateHeaderTimeSource: true, * useSuggestedPresentationDelay: true, * useAppendWindow: true, * manifestUpdateRetryInterval: 100, * liveCatchUpMinDrift: 0.02, * liveCatchUpMaxDrift: 0, * liveCatchUpPlaybackRate: 0.5, * lastBitrateCachingInfo: { enabled: true, ttl: 360000 }, * lastMediaSettingsCachingInfo: { enabled: true, ttl: 360000 }, * cacheLoadThresholds: { video: 50, audio: 5 }, * retryIntervals: { * MPD: 500, * XLinkExpansion: 500, * InitializationSegment: 1000, * IndexSegment: 1000, * MediaSegment: 1000, * BitstreamSwitchingSegment: 1000, * other: 1000, * lowLatencyReductionFactor: 10 * }, * retryAttempts: { * MPD: 3, * XLinkExpansion: 1, * InitializationSegment: 3, * IndexSegment: 3, * MediaSegment: 3, * BitstreamSwitchingSegment: 3, * other: 3, * lowLatencyMultiplyFactor: 5 * }, * abr: { * movingAverageMethod: Constants.MOVING_AVERAGE_SLIDING_WINDOW, * ABRStrategy: Constants.ABR_STRATEGY_DYNAMIC, * bandwidthSafetyFactor: 0.9, * useDefaultABRRules: true, * useBufferOccupancyABR: false, * useDeadTimeLatency: true, * limitBitrateByPortal: false, * usePixelRatioInLimitBitrateByPortal: false, * maxBitrate: { audio: -1, video: -1 }, * minBitrate: { audio: -1, video: -1 }, * maxRepresentationRatio: { audio: 1, video: 1 }, * initialBitrate: { audio: -1, video: -1 }, * initialRepresentationRatio: { audio: -1, video: -1 }, * autoSwitchBitrate: { audio: true, video: true } * }, * cmcd: { * enabled: false, * sid: null, * cid: null, * did: null * } * } * } */ /** * @typedef {Object} DebugSettings * @property {number} [logLevel=dashjs.Debug.LOG_LEVEL_WARNING] * Sets up the log level. The levels are cumulative. For example, if you set the log level * to dashjs.Debug.LOG_LEVEL_WARNING all warnings, errors and fatals will be logged. Possible values. * * &lt;ul&gt; * &lt;li&gt;dashjs.Debug.LOG_LEVEL_NONE&lt;br/&gt; * No message is written in the browser console. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_FATAL&lt;br/&gt; * Log fatal errors. An error is considered fatal when it causes playback to fail completely. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_ERROR&lt;br/&gt; * Log error messages. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_WARNING&lt;br/&gt; * Log warning messages. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_INFO&lt;br/&gt; * Log info messages. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_DEBUG&lt;br/&gt; * Log debug messages. * &lt;/ul&gt; */ /** * @typedef {Object} AbrSettings * @property {string} [movingAverageMethod=\"slidingWindow\"] * Sets the moving average method used for smoothing throughput estimates. Valid methods are * \"slidingWindow\" and \"ewma\". The call has no effect if an invalid method is passed. * * The sliding window moving average method computes the average throughput using the last four segments downloaded. * If the stream is live (as opposed to VOD), then only the last three segments are used. * If wide variations in throughput are detected, the number of segments can be dynamically increased to avoid oscillations. * * The exponentially weighted moving average (EWMA) method computes the average using exponential smoothing. * Two separate estimates are maintained, a fast one with a three-second half life and a slow one with an eight-second half life. * The throughput estimate at any time is the minimum of the fast and slow estimates. * This allows a fast reaction to a bandwidth drop and prevents oscillations on bandwidth spikes. * @property {string} [ABRStrategy=\"abrDynamic\"] Returns the current ABR strategy being used: \"abrDynamic\", \"abrBola\" or \"abrThroughput\". * @property {number} [bandwidthSafetyFactor=0.9] * Standard ABR throughput rules multiply the throughput by this value. It should be between 0 and 1, * with lower values giving less rebuffering (but also lower quality). * @property {boolean} [useDefaultABRRules=true] Should the default ABR rules be used, or the custom ones added. * @property {boolean} [useBufferOccupancyABR=false] Whether to use the BOLA abr rule. * @property {boolean} [useDeadTimeLatency=true] * If true, only the download portion will be considered part of the download bitrate * and latency will be regarded as static. If false, the reciprocal of the whole * transfer time will be used. * @property {boolean} [limitBitrateByPortal=false] If true, the size of the video portal will limit the max chosen video resolution. * @property {boolean} [usePixelRatioInLimitBitrateByPortal=false] * Sets whether to take into account the device's pixel ratio when defining the portal dimensions. * Useful on, for example, retina displays. * @property {module:Settings~AudioVideoSettings} [maxBitrate={audio: -1, video: -1}] The maximum bitrate that the ABR algorithms will choose. Use NaN for no limit. * @property {module:Settings~AudioVideoSettings} [minBitrate={audio: -1, video: -1}] The minimum bitrate that the ABR algorithms will choose. Use NaN for no limit. * @property {module:Settings~AudioVideoSettings} [maxRepresentationRatio={audio: 1, video: 1}] * When switching multi-bitrate content (auto or manual mode) this property specifies the maximum representation allowed, * as a proportion of the size of the representation set. * * You can set or remove this cap at anytime before or during playback. To clear this setting you set the value to 1. * * If both this and maxAllowedBitrate are defined, maxAllowedBitrate is evaluated first, then maxAllowedRepresentation, * i.e. the lowest value from executing these rules is used. * * This feature is typically used to reserve higher representations for playback only when connected over a fast connection. * @property {module:Settings~AudioVideoSettings} [initialBitrate={audio: -1, video: -1}] Explicitly set the starting bitrate for audio or video * @property {module:Settings~AudioVideoSettings} [initialRepresentationRatio={audio: -1, video: -1}] Explicitly set the initial representation ratio. If initalBitrate is specified, this is ignored. * @property {module:Settings~AudioVideoSettings} [autoSwitchBitrate={audio: true, video: true}] Indicates whether the player should enable ABR algorithms to switch the bitrate. */ /** * @typedef {Object} StreamingSettings * @property {number} [metricsMaxListDepth=1000] Maximum list depth of metrics. * @property {number} [abandonLoadTimeout=10000] * A timeout value in seconds, which during the ABRController will block switch-up events. * This will only take effect after an abandoned fragment event occurs. * @property {number} [liveDelayFragmentCount=NaN] * Changing this value will lower or increase live stream latency. The detected segment duration will be multiplied by this value * to define a time in seconds to delay a live stream from the live edge. Lowering this value will lower latency but may decrease * the player's ability to build a stable buffer. * @property {number} [liveDelay] * &lt;p&gt;Equivalent in seconds of setLiveDelayFragmentCount&lt;/p&gt; * &lt;p&gt;Lowering this value will lower latency but may decrease the player's ability to build a stable buffer.&lt;/p&gt; * &lt;p&gt;This value should be less than the manifest duration by a couple of segment durations to avoid playback issues&lt;/p&gt; * &lt;p&gt;If set, this parameter will take precedence over setLiveDelayFragmentCount and manifest info&lt;/p&gt; * @property {boolean} [scheduleWhilePaused=true] * Set to true if you would like dash.js to keep downloading fragments in the background * when the video element is paused. * @property {boolean} [fastSwitchEnabled=false] * When enabled, after an ABR up-switch in quality, instead of requesting and appending the next fragment * at the end of the current buffer range it is requested and appended closer to the current time * When enabled, The maximum time to render a higher quality is current time + (1.5 * fragment duration). * * Note, When ABR down-switch is detected, we appended the lower quality at the end of the buffer range to preserve the * higher quality media for as long as possible. * * If enabled, it should be noted there are a few cases when the client will not replace inside buffer range but rather * just append at the end. 1. When the buffer level is less than one fragment duration 2. The client * is in an Abandonment State due to recent fragment abandonment event. * * Known issues: * 1. In IE11 with auto switching off, if a user switches to a quality they can not download in time the * fragment may be appended in the same range as the playhead or even in the past, in IE11 it may cause a stutter * or stall in playback. * @property {boolean} [flushBufferAtTrackSwitch=false] * When enabled, after a track switch and in case buffer is being replaced (see MEdiaPlayer.setTrackSwitchModeFor(MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE)), * the video element is flushed (seek at current playback time) once a segment of the new track is appended in buffer in order to force video decoder to play new track. * This can be required on some devices like GoogleCast devices to make track switching functional. Otherwise track switching will be effective only once after previous * buffered track is fully consumed. * @property {boolean} [calcSegmentAvailabilityRangeFromTimeline=true] Enable calculation of the DVR window for SegmentTimeline manifests based on the entries in &lt;SegmentTimeline&gt; * @property {number} [bufferPruningInterval=10] The interval of pruning buffer in sconds. * @property {number} [bufferToKeep=20] * This value influences the buffer pruning logic. * Allows you to modify the buffer that is kept in source buffer in seconds. * 0|-----------bufferToPrune-----------|-----bufferToKeep-----|currentTime| * @property {boolean} [jumpGaps=true] Sets whether player should jump small gaps (discontinuities) in the buffer. * @property {boolean} [jumpLargeGaps=true] Sets whether player should jump large gaps (discontinuities) in the buffer. * @property {number} [smallGapLimit=1.8] Time in seconds for a gap to be considered small. * @property {number} [stableBufferTime=12] * The time that the internal buffer target will be set to post startup/seeks (NOT top quality). * * When the time is set higher than the default you will have to wait longer * to see automatic bitrate switches but will have a larger buffer which * will increase stability. * @property {number} [bufferTimeAtTopQuality=30] * The time that the internal buffer target will be set to once playing the top quality. * If there are multiple bitrates in your adaptation, and the media is playing at the highest * bitrate, then we try to build a larger buffer at the top quality to increase stability * and to maintain media quality. * @property {number} [bufferTimeAtTopQualityLongForm=60] The time that the internal buffer target will be set to once playing the top quality for long form content. * @property {number} [longFormContentDurationThreshold=600] * The threshold which defines if the media is considered long form content. * This will directly affect the buffer targets when playing back at the top quality. * @property {number} [wallclockTimeUpdateInterval=50] How frequently the wallclockTimeUpdated internal event is triggered (in milliseconds). * @property {boolean} [lowLatencyEnabled=false] Enable or disable low latency mode * @property {boolean} [keepProtectionMediaKeys=false] * Set the value for the ProtectionController and MediaKeys life cycle. If true, the * ProtectionController and then created MediaKeys and MediaKeySessions will be preserved during * the MediaPlayer lifetime. * @property {boolean} [useManifestDateHeaderTimeSource=true] * &lt;p&gt;Allows you to enable the use of the Date Header, if exposed with CORS, as a timing source for live edge detection. The * use of the date header will happen only after the other timing source that take precedence fail or are omitted as described. * @property {boolean} [useSuggestedPresentationDelay=true] * &lt;p&gt;Set to true if you would like to override the default live delay and honor the SuggestedPresentationDelay attribute in by the manifest.&lt;/p&gt; * @property {boolean} [useAppendWindow=true] * Specifies if the appendWindow attributes of the MSE SourceBuffers should be set according to content duration from manifest. * @property {number} [manifestUpdateRetryInterval=100] * For live streams, set the interval-frequency in milliseconds at which * dash.js will check if the current manifest is still processed before * downloading the next manifest once the minimumUpdatePeriod time has * @property {number} [liveCatchUpMinDrift=0.02] * Use this method to set the minimum latency deviation allowed before activating catch-up mechanism. In low latency mode, * when the difference between the measured latency and the target one, * as an absolute number, is higher than the one sets with this method, then dash.js increases/decreases * playback rate until target latency is reached. * * LowLatencyMinDrift should be provided in seconds, and it uses values between 0.0 and 0.5. * * Note: Catch-up mechanism is only applied when playing low latency live streams. * @property {number} [liveCatchUpMaxDrift=0] * Use this method to set the maximum latency deviation allowed before dash.js to do a seeking to live position. In low latency mode, * when the difference between the measured latency and the target one, * as an absolute number, is higher than the one sets with this method, then dash.js does a seek to live edge position minus * the target live delay. * * LowLatencyMaxDriftBeforeSeeking should be provided in seconds. If 0, then seeking operations won't be used for * fixing latency deviations. * * Note: Catch-up mechanism is only applied when playing low latency live streams. * @property {number} [liveCatchUpPlaybackRate=0.5] * Use this parameter to set the maximum catch up rate, as a percentage, for low latency live streams. In low latency mode, * when measured latency is higher/lower than the target one, * dash.js increases/decreases playback rate respectively up to (+/-) the percentage defined with this method until target is reached. * * Valid values for catch up rate are in range 0-0.5 (0-50%). Set it to 0 to turn off live catch up feature. * * Note: Catch-up mechanism is only applied when playing low latency live streams. * @property {number} [liveCatchupLatencyThreshold=NaN] * Use this parameter to set the maximum threshold for which live catch up is applied. For instance, if this value is set to 8 seconds, * then live catchup is only applied if the current live latency is equal or below 8 seconds. The reason behind this parameter is to avoid an increase * of the playback rate if the user seeks within the DVR window. * * If no value is specified this will be twice the maximum live delay. The maximum live delay is either specified in the manifest as part of a ServiceDescriptor or calculated the following: * maximumLiveDelay = targetDelay + liveCatchupMinDrift * * Note: Catch-up mechanism is only applied when playing low latency live streams. * @property {module:Settings~CachingInfoSettings} [lastBitrateCachingInfo={enabled: true, ttl: 360000}] * Set to false if you would like to disable the last known bit rate from being stored during playback and used * to set the initial bit rate for subsequent playback within the expiration window. * * The default expiration is one hour, defined in milliseconds. If expired, the default initial bit rate (closest to 1000 kbps) will be used * for that session and a new bit rate will be stored during that session. * @property {module:Settings~CachingInfoSettings} [lastMediaSettingsCachingInfo={enabled: true, ttl: 360000}] * Set to false if you would like to disable the last known lang for audio (or camera angle for video) from being stored during playback and used * to set the initial settings for subsequent playback within the expiration window. * * The default expiration is one hour, defined in milliseconds. If expired, the default settings will be used * for that session and a new settings will be stored during that session. * @property {module:Settings~AudioVideoSettings} [cacheLoadThresholds={video: 50, audio: 5}] * For a given media type, the threshold which defines if the response to a fragment * request is coming from browser cache or not. * @property {module:Settings~RequestTypeSettings} [retryIntervals] Time in milliseconds of which to reload a failed file load attempt. For low latency mode these values are divided by lowLatencyReductionFactor. * @property {module:Settings~RequestTypeSettings} [retryAttempts] Total number of retry attempts that will occur on a file load before it fails. For low latency mode these values are multiplied by lowLatencyMultiplyFactor. * @property {module:Settings~AbrSettings} abr Adaptive Bitrate algorithm related settings. * @property {module:Settings~CmcdSettings} cmcd Settings related to Common Media Client Data reporting. */ /** * @typedef {Object} CachingInfoSettings * @property {boolean} [enable] Enable or disable the caching feature. * @property {number} [ttl] Time to live. A value defined in milliseconds representing how log to cache the settings for. */ /** * @typedef {Object} module:Settings~AudioVideoSettings * @property {number|boolean} [audio] Configuration for audio media type of tracks. * @property {number|boolean} [video] Configuration for video media type of tracks. */ /** * @typedef {Object} RequestTypeSettings * @property {number} [MPD] Manifest type of requests * @property {number} [XLinkExpansion] XLink expansion type of requests * @property {number} [InitializationSegment] Request to retrieve an initialization segment * @property {number} [IndexSegment] Request to retrieve an index segment (SegmentBase) * @property {number} [MediaSegment] Request to retrieve a media segment (video/audio/image/text chunk) * @property {number} [BitstreamSwitchingSegment] Bitrate stream switching type of request * @property {number} [other] Other type of request * */ /** * @typedef {Object} module:Settings~CmcdSettings * @property {boolean} [enable=false] Enable or disable the CMCD reporting. * @property {string} [sid] GUID identifying the current playback session. Should be in UUID format. If not specified a UUID will be automatically generated. * @property {string} [cid] A unique string to identify the current content. If not specified it will be a hash of the MPD url. * @property {string} [did=dash.js-cmcd-default-id] A unique string identifying the current device. */ /** * @class * @ignore */ function Settings() { let instance; /** * @const {PlayerSettings} defaultSettings * @ignore */ const defaultSettings = { debug: { logLevel: Debug.LOG_LEVEL_WARNING }, streaming: { metricsMaxListDepth: 1000, abandonLoadTimeout: 10000, liveDelayFragmentCount: NaN, liveDelay: null, scheduleWhilePaused: true, fastSwitchEnabled: false, flushBufferAtTrackSwitch: false, calcSegmentAvailabilityRangeFromTimeline: true, bufferPruningInterval: 10, bufferToKeep: 20, jumpGaps: true, jumpLargeGaps: true, smallGapLimit: 1.5, stableBufferTime: 12, bufferTimeAtTopQuality: 30, bufferTimeAtTopQualityLongForm: 60, longFormContentDurationThreshold: 600, wallclockTimeUpdateInterval: 50, lowLatencyEnabled: false, keepProtectionMediaKeys: false, useManifestDateHeaderTimeSource: true, useSuggestedPresentationDelay: true, useAppendWindow: true, manifestUpdateRetryInterval: 100, liveCatchUpMinDrift: 0.02, liveCatchUpMaxDrift: 0, liveCatchUpPlaybackRate: 0.5, liveCatchupLatencyThreshold: NaN, lastBitrateCachingInfo: {enabled: true, ttl: 360000}, lastMediaSettingsCachingInfo: {enabled: true, ttl: 360000}, cacheLoadThresholds: {video: 50, audio: 5}, retryIntervals: { [HTTPRequest.MPD_TYPE]: 500, [HTTPRequest.XLINK_EXPANSION_TYPE]: 500, [HTTPRequest.MEDIA_SEGMENT_TYPE]: 1000, [HTTPRequest.INIT_SEGMENT_TYPE]: 1000, [HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE]: 1000, [HTTPRequest.INDEX_SEGMENT_TYPE]: 1000, [HTTPRequest.OTHER_TYPE]: 1000, lowLatencyReductionFactor: 10 }, retryAttempts: { [HTTPRequest.MPD_TYPE]: 3, [HTTPRequest.XLINK_EXPANSION_TYPE]: 1, [HTTPRequest.MEDIA_SEGMENT_TYPE]: 3, [HTTPRequest.INIT_SEGMENT_TYPE]: 3, [HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE]: 3, [HTTPRequest.INDEX_SEGMENT_TYPE]: 3, [HTTPRequest.OTHER_TYPE]: 3, lowLatencyMultiplyFactor: 5 }, abr: { movingAverageMethod: Constants.MOVING_AVERAGE_SLIDING_WINDOW, ABRStrategy: Constants.ABR_STRATEGY_DYNAMIC, bandwidthSafetyFactor: 0.9, useDefaultABRRules: true, useBufferOccupancyABR: false, useDeadTimeLatency: true, limitBitrateByPortal: false, usePixelRatioInLimitBitrateByPortal: false, maxBitrate: {audio: -1, video: -1}, minBitrate: {audio: -1, video: -1}, maxRepresentationRatio: {audio: 1, video: 1}, initialBitrate: {audio: -1, video: -1}, initialRepresentationRatio: {audio: -1, video: -1}, autoSwitchBitrate: {audio: true, video: true} }, cmcd: { enabled: false, sid: null, cid: null, did: null } } }; let settings = Utils.clone(defaultSettings); //Merge in the settings. If something exists in the new config that doesn't match the schema of the default config, //regard it as an error and log it. function mixinSettings(source, dest, path) { for (let n in source) { if (source.hasOwnProperty(n)) { if (dest.hasOwnProperty(n)) { if (typeof source[n] === 'object' &amp;&amp; source[n] !== null) { mixinSettings(source[n], dest[n], path.slice() + n + '.'); } else { dest[n] = Utils.clone(source[n]); } } } } } /** * Return the settings object. Don't copy/store this object, you won't get updates. * @func * @instance */ function get() { return settings; } /** * @func * @instance * @param {object} settingsObj - This should be a partial object of the Settings.Schema type. That is, fields defined should match the path (e.g. * settingsObj.streaming.abr.autoSwitchBitrate.audio -&gt; defaultSettings.streaming.abr.autoSwitchBitrate.audio). Where an element's path does * not match it is ignored, and a warning is logged. * * Use to change the settings object. Any new values defined will overwrite the settings and anything undefined will not change. * Implementers of new settings should add it in an approriate namespace to the defaultSettings object and give it a default value (that is not undefined). * */ function update(settingsObj) { if (typeof settingsObj === 'object') { mixinSettings(settingsObj, settings, ''); } } /** * Resets the settings object. Everything is set to its default value. * @func * @instance * */ function reset() { settings = Utils.clone(defaultSettings); } instance = { get: get, update: update, reset: reset }; return instance; } Settings.__dashjs_factory_name = 'Settings'; let factory = FactoryMaker.getSingletonFactory(Settings); export default factory; × Search results Close "},"streaming_models_URIFragmentModel.js.html":{"id":"streaming_models_URIFragmentModel.js.html","title":"Source: streaming/models/URIFragmentModel.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/models/URIFragmentModel.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import URIFragmentData from '../vo/URIFragmentData'; import FactoryMaker from '../../core/FactoryMaker'; /** * Model class managing URI fragments. * @ignore */ function URIFragmentModel() { let instance, URIFragmentDataVO; /** * @param {string} uri The URI to parse for fragment extraction * @memberof module:URIFragmentModel * @instance */ function initialize(uri) { URIFragmentDataVO = new URIFragmentData(); if (!uri) return null; const hashIndex = uri.indexOf('#'); if (hashIndex !== -1) { const fragments = uri.substr(hashIndex + 1).split('&amp;'); for (let i = 0, len = fragments.length; i &lt; len; ++i) { const fragment = fragments[i]; const equalIndex = fragment.indexOf('='); if (equalIndex !== -1) { const key = fragment.substring(0,equalIndex); if (URIFragmentDataVO.hasOwnProperty(key)) { URIFragmentDataVO[key] = fragment.substr(equalIndex + 1); } } } } } /** * @returns {URIFragmentData} Object containing supported URI fragments * @memberof module:URIFragmentModel * @instance */ function getURIFragmentData() { return URIFragmentDataVO; } instance = { initialize: initialize, getURIFragmentData: getURIFragmentData }; return instance; } URIFragmentModel.__dashjs_factory_name = 'URIFragmentModel'; export default FactoryMaker.getSingletonFactory(URIFragmentModel); × Search results Close "},"streaming_utils_URLUtils.js.html":{"id":"streaming_utils_URLUtils.js.html","title":"Source: streaming/utils/URLUtils.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/URLUtils.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import DefaultURLUtils from './DefaultURLUtils'; /** * @module URLUtils * @ignore * @description Provides utility functions for operating on URLs. * Initially this is simply a method to determine the Base URL of a URL, but * should probably include other things provided all over the place such as * determining whether a URL is relative/absolute, resolving two paths etc. */ function URLUtils() { let instance; let defaultURLUtils; let regexUtils = []; const context = this.context; function getUtils(url) { let i; for (i = 0; i &lt; regexUtils.length; i++) { let regex = regexUtils[i].regex; if (regex.test(url)) { return regexUtils[i].utils; } } return defaultURLUtils; } function setup() { defaultURLUtils = DefaultURLUtils(context).getInstance(); } /** * Register a module to handle specific url. * @param {regex} regex - url regex * @param {object} utils - object that handles the regex * @memberof module:URLUtils * @instance */ function registerUrlRegex(regex, utils) { regexUtils.push({regex: regex, utils: utils}); } function internalCall(functionName, url, baseUrl) { let utils = getUtils(baseUrl || url); return utils &amp;&amp; typeof (utils[functionName]) === 'function' ? utils[functionName](url, baseUrl) : defaultURLUtils[functionName](url, baseUrl); } /** * Returns a string that contains the Base URL of a URL, if determinable. * @param {string} url - full url * @return {string} * @memberof module:URLUtils * @instance */ function parseBaseUrl(url) { return internalCall('parseBaseUrl', url); } /** * Returns a string that contains the scheme and origin of a URL, * if determinable. * @param {string} url - full url * @return {string} * @memberof module:URLUtils * @instance */ function parseOrigin(url) { return internalCall('parseOrigin', url); } /** * Returns a string that contains the fragment of a URL without scheme, * if determinable. * @param {string} url - full url * @return {string} * @memberof module:URLUtils * @instance */ function removeHostname(url) { return internalCall('removeHostname', url); } /** * Returns a string that contains the scheme of a URL, if determinable. * @param {string} url - full url * @return {string} * @memberof module:URLUtils * @instance */ function parseScheme(url) { return internalCall('parseScheme', url); } /** * Determines whether the url is relative. * @return {boolean} * @param {string} url * @memberof module:URLUtils * @instance */ function isRelative(url) { return internalCall('isRelative', url); } /** * Determines whether the url is path-absolute. * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isPathAbsolute(url) { return internalCall('isPathAbsolute', url); } /** * Determines whether the url is scheme-relative. * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isSchemeRelative(url) { return internalCall('isSchemeRelative', url); } /** * Determines whether the url is an HTTP-URL as defined in ISO/IEC * 23009-1:2014 3.1.15. ie URL with a fixed scheme of http or https * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isHTTPURL(url) { return internalCall('isHTTPURL', url); } /** * Determines whether the supplied url has https scheme * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isHTTPS(url) { return internalCall('isHTTPS', url); } /** * Resolves a url given an optional base url * @return {string} * @param {string} url * @param {string} [baseUrl] * @memberof module:URLUtils * @instance */ function resolve(url, baseUrl) { return internalCall('resolve', url, baseUrl); } setup(); instance = { registerUrlRegex: registerUrlRegex, parseBaseUrl: parseBaseUrl, parseOrigin: parseOrigin, parseScheme: parseScheme, isRelative: isRelative, isPathAbsolute: isPathAbsolute, isSchemeRelative: isSchemeRelative, isHTTPURL: isHTTPURL, isHTTPS: isHTTPS, removeHostname: removeHostname, resolve: resolve }; return instance; } URLUtils.__dashjs_factory_name = 'URLUtils'; const factory = FactoryMaker.getSingletonFactory(URLUtils); export default factory; × Search results Close "},"mss_errors_MssErrors.js.html":{"id":"mss_errors_MssErrors.js.html","title":"Source: mss/errors/MssErrors.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: mss/errors/MssErrors.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import ErrorsBase from '../../core/errors/ErrorsBase'; /** * @class * */ class MssErrors extends ErrorsBase { constructor () { super(); /** * Error code returned when no tfrf box is detected in MSS live stream */ this.MSS_NO_TFRF_CODE = 200; /** * Error code returned when one of the codecs defined in the manifest is not supported */ this.MSS_UNSUPPORTED_CODEC_CODE = 201; this.MSS_NO_TFRF_MESSAGE = 'Missing tfrf in live media segment'; this.MSS_UNSUPPORTED_CODEC_MESSAGE = 'Unsupported codec'; } } let mssErrors = new MssErrors(); export default mssErrors; × Search results Close "},"offline_OfflineDownload.js.html":{"id":"offline_OfflineDownload.js.html","title":"Source: offline/OfflineDownload.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/OfflineDownload.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import OfflineConstants from './constants/OfflineConstants'; import OfflineStream from './OfflineStream'; import OfflineIndexDBManifestParser from './utils/OfflineIndexDBManifestParser'; import OfflineErrors from './errors/OfflineErrors'; import DashParser from '../dash/parser/DashParser'; function OfflineDownload(config) { config = config || {}; const context = this.context; const manifestLoader = config.manifestLoader; const mediaPlayerModel = config.mediaPlayerModel; const abrController = config.abrController; const playbackController = config.playbackController; const adapter = config.adapter; const dashMetrics = config.dashMetrics; const timelineConverter = config.timelineConverter; const offlineStoreController = config.offlineStoreController; const manifestId = config.id; const eventBus = config.eventBus; const errHandler = config.errHandler; const events = config.events; const errors = config.errors; const settings = config.settings; const debug = config.debug; const manifestUpdater = config.manifestUpdater; const baseURLController = config.baseURLController; const constants = config.constants; const dashConstants = config.dashConstants; const urlUtils = config.urlUtils; let instance, logger, _manifestURL, _offlineURL, _xmlManifest, _streams, _manifest, _isDownloadingStatus, _isComposed, _representationsToUpdate, _indexDBManifestParser, _progressionById, _progression, _status; function setup() { logger = debug.getLogger(instance); manifestUpdater.initialize(); _streams = []; _isDownloadingStatus = false; _isComposed = false; _progressionById = {}; _progression = 0; _status = undefined; } function getId() { return manifestId; } function getOfflineUrl () { return _offlineURL; } function getManifestUrl () { return _manifestURL; } function getStatus () { return _status; } function setInitialState(state) { _offlineURL = state.url; _progression = state.progress; _manifestURL = state.originalUrl; _status = state.status; } /** * Download a stream, from url of manifest * @param {string} url * @instance */ function downloadFromUrl(url) { _manifestURL = url; _offlineURL = `${OfflineConstants.OFFLINE_SCHEME}://${manifestId}`; _status = OfflineConstants.OFFLINE_STATUS_CREATED; setupOfflineEvents(); let offlineManifest = { 'fragmentStore': manifestId, 'status': _status, 'manifestId': manifestId, 'url': _offlineURL, 'originalURL': url }; return createOfflineManifest(offlineManifest); } function initDownload() { manifestLoader.load(_manifestURL); _isDownloadingStatus = true; } function setupOfflineEvents() { eventBus.on(events.MANIFEST_UPDATED, onManifestUpdated, instance); eventBus.on(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance); setupIndexedDBEvents(); } function setupIndexedDBEvents() { eventBus.on(events.ERROR, onError, instance); } function isDownloading() { return _isDownloadingStatus; } function onManifestUpdated(e) { if (_isComposed) { return; } if (!e.error) { try { _manifest = e.manifest; } catch (err) { _status = OfflineConstants.OFFLINE_STATUS_ERROR; errHandler.error({ code: OfflineErrors.OFFLINE_ERROR, message: err.message, data: { id: manifestId, status: _status } }); } } } function onDownloadingStarted(e) { if (e.id !== manifestId) { return; } if (!e.error &amp;&amp; manifestId !== null) { _status = OfflineConstants.OFFLINE_STATUS_STARTED; offlineStoreController.setDownloadingStatus(manifestId, _status).then(function () { eventBus.trigger(events.OFFLINE_RECORD_STARTED, {id: manifestId, message: 'Downloading started for this stream !'}); }); } else { _status = OfflineConstants.OFFLINE_STATUS_ERROR; errHandler.error({ code: OfflineErrors.OFFLINE_ERROR, message: 'Cannot start download ', data: { id: manifestId, status: _status, error: e.error } }); } } function OnStreamProgression(stream, downloaded, available) { _progressionById[stream.getStreamInfo().id] = { downloaded, available }; let segments = 0; let allSegments = 0; let waitForAllProgress; for (var property in _progressionById) { if (_progressionById.hasOwnProperty(property)) { if (_progressionById[property] === null) { waitForAllProgress = true; } else { segments += _progressionById[property].downloaded; allSegments += _progressionById[property].available; } } } if (!waitForAllProgress) { // all progression have been started, we can compute global progression _progression = segments / allSegments; // store progression offlineStoreController.getManifestById(manifestId) .then((item) =&gt; { item.progress = _progression; return updateOfflineManifest(item); }); } } function onDownloadingFinished(e) { if (e.id !== manifestId) { return; } if (!e.error &amp;&amp; manifestId !== null) { _status = OfflineConstants.OFFLINE_STATUS_FINISHED; offlineStoreController.setDownloadingStatus(manifestId, _status) .then(function () { eventBus.trigger(events.OFFLINE_RECORD_FINISHED, {id: manifestId, message: 'Downloading has been successfully completed for this stream !'}); resetDownload(); }); } else { _status = OfflineConstants.OFFLINE_STATUS_ERROR; errHandler.error({ code: OfflineErrors.OFFLINE_ERROR, message: 'Error finishing download ', data: { id: manifestId, status: _status, error: e.error } }); } } function onManifestUpdateNeeded(e) { if (e.id !== manifestId) { return; } _representationsToUpdate = e.representations; if (_representationsToUpdate.length &gt; 0) { _indexDBManifestParser.parse(_xmlManifest, _representationsToUpdate).then(function (parsedManifest) { if (parsedManifest !== null &amp;&amp; manifestId !== null) { offlineStoreController.getManifestById(manifestId) .then((item) =&gt; { item.manifest = parsedManifest; return updateOfflineManifest(item); }) .then( function () { for (let i = 0, ln = _streams.length; i &lt; ln; i++) { _streams[i].startOfflineStreamProcessors(); } }); } else { throw 'falling parsing offline manifest'; } }).catch(function (err) { throw err; }); } } function composeStreams() { try { adapter.updatePeriods(_manifest); baseURLController.initialize(_manifest); const streamsInfo = adapter.getStreamsInfo(); if (streamsInfo.length === 0) { _status = OfflineConstants.OFFLINE_STATUS_ERROR; errHandler.error({ code: OfflineErrors.OFFLINE_ERROR, message: 'Cannot download - no streams', data: { id: manifestId, status: _status } }); } for (let i = 0, ln = streamsInfo.length; i &lt; ln; i++) { const streamInfo = streamsInfo[i]; let stream = OfflineStream(context).create({ id: manifestId, callbacks: { started: onDownloadingStarted, progression: OnStreamProgression, finished: onDownloadingFinished, updateManifestNeeded: onManifestUpdateNeeded }, constants: constants, dashConstants: dashConstants, eventBus: eventBus, events: events, errors: errors, settings: settings, debug: debug, errHandler: errHandler, mediaPlayerModel: mediaPlayerModel, abrController: abrController, playbackController: playbackController, dashMetrics: dashMetrics, baseURLController: baseURLController, timelineConverter: timelineConverter, adapter: adapter, offlineStoreController: offlineStoreController }); _streams.push(stream); // initialise stream and get downloadable representations stream.initialize(streamInfo); _progressionById[streamInfo.id] = null; } _isComposed = true; } catch (e) { logger.info(e); _status = OfflineConstants.OFFLINE_STATUS_ERROR; errHandler.error({ code: OfflineErrors.OFFLINE_ERROR, message: e.message, data: { id: manifestId, status: _status, error: e.error } }); } } function getMediaInfos() { _streams.forEach(stream =&gt; { stream.getMediaInfos(); }); } /** * Init databsse to store fragments * @param {number} manifestId * @instance */ function createFragmentStore(manifestId) { return offlineStoreController.createFragmentStore(manifestId); } /** * Store in database the string representation of offline manifest (with only downloaded representations) * @param {object} offlineManifest * @instance */ function createOfflineManifest(offlineManifest) { return offlineStoreController.createOfflineManifest(offlineManifest); } /** * Store in database the string representation of offline manifest (with only downloaded representations) * @param {object} offlineManifest * @instance */ function updateOfflineManifest(offlineManifest) { return offlineStoreController.updateOfflineManifest(offlineManifest); } /** * Triggered when manifest is loaded from internet. * @param {Object[]} e */ function onOriginalManifestLoaded(e) { // unregister form event eventBus.off(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance); _xmlManifest = e.originalManifest; if (_manifest.type === dashConstants.DYNAMIC) { _status = OfflineConstants.OFFLINE_STATUS_ERROR; errHandler.error({ code: OfflineErrors.OFFLINE_ERROR, message: 'Cannot handle DYNAMIC manifest', data: { id: manifestId, status: _status } }); logger.error('Cannot handle DYNAMIC manifest'); return; } if (_manifest.Period_asArray.length &gt; 1) { _status = OfflineConstants.OFFLINE_STATUS_ERROR; errHandler.error({ code: OfflineErrors.OFFLINE_ERROR, message: 'MultiPeriod manifest are not yet supported', data: { id: manifestId, status: _status } }); logger.error('MultiPeriod manifest are not yet supported'); return; } // save original manifest (for resume) // initialise offline streams composeStreams(_manifest); // get MediaInfos getMediaInfos(); eventBus.trigger(events.STREAMS_COMPOSED); } function initializeAllMediasInfoList(selectedRepresentations) { for (let i = 0; i &lt; _streams.length; i++) { _streams[i].initializeAllMediasInfoList(selectedRepresentations); } } function getSelectedRepresentations(mediaInfos) { let rep = {}; rep[constants.VIDEO] = []; rep[constants.AUDIO] = []; rep[constants.TEXT] = []; rep[constants.FRAGMENTED_TEXT] = []; // selectedRepresentations.video.forEach(item =&gt; { // ret[constants.VIDEO].push(item.id); // }); // selectedRepresentations.audio.forEach(item =&gt; { // ret[constants.AUDIO].push(item.id); // }); // selectedRepresentations.text.forEach(item =&gt; { // ret[item.type].push(item.id); // }); mediaInfos.forEach(mediaInfo =&gt; { mediaInfo.bitrateList.forEach(bitrate =&gt; { rep[mediaInfo.type].push(bitrate.id); }); }); return rep; } function startDownload(mediaInfos) { try { let rep = getSelectedRepresentations(mediaInfos); offlineStoreController.saveSelectedRepresentations(manifestId, rep) .then(() =&gt; { return createFragmentStore(manifestId); }) .then(() =&gt; { return generateOfflineManifest(rep); }) .then(function () { initializeAllMediasInfoList(rep); }); } catch (err) { _status = OfflineConstants.OFFLINE_STATUS_ERROR; errHandler.error({ code: OfflineErrors.OFFLINE_ERROR, message: err.message, data: { id: manifestId, status: _status } }); } } /** * Create the parser used to convert original manifest in offline manifest * Creates a JSON object that will be stored in database * @param {Object[]} selectedRepresentations * @instance */ function generateOfflineManifest(selectedRepresentations) { _indexDBManifestParser = OfflineIndexDBManifestParser(context).create({ manifestId: manifestId, allMediaInfos: selectedRepresentations, debug: debug, dashConstants: dashConstants, constants: constants, urlUtils: urlUtils }); return _indexDBManifestParser.parse(_xmlManifest).then(function (parsedManifest) { if (parsedManifest !== null) { return offlineStoreController.getManifestById(manifestId) .then((item) =&gt; { item.originalURL = _manifest.url; item.originalManifest = _xmlManifest; item.manifest = parsedManifest; return updateOfflineManifest(item); }); } else { return Promise.reject('falling parsing offline manifest'); } }).catch(function (err) { return Promise.reject(err); }); } /** * Stops downloading of fragments * @instance */ function stopDownload() { if (manifestId !== null &amp;&amp; isDownloading()) { for (let i = 0, ln = _streams.length; i &lt; ln; i++) { _streams[i].stopOfflineStreamProcessors(); } // remove streams _streams = []; _isComposed = false; _status = OfflineConstants.OFFLINE_STATUS_STOPPED; // update status offlineStoreController.setDownloadingStatus(manifestId, _status).then(function () { eventBus.trigger(events.OFFLINE_RECORD_STOPPED, { sender: this, id: manifestId, status: _status, message: 'Downloading has been stopped for this stream !' }); _isDownloadingStatus = false; }); } } /** * Delete an offline manifest (and all of its data) * @instance */ function deleteDownload() { stopDownload(); } /** * Resume download of a stream * @instance */ function resumeDownload() { if (isDownloading()) { return; } _isDownloadingStatus = true; let selectedRepresentations; offlineStoreController.getManifestById(manifestId) .then((item) =&gt; { let parser = DashParser(context).create({debug: debug}); _manifest = parser.parse(item.originalManifest); composeStreams(_manifest); selectedRepresentations = item.selected; eventBus.trigger(events.STREAMS_COMPOSED); return createFragmentStore(manifestId); }). then(() =&gt; { initializeAllMediasInfoList(selectedRepresentations); }); } /** * Compute the progression of download * @instance */ function getDownloadProgression() { return Math.round(_progression * 100); } /** * Reset events listeners * @instance */ function resetDownload() { for (let i = 0, ln = _streams.length; i &lt; ln; i++) { _streams[i].reset(); } _indexDBManifestParser = null; _isDownloadingStatus = false; _streams = []; eventBus.off(events.MANIFEST_UPDATED, onManifestUpdated, instance); eventBus.off(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance); resetIndexedDBEvents(); } function onError(e) { if ( e.error.code === OfflineErrors.INDEXEDDB_QUOTA_EXCEED_ERROR || e.error.code === OfflineErrors.INDEXEDDB_INVALID_STATE_ERROR ) { stopDownload(); } } function resetIndexedDBEvents() { eventBus.on(events.ERROR, onError, instance); } /** * Reset * @instance */ function reset() { if (isDownloading()) { resetDownload(); } baseURLController.reset(); manifestUpdater.reset(); } instance = { reset: reset, getId: getId, getOfflineUrl: getOfflineUrl, getManifestUrl: getManifestUrl, getStatus: getStatus, setInitialState: setInitialState, initDownload: initDownload, downloadFromUrl: downloadFromUrl, startDownload: startDownload, stopDownload: stopDownload, resumeDownload: resumeDownload, deleteDownload: deleteDownload, getDownloadProgression: getDownloadProgression, isDownloading: isDownloading, resetDownload: resetDownload }; setup(); return instance; } OfflineDownload.__dashjs_factory_name = 'OfflineDownload'; export default dashjs.FactoryMaker.getClassFactory(OfflineDownload); /* jshint ignore:line */ × Search results Close "},"offline_errors_OfflineErrors.js.html":{"id":"offline_errors_OfflineErrors.js.html","title":"Source: offline/errors/OfflineErrors.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/errors/OfflineErrors.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import ErrorsBase from '../../core/errors/ErrorsBase'; /** * Offline Errors declaration * @class */ class OfflineErrors extends ErrorsBase { constructor () { super(); /** * Error code returned when an error occurs in offline module */ this.OFFLINE_ERROR = 11000; // Based upon https://developer.mozilla.org/fr/docs/Web/API/DOMException this.INDEXEDDB_QUOTA_EXCEED_ERROR = 11001; this.INDEXEDDB_INVALID_STATE_ERROR = 11002; this.INDEXEDDB_NOT_READABLE_ERROR = 11003; this.INDEXEDDB_NOT_FOUND_ERROR = 11004; this.INDEXEDDB_NETWORK_ERROR = 11005; this.INDEXEDDB_DATA_ERROR = 11006; this.INDEXEDDB_TRANSACTION_INACTIVE_ERROR = 11007; this.INDEXEDDB_NOT_ALLOWED_ERROR = 11008; this.INDEXEDDB_NOT_SUPPORTED_ERROR = 11009; this.INDEXEDDB_VERSION_ERROR = 11010; this.INDEXEDDB_TIMEOUT_ERROR = 11011; this.INDEXEDDB_ABORT_ERROR = 11012; this.INDEXEDDB_UNKNOWN_ERROR = 11013; } } let offlineErrors = new OfflineErrors(); export default offlineErrors; × Search results Close "},"offline_events_OfflineEvents.js.html":{"id":"offline_events_OfflineEvents.js.html","title":"Source: offline/events/OfflineEvents.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/events/OfflineEvents.js import EventsBase from './../../core/events/EventsBase'; /** * These are offline events that should be sent to the player level. * @class */ class OfflineEvents extends EventsBase { constructor () { super(); /** * Triggered when all mediaInfo has been loaded * @event OfflineEvents#OFFLINE_RECORD_LOADEDMETADATA */ this.OFFLINE_RECORD_LOADEDMETADATA = 'public_offlineRecordLoadedmetadata'; /** * Triggered when a record is initialized and download is started * @event OfflineEvents#OFFLINE_RECORD_STARTED */ this.OFFLINE_RECORD_STARTED = 'public_offlineRecordStarted'; /** * Triggered when the user stop downloading a record * @event OfflineEvents#OFFLINE_RECORD_STOPPED */ this.OFFLINE_RECORD_STOPPED = 'public_offlineRecordStopped'; /** * Triggered when all record has been downloaded * @event OfflineEvents#OFFLINE_RECORD_FINISHED */ this.OFFLINE_RECORD_FINISHED = 'public_offlineRecordFinished'; } } let offlineEvents = new OfflineEvents(); export default offlineEvents; × Search results Close "},"offline_OfflineStreamProcessor.js.html":{"id":"offline_OfflineStreamProcessor.js.html","title":"Source: offline/OfflineStreamProcessor.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/OfflineStreamProcessor.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import DashHandler from '../dash/DashHandler'; import RepresentationController from '../dash/controllers/RepresentationController'; import FragmentModel from '../streaming/models/FragmentModel'; import FragmentLoader from '../streaming/FragmentLoader'; import URLUtils from '../streaming/utils/URLUtils'; import RequestModifier from '../streaming/utils/RequestModifier'; function OfflineStreamProcessor(config) { config = config || {}; const context = this.context; const eventBus = config.eventBus; const events = config.events; const errors = config.errors; const debug = config.debug; const constants = config.constants; const settings = config.settings; const dashConstants = config.dashConstants; const manifestId = config.id; const type = config.type; const streamInfo = config.streamInfo; const errHandler = config.errHandler; const mediaPlayerModel = config.mediaPlayerModel; const abrController = config.abrController; const playbackController = config.playbackController; const adapter = config.adapter; const dashMetrics = config.dashMetrics; const baseURLController = config.baseURLController; const timelineConverter = config.timelineConverter; const bitrate = config.bitrate; const offlineStoreController = config.offlineStoreController; const completedCb = config.callbacks &amp;&amp; config.callbacks.completed; const progressCb = config.callbacks &amp;&amp; config.callbacks.progression; let instance, logger, mediaInfo, indexHandler, representationController, fragmentModel, updating, downloadedSegments, isInitialized, isStopped; function setup() { resetInitialSettings(); logger = debug.getLogger(instance); indexHandler = DashHandler(context).create({ streamInfo: streamInfo, type: type, timelineConverter: timelineConverter, dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, baseURLController: baseURLController, errHandler: errHandler, settings: settings, // boxParser: boxParser, eventBus: eventBus, events: events, debug: debug, requestModifier: RequestModifier(context).getInstance(), dashConstants: dashConstants, constants: constants, urlUtils: URLUtils(context).getInstance() }); representationController = RepresentationController(context).create({ streamId: streamInfo.id, type: type, abrController: abrController, dashMetrics: dashMetrics, playbackController: playbackController, timelineConverter: timelineConverter, dashConstants: dashConstants, events: events, eventBus: eventBus, errors: errors }); fragmentModel = FragmentModel(context).create({ streamId: streamInfo.id, dashMetrics: dashMetrics, fragmentLoader: FragmentLoader(context).create({ dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, errHandler: errHandler, requestModifier: RequestModifier(context).getInstance(), settings: settings, eventBus: eventBus, events: events, errors: errors, constants: constants, dashConstants: dashConstants, urlUtils: URLUtils(context).getInstance() }), debug: debug, eventBus: eventBus, events: events }); eventBus.on(events.STREAM_COMPLETED, onStreamCompleted, instance); eventBus.on(events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, instance); } function initialize(_mediaInfo) { mediaInfo = _mediaInfo; indexHandler.initialize(false); updateRepresentation(mediaInfo); } function isInitRequest(request) { return request.type === 'InitializationSegment'; } function onFragmentLoadingCompleted(e) { if (e.sender !== fragmentModel) { return; } if (e.request !== null) { let isInit = isInitRequest(e.request); let suffix = isInit ? 'init' : e.request.index; let fragmentName = e.request.representationId + '_' + suffix; offlineStoreController.storeFragment(manifestId, fragmentName, e.response) .then(() =&gt; { if (!isInit) { // store current index and downloadedSegments number offlineStoreController.setRepresentationCurrentState(manifestId, e.request.representationId, { index: e.request.index, downloaded: downloadedSegments } ); } }); } if (e.error &amp;&amp; e.request.serviceLocation &amp;&amp; !isStopped) { fragmentModel.executeRequest(e.request); } else { downloadedSegments++; download(); } } function onStreamCompleted(e) { if (e.fragmentModel !== fragmentModel) { return; } logger.info(`[${manifestId}] Stream is complete`); stop(); completedCb(); } function getRepresentationController () { return representationController; } function getRepresentationId() { return representationController.getCurrentRepresentation().id; } /** * Stops download of fragments * @memberof OfflineStreamProcessor# */ function stop() { if (isStopped) { return; } isStopped = true; } function removeExecutedRequestsBeforeTime(time) { if (fragmentModel) { fragmentModel.removeExecutedRequestsBeforeTime(time); } } /** * Execute init request for the represenation * @memberof OfflineStreamProcessor# */ function getInitRequest() { if (!representationController.getCurrentRepresentation()) { return null; } return indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation()); } /** * Get next request * @memberof OfflineStreamProcessor# */ function getNextRequest() { return indexHandler.getNextSegmentRequest(getMediaInfo(), representationController.getCurrentRepresentation()); } /** * Start download * @memberof OfflineStreamProcessor# */ function start() { if (representationController) { if (!representationController.getCurrentRepresentation()) { throw new Error('Start denied to OfflineStreamProcessor'); } isStopped = false; offlineStoreController.getRepresentationCurrentState(manifestId, representationController.getCurrentRepresentation().id) .then((state) =&gt; { if (state) { indexHandler.setCurrentIndex(state.index); downloadedSegments = state.downloaded; } download(); }).catch(() =&gt; { // start from beginining download(); }); } } /** * Performs download of fragment according to type * @memberof OfflineStreamProcessor# */ function download() { if (isStopped) { return; } if (isNaN(representationController.getCurrentRepresentation())) { let request = null; if (!isInitialized) { request = getInitRequest(); isInitialized = true; } else { request = getNextRequest(); // update progression : done here because availableSegmentsNumber is done in getNextRequest from dash handler updateProgression(); } if (request) { logger.info(`[${manifestId}] download request : ${request.url}`); fragmentModel.executeRequest(request); } else { logger.info(`[${manifestId}] no request to be downloaded`); } } } /** * Update representation * @param {Object} mediaInfo - mediaInfo * @memberof OfflineStreamProcessor# */ function updateRepresentation(mediaInfo) { updating = true; let voRepresentations = adapter.getVoRepresentations(mediaInfo); // get representation VO according to id. let quality = voRepresentations.findIndex((representation) =&gt; { return representation.id === bitrate.id; }); if (type !== constants.VIDEO &amp;&amp; type !== constants.AUDIO &amp;&amp; type !== constants.TEXT &amp;&amp; type !== constants.FRAGMENTED_TEXT) { updating = false; return; } representationController.updateData(null, voRepresentations, type, quality); } function isUpdating() { return updating; } function getType() { return type; } function getMediaInfo() { return mediaInfo; } function getAvailableSegmentsNumber() { return representationController.getCurrentRepresentation().availableSegmentsNumber + 1; // do not forget init segment } function updateProgression () { if (progressCb) { progressCb(instance, downloadedSegments, getAvailableSegmentsNumber()); } } function resetInitialSettings() { isInitialized = false; downloadedSegments = 0; updating = false; } /** * Reset * @memberof OfflineStreamProcessor# */ function reset() { resetInitialSettings(); indexHandler.reset(); eventBus.off(events.STREAM_COMPLETED, onStreamCompleted, instance); eventBus.off(events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, instance); } instance = { initialize: initialize, getMediaInfo: getMediaInfo, getRepresentationController: getRepresentationController, removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime, getType: getType, getRepresentationId: getRepresentationId, isUpdating: isUpdating, start: start, stop: stop, getAvailableSegmentsNumber: getAvailableSegmentsNumber, reset: reset }; setup(); return instance; } OfflineStreamProcessor.__dashjs_factory_name = 'OfflineStreamProcessor'; const factory = dashjs.FactoryMaker.getClassFactory(OfflineStreamProcessor); /* jshint ignore:line */ export default factory; × Search results Close "},"offline_OfflineStream.js.html":{"id":"offline_OfflineStream.js.html","title":"Source: offline/OfflineStream.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: offline/OfflineStream.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import OfflineStreamProcessor from './OfflineStreamProcessor'; /** * Initialize and Manage Offline Stream for each type */ /** * @class OfflineStream * @description Initialize and Manage Offline Stream for each type * @param {Object} config - dependences * @ignore */ function OfflineStream(config) { config = config || {}; const context = this.context; const eventBus = config.eventBus; const events = config.events; const errors = config.errors; const constants = config.constants; const dashConstants = config.dashConstants; const settings = config.settings; const debug = config.debug; const errHandler = config.errHandler; const mediaPlayerModel = config.mediaPlayerModel; const abrController = config.abrController; const playbackController = config.playbackController; const adapter = config.adapter; const dashMetrics = config.dashMetrics; const baseURLController = config.baseURLController; const timelineConverter = config.timelineConverter; const offlineStoreController = config.offlineStoreController; const manifestId = config.id; const startedCb = config.callbacks &amp;&amp; config.callbacks.started; const progressionCb = config.callbacks &amp;&amp; config.callbacks.progression; const finishedCb = config.callbacks &amp;&amp; config.callbacks.finished; const updateManifest = config.callbacks &amp;&amp; config.callbacks.updateManifestNeeded; let instance, offlineStreamProcessors, startedOfflineStreamProcessors, finishedOfflineStreamProcessors, streamInfo, representationsToUpdate, allMediasInfosList, progressionById; function setup() { resetInitialSettings(); } /** * Reset */ function resetInitialSettings() { streamInfo = null; offlineStreamProcessors = []; startedOfflineStreamProcessors = 0; finishedOfflineStreamProcessors = 0; allMediasInfosList = []; representationsToUpdate = []; progressionById = {}; } /** * Initialize offlinestream * @param {Object} initStreamInfo */ function initialize(initStreamInfo) { streamInfo = initStreamInfo; eventBus.on(events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this); } /** * Creates media infos list, so that user will be able to choose the representation he wants to download */ function getMediaInfos() { let mediaInfos = adapter.getAllMediaInfoForType(streamInfo, constants.VIDEO); mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.AUDIO)); mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.FRAGMENTED_TEXT)); mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.TEXT)); // mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.MUXED)); // mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.IMAGE)); eventBus.trigger(events.OFFLINE_RECORD_LOADEDMETADATA, { id: manifestId, mediaInfos: mediaInfos }); } /** * Initialize with choosen representations by user * @param {Object} mediasInfoList */ function initializeAllMediasInfoList(mediasInfoList) { allMediasInfosList = mediasInfoList; initializeMedia(streamInfo); } /** * Initialize media for each type * @param {Object} streamInfo */ function initializeMedia(streamInfo) { createOfflineStreamProcessorFor(constants.VIDEO,streamInfo); createOfflineStreamProcessorFor(constants.AUDIO,streamInfo); createOfflineStreamProcessorFor(constants.FRAGMENTED_TEXT,streamInfo); createOfflineStreamProcessorFor(constants.TEXT,streamInfo); createOfflineStreamProcessorFor(constants.MUXED,streamInfo); createOfflineStreamProcessorFor(constants.IMAGE,streamInfo); } function createOfflineStreamProcessorFor(type, streamInfo) { // filter mediaInfo according to choosen representation id let allMediaInfoForType = adapter.getAllMediaInfoForType(streamInfo, type); allMediaInfoForType.forEach((media) =&gt; { media.bitrateList = media.bitrateList.filter((bitrate) =&gt; { if (allMediasInfosList[type] &amp;&amp; allMediasInfosList[type].indexOf(bitrate.id) !== -1) { return true; } return false; }); }); allMediaInfoForType = allMediaInfoForType.filter((media) =&gt; { return (media.bitrateList &amp;&amp; media.bitrateList.length &gt; 0); }); // cration of an offline stream processor for each choosen representation allMediaInfoForType.forEach((mediaInfo) =&gt; { if (mediaInfo.bitrateList) { mediaInfo.bitrateList.forEach((bitrate) =&gt; { createStreamProcessor(mediaInfo, bitrate); }); } }); return allMediaInfoForType; } function createStreamProcessor (mediaInfo, bitrate) { let streamProcessor = OfflineStreamProcessor(context).create({ id: manifestId, streamInfo: streamInfo, debug: debug, events: events, errors: errors, eventBus: eventBus, constants: constants, dashConstants: dashConstants, settings: settings, type: mediaInfo.type, mimeType: mediaInfo.mimeType, bitrate: bitrate, errHandler: errHandler, mediaPlayerModel: mediaPlayerModel, abrController: abrController, playbackController: playbackController, adapter: adapter, dashMetrics: dashMetrics, baseURLController: baseURLController, timelineConverter: timelineConverter, offlineStoreController: offlineStoreController, callbacks: { completed: onStreamCompleted, progression: onStreamProgression } }); offlineStreamProcessors.push(streamProcessor); streamProcessor.initialize(mediaInfo); progressionById[bitrate.id] = null; } function onStreamCompleted() { finishedOfflineStreamProcessors++; if (finishedOfflineStreamProcessors === offlineStreamProcessors.length) { finishedCb({sender: this, id: manifestId, message: 'Downloading has been successfully completed for this stream !'}); } } function onStreamProgression(streamProcessor, downloadedSegments, availableSegments ) { progressionById[streamProcessor.getRepresentationId()] = { downloadedSegments, availableSegments }; let segments = 0; let allSegments = 0; let waitForAllProgress; for (var property in progressionById) { if (progressionById.hasOwnProperty(property)) { if (progressionById[property] === null) { waitForAllProgress = true; } else { segments += progressionById[property].downloadedSegments; allSegments += progressionById[property].availableSegments; } } } if (!waitForAllProgress &amp;&amp; progressionCb) { // all progression have been started, we can compute global progression if (allSegments &gt; 0) { progressionCb(instance, segments, allSegments); } } } function onDataUpdateCompleted(e) { let repCtrl = e.sender; if (!streamInfo || repCtrl.getStreamId() !== streamInfo.id) return; if (e.currentRepresentation.segments &amp;&amp; e.currentRepresentation.segments.length &gt; 0) { representationsToUpdate.push(e.currentRepresentation); } let sp; // data are ready fr stream processor, let's start download for (let i = 0; i &lt; offlineStreamProcessors.length; i++ ) { if (offlineStreamProcessors[i].getRepresentationController().getType() === repCtrl.getType()) { sp = offlineStreamProcessors[i]; break; } } if (sp) { checkIfAllOfflineStreamProcessorsStarted(); } } function checkIfAllOfflineStreamProcessorsStarted() { startedOfflineStreamProcessors++; if (startedOfflineStreamProcessors === offlineStreamProcessors.length) { startedCb({sender: this, id: manifestId, message: 'Downloading started for this stream !'}); if (representationsToUpdate.length &gt; 0) { updateManifest({sender: this, id: manifestId, representations: representationsToUpdate }); } else { startOfflineStreamProcessors(); } } } function getStreamInfo() { return streamInfo; } function getStartTime() { return streamInfo ? streamInfo.start : NaN; } function getDuration() { return streamInfo ? streamInfo.duration : NaN; } /** * Stop offline stream processors */ function stopOfflineStreamProcessors() { for (let i = 0; i &lt; offlineStreamProcessors.length; i++) { offlineStreamProcessors[i].stop(); } } /** * Start offline stream processors */ function startOfflineStreamProcessors() { for (let i = 0; i &lt; offlineStreamProcessors.length; i++) { offlineStreamProcessors[i].start(); } } function deactivate() { let ln = offlineStreamProcessors ? offlineStreamProcessors.length : 0; for (let i = 0; i &lt; ln; i++) { offlineStreamProcessors[i].removeExecutedRequestsBeforeTime(getStartTime() + getDuration()); offlineStreamProcessors[i].reset(); } } /** * Reset */ function reset() { stopOfflineStreamProcessors(); deactivate(); resetInitialSettings(); eventBus.off(events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this); } instance = { initialize: initialize, getMediaInfos: getMediaInfos, initializeAllMediasInfoList: initializeAllMediasInfoList, getStreamInfo: getStreamInfo, stopOfflineStreamProcessors: stopOfflineStreamProcessors, startOfflineStreamProcessors: startOfflineStreamProcessors, reset: reset }; setup(); return instance; } OfflineStream.__dashjs_factory_name = 'OfflineStream'; export default dashjs.FactoryMaker.getClassFactory(OfflineStream); /* jshint ignore:line */ × Search results Close "},"streaming_controllers_PlaybackController.js.html":{"id":"streaming_controllers_PlaybackController.js.html","title":"Source: streaming/controllers/PlaybackController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/controllers/PlaybackController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import MetricsConstants from '../constants/MetricsConstants'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; const LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500; function PlaybackController() { const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, streamController, dashMetrics, adapter, videoModel, timelineConverter, streamSwitch, streamSeekTime, wallclockTimeIntervalId, liveDelay, streamInfo, isDynamic, mediaPlayerModel, playOnceInitialized, lastLivePlaybackTime, availabilityStartTime, seekTarget, isLowLatencySeekingInProgress, playbackStalled, minPlaybackRateChange, uriFragmentModel, settings; function setup() { logger = Debug(context).getInstance().getLogger(instance); reset(); } function initialize(sInfo, periodSwitch, seekTime) { streamInfo = sInfo; addAllListeners(); isDynamic = streamInfo.manifestInfo.isDynamic; isLowLatencySeekingInProgress = false; playbackStalled = false; streamSwitch = periodSwitch === true; streamSeekTime = seekTime; const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : ''; // Detect safari browser (special behavior for low latency streams) const isSafari = /safari/.test(ua) &amp;&amp; !/chrome/.test(ua); minPlaybackRateChange = isSafari ? 0.25 : 0.02; eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this); eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this); eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this); eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this); eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this); eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this); eventBus.on(Events.PLAYBACK_ENDED, onPlaybackEnded, this); eventBus.on(Events.STREAM_INITIALIZING, onStreamInitializing, this); if (playOnceInitialized) { playOnceInitialized = false; play(); } } function onStreamInitialized(e) { // Seamless period switch if (streamSwitch &amp;&amp; isNaN(streamSeekTime)) return; // Seek new stream in priority order: // - at seek time (streamSeekTime) when switching period // - at start time provided in URI parameters // - at stream/period start time (for static streams) or live start time (for dynamic streams) let startTime = streamSeekTime; if (isNaN(startTime)) { if (isDynamic) { // For dynamic stream, start by default at (live edge - live delay) startTime = e.liveStartTime; // If start time in URI, take min value between live edge time and time from URI (capped by DVR window range) const dvrInfo = dashMetrics.getCurrentDVRInfo(); const dvrWindow = dvrInfo ? dvrInfo.range : null; if (dvrWindow) { // #t shall be relative to period start const startTimeFromUri = getStartTimeFromUriParameters(streamInfo.start, true); if (!isNaN(startTimeFromUri)) { logger.info('Start time from URI parameters: ' + startTimeFromUri); startTime = Math.max(Math.min(startTime, startTimeFromUri), dvrWindow.start); } } } else { // For static stream, start by default at period start startTime = streamInfo.start; // If start time in URI, take max value between period start and time from URI (if in period range) const startTimeFromUri = getStartTimeFromUriParameters(streamInfo.start, false); if (!isNaN(startTimeFromUri) &amp;&amp; startTimeFromUri &lt; (startTime + streamInfo.duration)) { logger.info('Start time from URI parameters: ' + startTimeFromUri); startTime = Math.max(startTime, startTimeFromUri); } } } if (!isNaN(startTime) &amp;&amp; startTime !== videoModel.getTime()) { // Trigger PLAYBACK_SEEKING event for controllers eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: startTime }); // Seek video model seek(startTime, false, true); } } function getTimeToStreamEnd() { return parseFloat((getStreamEndTime() - getTime()).toFixed(5)); } function getStreamEndTime() { return streamInfo.start + streamInfo.duration; } function play() { if (streamInfo &amp;&amp; videoModel &amp;&amp; videoModel.getElement()) { videoModel.play(); } else { playOnceInitialized = true; } } function isPaused() { return streamInfo &amp;&amp; videoModel ? videoModel.isPaused() : null; } function pause() { if (streamInfo &amp;&amp; videoModel) { videoModel.pause(); } } function isSeeking() { return streamInfo &amp;&amp; videoModel ? videoModel.isSeeking() : null; } function seek(time, stickToBuffered, internalSeek) { if (!streamInfo || !videoModel) return; let currentTime = !isNaN(seekTarget) ? seekTarget : videoModel.getTime(); if (time === currentTime) return; if (internalSeek === true) { // Internal seek = seek video model only (disable 'seeking' listener) // buffer(s) are already appended at requested time videoModel.removeEventListener('seeking', onPlaybackSeeking); logger.info('Requesting internal seek to time: ' + time); videoModel.setCurrentTime(time, stickToBuffered); } else { seekTarget = time; eventBus.trigger(Events.PLAYBACK_SEEK_ASKED); logger.info('Requesting seek to time: ' + time); videoModel.setCurrentTime(time, stickToBuffered); } } function seekToLive() { const DVRMetrics = dashMetrics.getCurrentDVRInfo(); const DVRWindow = DVRMetrics ? DVRMetrics.range : null; seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false); } function getTime() { return streamInfo &amp;&amp; videoModel ? videoModel.getTime() : null; } function getNormalizedTime() { let t = getTime(); if (isDynamic &amp;&amp; !isNaN(availabilityStartTime)) { const timeOffset = availabilityStartTime / 1000; // Fix current time for firefox and safari (returned as an absolute time) if (t &gt; timeOffset) { t -= timeOffset; } } return t; } function getPlaybackRate() { return streamInfo &amp;&amp; videoModel ? videoModel.getPlaybackRate() : null; } function getPlayedRanges() { return streamInfo &amp;&amp; videoModel ? videoModel.getPlayedRanges() : null; } function getEnded() { return streamInfo &amp;&amp; videoModel ? videoModel.getEnded() : null; } function getIsDynamic() { return isDynamic; } function getStreamController() { return streamController; } /** * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge * @param {number} fragmentDuration - seconds? * @param {number} dvrWindowSize - seconds? * @param {number} minBufferTime - seconds? * @returns {number} object * @memberof PlaybackController# */ function computeAndSetLiveDelay(fragmentDuration, dvrWindowSize, minBufferTime) { let delay, ret, startTime; const END_OF_PLAYLIST_PADDING = 10; const MIN_BUFFER_TIME_FACTOR = 4; const FRAGMENT_DURATION_FACTOR = 4; const adjustedFragmentDuration = !isNaN(fragmentDuration) &amp;&amp; isFinite(fragmentDuration) ? fragmentDuration : NaN; let suggestedPresentationDelay = adapter.getSuggestedPresentationDelay(); if (settings.get().streaming.lowLatencyEnabled) { delay = 0; } else if (mediaPlayerModel.getLiveDelay()) { delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence } else if (settings.get().streaming.liveDelayFragmentCount !== null &amp;&amp; !isNaN(settings.get().streaming.liveDelayFragmentCount) &amp;&amp; !isNaN(adjustedFragmentDuration)) { delay = adjustedFragmentDuration * settings.get().streaming.liveDelayFragmentCount; } else if (settings.get().streaming.useSuggestedPresentationDelay === true &amp;&amp; suggestedPresentationDelay !== null &amp;&amp; !isNaN(suggestedPresentationDelay) &amp;&amp; suggestedPresentationDelay &gt; 0) { delay = suggestedPresentationDelay; } else if (!isNaN(adjustedFragmentDuration)) { delay = adjustedFragmentDuration * FRAGMENT_DURATION_FACTOR; } else { delay = !isNaN(minBufferTime) ? minBufferTime * MIN_BUFFER_TIME_FACTOR : streamInfo.manifestInfo.minBufferTime * MIN_BUFFER_TIME_FACTOR; } startTime = adapter.getAvailabilityStartTime(); if (startTime !== null) { availabilityStartTime = startTime; } if (dvrWindowSize &gt; 0) { // cap target latency to: // - dvrWindowSize / 2 for short playlists // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2); ret = Math.min(delay, targetDelayCapping); } else { ret = delay; } liveDelay = ret; return ret; } function getLiveDelay() { return liveDelay; } function setLiveDelay(value, useMaxValue = false) { if (useMaxValue &amp;&amp; value &lt; liveDelay) { return; } liveDelay = value; } function getCurrentLiveLatency() { if (!isDynamic || isNaN(availabilityStartTime)) { return NaN; } let currentTime = getNormalizedTime(); if (isNaN(currentTime) || currentTime === 0) { return 0; } const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000; return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0); } function reset() { playOnceInitialized = false; streamSwitch = false; streamSeekTime = NaN; liveDelay = 0; availabilityStartTime = 0; seekTarget = NaN; if (videoModel) { eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this); eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this); eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this); eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this); eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this); eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this); eventBus.off(Events.PLAYBACK_ENDED, onPlaybackEnded, this); eventBus.off(Events.STREAM_INITIALIZING, onStreamInitializing, this); stopUpdatingWallclockTime(); removeAllListeners(); } wallclockTimeIntervalId = null; videoModel = null; streamInfo = null; isDynamic = null; } function setConfig(config) { if (!config) return; if (config.streamController) { console.log('enter streaming controller'); streamController = config.streamController; } if (config.dashMetrics) { dashMetrics = config.dashMetrics; } if (config.mediaPlayerModel) { mediaPlayerModel = config.mediaPlayerModel; } if (config.adapter) { adapter = config.adapter; } if (config.videoModel) { videoModel = config.videoModel; } if (config.timelineConverter) { timelineConverter = config.timelineConverter; } if (config.uriFragmentModel) { uriFragmentModel = config.uriFragmentModel; } if (config.settings) { settings = config.settings; } } function getStartTimeFromUriParameters(rangeStart, isDynamic) { const fragData = uriFragmentModel.getURIFragmentData(); if (!fragData || !fragData.t) { return NaN; } let startTime = NaN; // Consider only start time of MediaRange // TODO: consider end time of MediaRange to stop playback at provided end time fragData.t = fragData.t.split(',')[0]; // \"t=&lt;time&gt;\" : time is relative to period start (for static streams) or DVR window range start (for dynamic streams) // \"t=posix:&lt;time&gt;\" : time is absolute start time as number of seconds since 01-01-1970 startTime = (isDynamic &amp;&amp; fragData.t.indexOf('posix:') !== -1) ? parseInt(fragData.t.substring(6)) : (rangeStart + parseInt(fragData.t)); return startTime; } function getActualPresentationTime(currentTime) { const DVRMetrics = dashMetrics.getCurrentDVRInfo(); const DVRWindow = DVRMetrics ? DVRMetrics.range : null; let actualTime; if (!DVRWindow) { return NaN; } logger.debug(`Checking DVR window for at ${currentTime} with DVR window range ${DVRWindow.start} - ${DVRWindow.end}`); if (currentTime &gt; DVRWindow.end) { actualTime = Math.max(DVRWindow.end - liveDelay, DVRWindow.start); } else if (currentTime &gt; 0 &amp;&amp; currentTime + 0.250 &lt; DVRWindow.start &amp;&amp; Math.abs(currentTime - DVRWindow.start) &lt; 315360000) { // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource // Checking also duration of the DVR makes sense. We detected temporary situations in which currentTime // is bad reported by the browser which causes playback to jump to start (315360000 = 1 year) //actualTime = DVRWindow.start; actualTime = DVRWindow.start; } else { actualTime = currentTime; } return actualTime; } function startUpdatingWallclockTime() { if (wallclockTimeIntervalId !== null) return; const tick = function () { onWallclockTime(); }; wallclockTimeIntervalId = setInterval(tick, settings.get().streaming.wallclockTimeUpdateInterval); } function stopUpdatingWallclockTime() { clearInterval(wallclockTimeIntervalId); wallclockTimeIntervalId = null; } function updateCurrentTime() { if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return; const currentTime = getNormalizedTime(); const actualTime = getActualPresentationTime(currentTime); const timeChanged = (!isNaN(actualTime) &amp;&amp; actualTime !== currentTime); if (timeChanged) { logger.debug(`UpdateCurrentTime: Seek to actual time: ${actualTime} from currentTime: ${currentTime}`); seek(actualTime); } } function onDataUpdateCompleted(e) { if (e.error) return; const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation); const info = representationInfo ? representationInfo.mediaInfo.streamInfo : null; if (info === null || streamInfo.id !== info.id) return; streamInfo = info; updateCurrentTime(); } function onCanPlay() { eventBus.trigger(Events.CAN_PLAY); } function onPlaybackStart() { logger.info('Native video element event: play'); updateCurrentTime(); startUpdatingWallclockTime(); eventBus.trigger(Events.PLAYBACK_STARTED, { startTime: getTime() }); } function onPlaybackWaiting() { logger.info('Native video element event: waiting'); eventBus.trigger(Events.PLAYBACK_WAITING, { playingTime: getTime() }); } function onPlaybackPlaying() { logger.info('Native video element event: playing'); eventBus.trigger(Events.PLAYBACK_PLAYING, { playingTime: getTime() }); } function onPlaybackPaused() { logger.info('Native video element event: pause'); eventBus.trigger(Events.PLAYBACK_PAUSED, { ended: getEnded() }); } function onPlaybackSeeking() { let seekTime = getTime(); // On some browsers/devices, in case of live streams, setting current time on video element fails when there is no buffered data at requested time // Then re-set seek target time and video element will be seeked afterwhile once data is buffered (see BufferContoller) if (!isNaN(seekTarget) &amp;&amp; seekTarget !== seekTime) { seekTime = seekTarget; } seekTarget = NaN; logger.info('Seeking to: ' + seekTime); startUpdatingWallclockTime(); eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: seekTime }); } function onPlaybackSeeked() { logger.info('Native video element event: seeked'); eventBus.trigger(Events.PLAYBACK_SEEKED); // Reactivate 'seeking' event listener (see seek()) videoModel.addEventListener('seeking', onPlaybackSeeking); } function onPlaybackTimeUpdated() { if (streamInfo) { eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, { timeToEnd: getTimeToStreamEnd(), time: getTime() }); } } function updateLivePlaybackTime() { const now = Date.now(); if (!lastLivePlaybackTime || now &gt; lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) { lastLivePlaybackTime = now; onPlaybackTimeUpdated(); } } function onPlaybackProgress() { eventBus.trigger(Events.PLAYBACK_PROGRESS); } function onPlaybackRateChanged() { const rate = getPlaybackRate(); logger.info('Native video element event: ratechange: ', rate); eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, { playbackRate: rate }); } function onPlaybackMetaDataLoaded() { logger.info('Native video element event: loadedmetadata'); eventBus.trigger(Events.PLAYBACK_METADATA_LOADED); startUpdatingWallclockTime(); } // Event to handle the native video element ended event function onNativePlaybackEnded() { logger.info('Native video element event: ended'); pause(); stopUpdatingWallclockTime(); eventBus.trigger(Events.PLAYBACK_ENDED, {'isLast': streamController.getActiveStreamInfo().isLast}); } // Handle DASH PLAYBACK_ENDED event function onPlaybackEnded(e) { if (wallclockTimeIntervalId &amp;&amp; e.isLast) { // PLAYBACK_ENDED was triggered elsewhere, react. logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended'); const seekTime = e.seekTime ? e.seekTime : getStreamEndTime(); videoModel.setCurrentTime(seekTime); pause(); stopUpdatingWallclockTime(); } } function onPlaybackError(event) { const target = event.target || event.srcElement; eventBus.trigger(Events.PLAYBACK_ERROR, { error: target.error }); } function onWallclockTime() { eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, { isDynamic: isDynamic, time: new Date() }); // Updates playback time for paused dynamic streams // (video element doesn't call timeupdate when the playback is paused) if (getIsDynamic() &amp;&amp; isPaused()) { updateLivePlaybackTime(); } } function onPlaybackProgression() { if ( isDynamic &amp;&amp; settings.get().streaming.lowLatencyEnabled &amp;&amp; settings.get().streaming.liveCatchUpPlaybackRate &gt; 0 &amp;&amp; !isPaused() &amp;&amp; !isSeeking() ) { if (needToCatchUp()) { startPlaybackCatchUp(); } else { stopPlaybackCatchUp(); } } } function getBufferLevel() { let bufferLevel = null; streamController.getActiveStreamProcessors().forEach(p =&gt; { const bl = p.getBufferLevel(); if (bufferLevel === null) { bufferLevel = bl; } else { bufferLevel = Math.min(bufferLevel, bl); } }); return bufferLevel; } function needToCatchUp() { const currentLiveLatency = getCurrentLiveLatency(); const latencyDrift = Math.abs(currentLiveLatency - mediaPlayerModel.getLiveDelay()); const liveCatchupLatencyThreshold = mediaPlayerModel.getLiveCatchupLatencyThreshold(); return settings.get().streaming.lowLatencyEnabled &amp;&amp; settings.get().streaming.liveCatchUpPlaybackRate &gt; 0 &amp;&amp; getTime() &gt; 0 &amp;&amp; latencyDrift &gt; settings.get().streaming.liveCatchUpMinDrift &amp;&amp; (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency &lt;= liveCatchupLatencyThreshold); } function startPlaybackCatchUp() { if (videoModel) { const cpr = settings.get().streaming.liveCatchUpPlaybackRate; const liveDelay = mediaPlayerModel.getLiveDelay(); const deltaLatency = getCurrentLiveLatency() - liveDelay; const d = deltaLatency * 5; // Playback rate must be between (1 - cpr) - (1 + cpr) // ex: if cpr is 0.5, it can have values between 0.5 - 1.5 const s = (cpr * 2) / (1 + Math.pow(Math.E, -d)); let newRate = (1 - cpr) + s; // take into account situations in which there are buffer stalls, // in which increasing playbackRate to reach target latency will // just cause more and more stall situations if (playbackStalled) { const bufferLevel = getBufferLevel(); if (bufferLevel &gt; liveDelay / 2) { playbackStalled = false; } else if (deltaLatency &gt; 0) { newRate = 1.0; } } // don't change playbackrate for small variations (don't overload element with playbackrate changes) if (Math.abs(videoModel.getPlaybackRate() - newRate) &gt; minPlaybackRateChange) { videoModel.setPlaybackRate(newRate); } if (settings.get().streaming.liveCatchUpMaxDrift &gt; 0 &amp;&amp; !isLowLatencySeekingInProgress &amp;&amp; deltaLatency &gt; settings.get().streaming.liveCatchUpMaxDrift) { logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point'); isLowLatencySeekingInProgress = true; seekToLive(); } else { isLowLatencySeekingInProgress = false; } } } function stopPlaybackCatchUp() { if (videoModel) { videoModel.setPlaybackRate(1.0); } } function onFragmentLoadProgress(e) { // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration if (e.stream === false &amp;&amp; settings.get().streaming.lowLatencyEnabled &amp;&amp; !isNaN(e.request.duration)) { const minDelay = 1.2 * e.request.duration; if (minDelay &gt; mediaPlayerModel.getLiveDelay()) { logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2)); const s = {streaming: {liveDelay: minDelay}}; settings.update(s); } } } function onBufferLevelStateChanged(e) { // do not stall playback when get an event from Stream that is not active if (e.streamId !== streamInfo.id) return; if (settings.get().streaming.lowLatencyEnabled) { if (e.state === MetricsConstants.BUFFER_EMPTY &amp;&amp; !isSeeking()) { if (!playbackStalled) { playbackStalled = true; stopPlaybackCatchUp(); } } } else { videoModel.setStallState(e.mediaType, e.state === MetricsConstants.BUFFER_EMPTY); } } function onPlaybackStalled(e) { eventBus.trigger(Events.PLAYBACK_STALLED, { e: e }); } function onStreamInitializing(e) { applyServiceDescription(e.streamInfo, e.mediaInfo); } function applyServiceDescription(streamInfo, mediaInfo) { if (streamInfo &amp;&amp; streamInfo.manifestInfo &amp;&amp; streamInfo.manifestInfo.serviceDescriptions) { // is there a service description for low latency defined? let llsd; for (let i = 0; i &lt; streamInfo.manifestInfo.serviceDescriptions.length; i++) { const sd = streamInfo.manifestInfo.serviceDescriptions[i]; if (sd.schemeIdUri === Constants.SERVICE_DESCRIPTION_LL_SCHEME) { llsd = sd; break; } } if (llsd) { if (mediaInfo &amp;&amp; mediaInfo.supplementalProperties &amp;&amp; mediaInfo.supplementalProperties[Constants.SUPPLEMENTAL_PROPERTY_LL_SCHEME] === 'true') { if (llsd.latency &amp;&amp; llsd.latency.target &gt; 0) { logger.debug('Apply LL properties coming from service description. Target Latency (ms):', llsd.latency.target); settings.update({ streaming: { lowLatencyEnabled: true, liveDelay: llsd.latency.target / 1000, liveCatchUpMinDrift: llsd.latency.max &gt; llsd.latency.target ? (llsd.latency.max - llsd.latency.target) / 1000 : undefined } }); } if (llsd.playbackRate &amp;&amp; llsd.playbackRate.max &gt; 1.0) { logger.debug('Apply LL properties coming from service description. Max PlaybackRate:', llsd.playbackRate.max); settings.update({ streaming: { lowLatencyEnabled: true, liveCatchUpPlaybackRate: llsd.playbackRate.max - 1.0 } }); } } } } } function addAllListeners() { videoModel.addEventListener('canplay', onCanPlay); videoModel.addEventListener('play', onPlaybackStart); videoModel.addEventListener('waiting', onPlaybackWaiting); videoModel.addEventListener('playing', onPlaybackPlaying); videoModel.addEventListener('pause', onPlaybackPaused); videoModel.addEventListener('error', onPlaybackError); videoModel.addEventListener('seeking', onPlaybackSeeking); videoModel.addEventListener('seeked', onPlaybackSeeked); videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated); videoModel.addEventListener('progress', onPlaybackProgress); videoModel.addEventListener('ratechange', onPlaybackRateChanged); videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded); videoModel.addEventListener('stalled', onPlaybackStalled); videoModel.addEventListener('ended', onNativePlaybackEnded); } function removeAllListeners() { videoModel.removeEventListener('canplay', onCanPlay); videoModel.removeEventListener('play', onPlaybackStart); videoModel.removeEventListener('waiting', onPlaybackWaiting); videoModel.removeEventListener('playing', onPlaybackPlaying); videoModel.removeEventListener('pause', onPlaybackPaused); videoModel.removeEventListener('error', onPlaybackError); videoModel.removeEventListener('seeking', onPlaybackSeeking); videoModel.removeEventListener('seeked', onPlaybackSeeked); videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated); videoModel.removeEventListener('progress', onPlaybackProgress); videoModel.removeEventListener('ratechange', onPlaybackRateChanged); videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded); videoModel.removeEventListener('stalled', onPlaybackStalled); videoModel.removeEventListener('ended', onNativePlaybackEnded); } instance = { initialize: initialize, setConfig: setConfig, getStartTimeFromUriParameters: getStartTimeFromUriParameters, getTimeToStreamEnd: getTimeToStreamEnd, getTime: getTime, getNormalizedTime: getNormalizedTime, getPlaybackRate: getPlaybackRate, getPlayedRanges: getPlayedRanges, getEnded: getEnded, getIsDynamic: getIsDynamic, getStreamController: getStreamController, computeAndSetLiveDelay: computeAndSetLiveDelay, getLiveDelay: getLiveDelay, setLiveDelay: setLiveDelay, getCurrentLiveLatency: getCurrentLiveLatency, play: play, isPaused: isPaused, pause: pause, isSeeking: isSeeking, getStreamEndTime, seek: seek, reset: reset }; setup(); return instance; } PlaybackController.__dashjs_factory_name = 'PlaybackController'; export default FactoryMaker.getSingletonFactory(PlaybackController); × Search results Close "},"streaming_vo_metrics_PlayList.js.html":{"id":"streaming_vo_metrics_PlayList.js.html","title":"Source: streaming/vo/metrics/PlayList.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/PlayList.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc a PlayList from ISO23009-1 Annex D, this Object holds reference to the playback session information * @ignore */ class PlayList { /** * @class */ constructor() { /** * Timestamp of the user action that starts the playback stream... * @public */ this.start = null; /** * Presentation time at which playout was requested by the user... * @public */ this.mstart = null; /** * Type of user action which triggered playout * - New playout request (e.g. initial playout or seeking) * - Resume from pause * - Other user request (e.g. user-requested quality change) * - Start of a metrics collection stream (hence earlier entries in the play list not collected) * @public */ this.starttype = null; /** * List of streams of continuous rendering of decoded samples. * @public */ this.trace = []; } } /* Public Static Constants */ PlayList.INITIAL_PLAYOUT_START_REASON = 'initial_playout'; PlayList.SEEK_START_REASON = 'seek'; PlayList.RESUME_FROM_PAUSE_START_REASON = 'resume'; PlayList.METRICS_COLLECTION_START_REASON = 'metrics_collection_start'; /** * @classdesc a PlayList.Trace from ISO23009-1 Annex D * @ignore */ class PlayListTrace { /** * @class */ constructor() { /** * The value of the Representation@id of the Representation from which the samples were taken. * @type {string} * @public */ this.representationid = null; /** * If not present, this metrics concerns the Representation as a whole. * If present, subreplevel indicates the greatest value of any * Subrepresentation@level being rendered. * @type {number} * @public */ this.subreplevel = null; /** * The time at which the first sample was rendered * @type {number} * @public */ this.start = null; /** * The presentation time of the first sample rendered. * @type {number} * @public */ this.mstart = null; /** * The duration of the continuously presented samples (which is the same in real time and media time). \"Continuously presented\" means that the media clock continued to advance at the playout speed throughout the interval. NOTE: the spec does not call out the units, but all other durations etc are in ms, and we use ms too. * @type {number} * @public */ this.duration = null; /** * The playback speed relative to normal playback speed (i.e.normal forward playback speed is 1.0). * @type {number} * @public */ this.playbackspeed = null; /** * The reason why continuous presentation of this Representation was stopped. * representation switch * rebuffering * user request * end of Period * end of Stream * end of content * end of a metrics collection period * * @type {string} * @public */ this.stopreason = null; } } PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON = 'representation_switch'; PlayListTrace.REBUFFERING_REASON = 'rebuffering'; PlayListTrace.USER_REQUEST_STOP_REASON = 'user_request'; PlayListTrace.END_OF_PERIOD_STOP_REASON = 'end_of_period'; PlayListTrace.END_OF_CONTENT_STOP_REASON = 'end_of_content'; PlayListTrace.METRICS_COLLECTION_STOP_REASON = 'metrics_collection_end'; PlayListTrace.FAILURE_STOP_REASON = 'failure'; export { PlayList, PlayListTrace }; × Search results Close "},"streaming_PreBufferSink.js.html":{"id":"streaming_PreBufferSink.js.html","title":"Source: streaming/PreBufferSink.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/PreBufferSink.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Debug from '../core/Debug'; import FactoryMaker from '../core/FactoryMaker'; /** * This is a sink that is used to temporarily hold onto media chunks before a video element is added. * The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer. * * @class PreBufferSink * @ignore * @implements FragmentSink */ function PreBufferSink(onAppendedCallback) { const context = this.context; let instance, logger, outstandingInit; let chunks = []; let onAppended = onAppendedCallback; function setup() { logger = Debug(context).getInstance().getLogger(instance); } function reset() { chunks = []; outstandingInit = null; onAppended = null; } function append(chunk) { if (chunk.segmentType !== 'InitializationSegment') { //Init segments are stored in the initCache. chunks.push(chunk); chunks.sort(function (a, b) { return a.start - b.start; }); outstandingInit = null; } else {//We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens. outstandingInit = chunk; } logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end); if (onAppended) { onAppended({ chunk: chunk }); } } function remove(start, end) { chunks = chunks.filter( a =&gt; !((isNaN(end) || a.start &lt; end) &amp;&amp; (isNaN(start) || a.end &gt; start))); //The opposite of the getChunks predicate. } //Nothing async, nothing to abort. function abort() { } function getAllBufferRanges() { let ranges = []; for (let i = 0; i &lt; chunks.length; i++) { let chunk = chunks[i]; if (ranges.length === 0 || chunk.start &gt; ranges[ranges.length - 1].end) { ranges.push({ start: chunk.start, end: chunk.end }); } else { ranges[ranges.length - 1].end = chunk.end; } } //Implements TimeRanges interface. So acts just like sourceBuffer.buffered. const timeranges = { start: function (n) { return ranges[n].start; }, end: function (n) { return ranges[n].end; } }; Object.defineProperty(timeranges, 'length', { get: function () { return ranges.length; } }); return timeranges; } function hasDiscontinuitiesAfter() { return false; } function updateTimestampOffset() { // Nothing to do } function getBuffer() { return this; } /** * Return the all chunks in the buffer the lie between times start and end. * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range. * Chunks are removed from the buffer when they are discharged. * @function PreBufferSink#discharge * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded. * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded. * @returns {Array} The set of chunks from the buffer within the time ranges. */ function discharge(start, end) { const result = getChunksAt(start, end); if (outstandingInit) { result.push(outstandingInit); outstandingInit = null; } remove(start, end); return result; } function getChunksAt(start, end) { return chunks.filter( a =&gt; ((isNaN(end) || a.start &lt; end) &amp;&amp; (isNaN(start) || a.end &gt; start)) ); } function waitForUpdateEnd(callback) { callback(); } instance = { getAllBufferRanges: getAllBufferRanges, append: append, remove: remove, abort: abort, discharge: discharge, reset: reset, updateTimestampOffset: updateTimestampOffset, hasDiscontinuitiesAfter: hasDiscontinuitiesAfter, waitForUpdateEnd: waitForUpdateEnd, getBuffer: getBuffer }; setup(); return instance; } PreBufferSink.__dashjs_factory_name = 'PreBufferSink'; const factory = FactoryMaker.getClassFactory(PreBufferSink); export default factory; × Search results Close "},"streaming_protection_vo_ProtectionData.js.html":{"id":"streaming_protection_vo_ProtectionData.js.html","title":"Source: streaming/protection/vo/ProtectionData.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/vo/ProtectionData.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc Data provided for a particular piece of content to customize license server URLs, * license server HTTP request headers, clearkeys, or other content-specific data * @ignore */ class ProtectionData { /** * @param {string|Object} serverURL a license server URL to use with this key system. * When specified as a string, a single URL will be used regardless of message type. * When specified as an object, the object will have property names for each message * type ({@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|message * types defined here)} with the corresponding property value being the URL to use for * messages of that type * @param {Object} httpRequestHeaders headers to add to the http request * @param {Object} clearkeys defines a set of clear keys that are available to * the key system. Object properties are base64-encoded keyIDs (with no padding). * Corresponding property values are keys, base64-encoded (no padding). * @param {number|undefined} priority priority order of the current ProtectionData * @class */ constructor(serverURL, httpRequestHeaders, clearkeys, priority) { this.serverURL = serverURL; this.httpRequestHeaders = httpRequestHeaders; this.clearkeys = clearkeys; this.priority = priority === undefined ? -1 : priority; } } /** * License server URL * * @instance * @type string|Object * @name ProtectionData.serverURL * @readonly * @memberof ProtectionData */ /** * HTTP Request Headers for use in license requests. Each property name * in the object is a header name with its corresponding header value being * the property value * * @instance * @type Object * @name ProtectionData.httpRequestsHeaders * @readonly * @memberof ProtectionData */ /** * ClearKey key-pairs that can be used to decrypt the content * * @instance * @type Object * @name ProtectionData.clearkeys * @readonly * @memberof ProtectionData */ /** * priority * * @instance * @type Object * @name ProtectionData.priority * @readonly * @memberof ProtectionData */ export default ProtectionData; × Search results Close "},"streaming_protection_errors_ProtectionErrors.js.html":{"id":"streaming_protection_errors_ProtectionErrors.js.html","title":"Source: streaming/protection/errors/ProtectionErrors.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/errors/ProtectionErrors.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import ErrorsBase from '../../../core/errors/ErrorsBase'; /** * @class */ class ProtectionErrors extends ErrorsBase { constructor () { super(); /** * Generid key Error code */ this.MEDIA_KEYERR_CODE = 100; /** * Error code returned by keyerror api for ProtectionModel_01b */ this.MEDIA_KEYERR_UNKNOWN_CODE = 101; /** * Error code returned by keyerror api for ProtectionModel_01b */ this.MEDIA_KEYERR_CLIENT_CODE = 102; /** * Error code returned by keyerror api for ProtectionModel_01b */ this.MEDIA_KEYERR_SERVICE_CODE = 103; /** * Error code returned by keyerror api for ProtectionModel_01b */ this.MEDIA_KEYERR_OUTPUT_CODE = 104; /** * Error code returned by keyerror api for ProtectionModel_01b */ this.MEDIA_KEYERR_HARDWARECHANGE_CODE = 105; /** * Error code returned by keyerror api for ProtectionModel_01b */ this.MEDIA_KEYERR_DOMAIN_CODE = 106; /** * Error code returned when an error occured in keymessage event for ProtectionModel_01b */ this.MEDIA_KEY_MESSAGE_ERROR_CODE = 107; /** * Error code returned when challenge is invalid in keymessage event (event triggered by CDM) */ this.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE = 108; /** * Error code returned when License server certificate has not been successfully updated */ this.SERVER_CERTIFICATE_UPDATED_ERROR_CODE = 109; /** * Error code returned when license validity has expired */ this.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE = 110; /** * Error code returned when no licenser url is defined */ this.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE = 111; /** * Error code returned when key system access is denied */ this.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE = 112; /** * Error code returned when key session has not been successfully created */ this.KEY_SESSION_CREATED_ERROR_CODE = 113; /** * Error code returned when license request failed after a keymessage event has been triggered */ this.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE = 114; this.MEDIA_KEYERR_UNKNOWN_MESSAGE = 'An unspecified error occurred. This value is used for errors that don\\'t match any of the other codes.'; this.MEDIA_KEYERR_CLIENT_MESSAGE = 'The Key System could not be installed or updated.'; this.MEDIA_KEYERR_SERVICE_MESSAGE = 'The message passed into update indicated an error from the license service.'; this.MEDIA_KEYERR_OUTPUT_MESSAGE = 'There is no available output device with the required characteristics for the content protection system.'; this.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE = 'A hardware configuration change caused a content protection error.'; this.MEDIA_KEYERR_DOMAIN_MESSAGE = 'An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.'; this.MEDIA_KEY_MESSAGE_ERROR_MESSAGE = 'Multiple key sessions were creates with a user-agent that does not support sessionIDs!! Unpredictable behavior ahead!'; this.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE = 'DRM: Empty key message from CDM'; this.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE = 'Error updating server certificate -- '; this.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE = 'DRM: KeyStatusChange error! -- License has expired'; this.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE = 'DRM: No license server URL specified!'; this.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE = 'DRM: KeySystem Access Denied! -- '; this.KEY_SESSION_CREATED_ERROR_MESSAGE = 'DRM: unable to create session! --'; this.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE = 'DRM: licenser error! --'; } } let protectionErrors = new ProtectionErrors(); export default protectionErrors; × Search results Close "},"streaming_protection_ProtectionEvents.js.html":{"id":"streaming_protection_ProtectionEvents.js.html","title":"Source: streaming/protection/ProtectionEvents.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/ProtectionEvents.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import EventsBase from '../../core/events/EventsBase'; /** * @class */ class ProtectionEvents extends EventsBase { /** * @description Public facing external events to be used when including protection package. * All public events will be aggregated into the MediaPlayerEvents Class and can be accessed * via MediaPlayer.events. public_ is the prefix that we use to move event names to MediaPlayerEvents. */ constructor () { super(); /** * Event ID for events delivered when the protection set receives * a key message from the CDM * * @ignore */ this.INTERNAL_KEY_MESSAGE = 'internalKeyMessage'; /** * Event ID for events delivered when a key system selection procedure * completes * @ignore */ this.INTERNAL_KEY_SYSTEM_SELECTED = 'internalKeySystemSelected'; /** * Event ID for events delivered when the status of one decryption keys has changed * @ignore */ this.INTERNAL_KEY_STATUS_CHANGED = 'internalkeyStatusChanged'; /** * Event ID for events delivered when a new key has been added * * @constant * @deprecated The latest versions of the EME specification no longer * use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} * is preferred. * @event ProtectionEvents#KEY_ADDED */ this.KEY_ADDED = 'public_keyAdded'; /** * Event ID for events delivered when an error is encountered by the CDM * while processing a license server response message * @event ProtectionEvents#KEY_ERROR */ this.KEY_ERROR = 'public_keyError'; /** * Event ID for events delivered when the protection set receives * a key message from the CDM * @event ProtectionEvents#KEY_MESSAGE */ this.KEY_MESSAGE = 'public_keyMessage'; /** * Event ID for events delivered when a key session close * process has completed * @event ProtectionEvents#KEY_SESSION_CLOSED */ this.KEY_SESSION_CLOSED = 'public_keySessionClosed'; /** * Event ID for events delivered when a new key sessions creation * process has completed * @event ProtectionEvents#KEY_SESSION_CREATED */ this.KEY_SESSION_CREATED = 'public_keySessionCreated'; /** * Event ID for events delivered when a key session removal * process has completed * @event ProtectionEvents#KEY_SESSION_REMOVED */ this.KEY_SESSION_REMOVED = 'public_keySessionRemoved'; /** * Event ID for events delivered when the status of one or more * decryption keys has changed * @event ProtectionEvents#KEY_STATUSES_CHANGED */ this.KEY_STATUSES_CHANGED = 'public_keyStatusesChanged'; /** * Event ID for events delivered when a key system access procedure * has completed * @ignore */ this.KEY_SYSTEM_ACCESS_COMPLETE = 'public_keySystemAccessComplete'; /** * Event ID for events delivered when a key system selection procedure * completes * @event ProtectionEvents#KEY_SYSTEM_SELECTED */ this.KEY_SYSTEM_SELECTED = 'public_keySystemSelected'; /** * Event ID for events delivered when a license request procedure * has completed * @event ProtectionEvents#LICENSE_REQUEST_COMPLETE */ this.LICENSE_REQUEST_COMPLETE = 'public_licenseRequestComplete'; /** * Event ID for needkey/encrypted events * @ignore */ this.NEED_KEY = 'needkey'; /** * Event ID for events delivered when the Protection system is detected and created. * @event ProtectionEvents#PROTECTION_CREATED */ this.PROTECTION_CREATED = 'public_protectioncreated'; /** * Event ID for events delivered when the Protection system is destroyed. * @event ProtectionEvents#PROTECTION_DESTROYED */ this.PROTECTION_DESTROYED = 'public_protectiondestroyed'; /** * Event ID for events delivered when a new server certificate has * been delivered to the CDM * @ignore */ this.SERVER_CERTIFICATE_UPDATED = 'serverCertificateUpdated'; /** * Event ID for events delivered when the process of shutting down * a protection set has completed * @ignore */ this.TEARDOWN_COMPLETE = 'protectionTeardownComplete'; /** * Event ID for events delivered when a HTMLMediaElement has been * associated with the protection set * @ignore */ this.VIDEO_ELEMENT_SELECTED = 'videoElementSelected'; } } let protectionEvents = new ProtectionEvents(); export default protectionEvents; × Search results Close "},"streaming_protection_models_ProtectionModel.js.html":{"id":"streaming_protection_models_ProtectionModel.js.html","title":"Source: streaming/protection/models/ProtectionModel.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/models/ProtectionModel.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Defines the public interface for all ProtectionModel implementations. * * ProtectionModel implementations provide access to particular versions * of the Encrypted Media Extensions (EME) APIs that have been implemented * in a user agent. Developers wishing to add support for a new EME version * found in a target user-agent should add a new instance of this interface * to the * * Applications should not need direct access to this object. All interactions with * the protection system should be performed with * {@link module:ProtectionController} * * @interface ProtectionModel * @ignore */ const ProtectionModel = function () { }; /** * Returns an array of all initialization data currently used by * active sessions. * @function * @instance * @name getAllInitData * @memberof ProtectionModel * @returns {Array.&lt;ArrayBuffer&gt;} an array of initialization data buffers */ /** * Determine if the user-agent supports one of the given key systems and * content type configurations. Sends ENAME_KEY_SYSTEM_ACCESS_COMPLETE event * with a KeySystemAccess object as event data * * @function * @instance * @name requestKeySystemAccess * @memberof ProtectionModel * * @param {Array.&lt;Object&gt;} ksConfigurations array of desired key system * configurations in priority order (highest priority first) * @param {MediaPlayer.dependencies.protection.KeySystem} ksConfigurations.ks * the key system * @param {MediaPlayer.vo.protection.KeySystemConfiguration[]} ksConfigurations.configs * array of acceptable key system configurations * for this key system in priority order (highest priority first) */ /** * Selects the key system to use for all future operations on this * ProtectionModel. Sends ENAME_KEY_SYSTEM_SELECTED with no data * * @function * @instance * @name selectKeySystem * @memberof ProtectionModel * @param keySystemAccess {MediaPlayer.vo.protection.KeySystemAccess} the key * system access token representing a supported key system */ /** * Associate this protection model with a HTMLMediaElement * * @function * @instance * @name setMediaElement * @memberof ProtectionModel * @param mediaElement {HTMLMediaElement} the media element to * which we should associate this protection model and all current * key sessions */ /** * Creates a new key session using the given initData and type. Sends * KEY_SESSION_CREATED event with MediaPlayer.vo.protection.SessionToken * as data. * * @function * @instance * @name createKeySession * @memberof ProtectionModel * @param {ArrayBuffer} initData PSSH box for the currently selected * key system. * @param {ProtectionData} protData Protection data for the currently selected * key system. * @param {string} sessionType the desired session type. One of \"temporary\", * \"persistent-license\", \"persistent-release-message\". CDM implementations * are not required to support anything except \"temporary\" */ /** * Update the given key session with a key (or any other message * intended for the CDM) * * @function * @instance * @name updateKeySession * @memberof ProtectionModel * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session * token * @param {ArrayBuffer} message the message that should be delivered to the CDM * for this session */ /** * Loads the persisted key session data associated with the given sessionID * into a new session. Sends KEY_SESSION_CREATED event with * {@MediaPlayer.vo.protection.SessionToken} as data. * * @function * @instance * @name loadKeySession * @memberof ProtectionModel * @param {string} sessionID the session ID corresponding to the persisted * session data to be loaded * @param {ArrayBuffer} the corresponding initData PSSH box for the currently * selected key system. */ /** * Removes any persisted key session data associated with the given session. * Also closes the session. Sends KEY_SESSION_REMOVED and * ENAME_KEY_SESSION_CLOSED with sessionID as data * * @function * @instance * @name removeKeySession * @memberof ProtectionModel * @param {SessionToken} sessionToken the session * token */ /** * Close the given session and release all associated keys. Following * this call, the sessionToken becomes invalid. Sends KEY_SESSION_CLOSED * with sessionID as data * * @function * @instance * @name closeKeySession * @memberof ProtectionModel * @param sessionToken the session token */ /** * Sets the certificate to be used by the CDM for encrypting messages * * @function * @instance * @name setServerCertificate * @memberof ProtectionModel * @param {ArrayBuffer} serverCertificate */ /** * Currently selected key system. Will be null or undefined if no key * system has yet been selected * * @instance * @name keySystem * @memberof ProtectionModel * @readonly * @type MediaPlayer.dependencies.protection.KeySystem */ export default ProtectionModel; × Search results Close "},"streaming_protection_models_ProtectionModel_01b.js.html":{"id":"streaming_protection_models_ProtectionModel_01b.js.html","title":"Source: streaming/protection/models/ProtectionModel_01b.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/models/ProtectionModel_01b.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Initial implementation of EME * * Implemented by Google Chrome prior to v36 * * @implements ProtectionModel * @class */ import ProtectionKeyController from '../controllers/ProtectionKeyController'; import NeedKey from '../vo/NeedKey'; import DashJSError from '../../vo/DashJSError'; import KeyMessage from '../vo/KeyMessage'; import KeySystemConfiguration from '../vo/KeySystemConfiguration'; import KeySystemAccess from '../vo/KeySystemAccess'; import ProtectionErrors from '../errors/ProtectionErrors'; function ProtectionModel_01b(config) { config = config || {}; const context = this.context; const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module const events = config.events; const debug = config.debug; const api = config.api; const errHandler = config.errHandler; let instance, logger, videoElement, keySystem, protectionKeyController, // With this version of the EME APIs, sessionIDs are not assigned to // sessions until the first key message is received. We are assuming // that in the case of multiple sessions, key messages will be received // in the order that generateKeyRequest() is called. // Holding spot for newly-created sessions until we determine whether or // not the CDM supports sessionIDs pendingSessions, // List of sessions that have been initialized. Only the first position will // be used in the case that the CDM does not support sessionIDs sessions, // Not all CDMs support the notion of sessionIDs. Without sessionIDs // there is no way for us to differentiate between sessions, therefore // we must only allow a single session. Once we receive the first key // message we can set this flag to determine if more sessions are allowed moreSessionsAllowed, // This is our main event handler for all desired HTMLMediaElement events // related to EME. These events are translated into our API-independent // versions of the same events eventHandler; function setup() { logger = debug.getLogger(instance); videoElement = null; keySystem = null; pendingSessions = []; sessions = []; protectionKeyController = ProtectionKeyController(context).getInstance(); eventHandler = createEventHandler(); } function reset() { if (videoElement) { removeEventListeners(); } for (let i = 0; i &lt; sessions.length; i++) { closeKeySession(sessions[i]); } eventBus.trigger(events.TEARDOWN_COMPLETE); } function getKeySystem() { return keySystem; } function getAllInitData() { const retVal = []; for (let i = 0; i &lt; pendingSessions.length; i++) { retVal.push(pendingSessions[i].initData); } for (let i = 0; i &lt; sessions.length; i++) { retVal.push(sessions[i].initData); } return retVal; } function requestKeySystemAccess(ksConfigurations) { let ve = videoElement; if (!ve) { // Must have a video element to do this capability tests ve = document.createElement('video'); } // Try key systems in order, first one with supported key system configuration // is used let found = false; for (let ksIdx = 0; ksIdx &lt; ksConfigurations.length; ksIdx++) { const systemString = ksConfigurations[ksIdx].ks.systemString; const configs = ksConfigurations[ksIdx].configs; let supportedAudio = null; let supportedVideo = null; // Try key system configs in order, first one with supported audio/video // is used for (let configIdx = 0; configIdx &lt; configs.length; configIdx++) { //let audios = configs[configIdx].audioCapabilities; const videos = configs[configIdx].videoCapabilities; // Look for supported video container/codecs if (videos &amp;&amp; videos.length !== 0) { supportedVideo = []; // Indicates that we have a requested video config for (let videoIdx = 0; videoIdx &lt; videos.length; videoIdx++) { if (ve.canPlayType(videos[videoIdx].contentType, systemString) !== '') { supportedVideo.push(videos[videoIdx]); } } } // No supported audio or video in this configuration OR we have // requested audio or video configuration that is not supported if ((!supportedAudio &amp;&amp; !supportedVideo) || (supportedAudio &amp;&amp; supportedAudio.length === 0) || (supportedVideo &amp;&amp; supportedVideo.length === 0)) { continue; } // This configuration is supported found = true; const ksConfig = new KeySystemConfiguration(supportedAudio, supportedVideo); const ks = protectionKeyController.getKeySystemBySystemString(systemString); eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: new KeySystemAccess(ks, ksConfig) }); break; } } if (!found) { eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {error: 'Key system access denied! -- No valid audio/video content configurations detected!'}); } } function selectKeySystem(keySystemAccess) { keySystem = keySystemAccess.keySystem; eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED); } function setMediaElement(mediaElement) { if (videoElement === mediaElement) { return; } // Replacing the previous element if (videoElement) { removeEventListeners(); // Close any open sessions - avoids memory leak on LG webOS 2016/2017 TVs for (var i = 0; i &lt; sessions.length; i++) { closeKeySession(sessions[i]); } sessions = []; } videoElement = mediaElement; // Only if we are not detaching from the existing element if (videoElement) { videoElement.addEventListener(api.keyerror, eventHandler); videoElement.addEventListener(api.needkey, eventHandler); videoElement.addEventListener(api.keymessage, eventHandler); videoElement.addEventListener(api.keyadded, eventHandler); eventBus.trigger(events.VIDEO_ELEMENT_SELECTED); } } function createKeySession(initData /*, protData, keySystemType */) { if (!keySystem) { throw new Error('Can not create sessions until you have selected a key system'); } // Determine if creating a new session is allowed if (moreSessionsAllowed || sessions.length === 0) { const newSession = { // Implements SessionToken sessionID: null, initData: initData, getSessionID: function () { return this.sessionID; }, getExpirationTime: function () { return NaN; }, getSessionType: function () { return 'temporary'; } }; pendingSessions.push(newSession); // Send our request to the CDM videoElement[api.generateKeyRequest](keySystem.systemString, new Uint8Array(initData)); return newSession; } else { throw new Error('Multiple sessions not allowed!'); } } function updateKeySession(sessionToken, message) { const sessionID = sessionToken.sessionID; if (!protectionKeyController.isClearKey(keySystem)) { // Send our request to the CDM videoElement[api.addKey](keySystem.systemString, new Uint8Array(message), new Uint8Array(sessionToken.initData), sessionID); } else { // For clearkey, message is a ClearKeyKeySet for (let i = 0; i &lt; message.keyPairs.length; i++) { videoElement[api.addKey](keySystem.systemString, message.keyPairs[i].key, message.keyPairs[i].keyID, sessionID); } } } function closeKeySession(sessionToken) { // Send our request to the CDM try { videoElement[api.cancelKeyRequest](keySystem.systemString, sessionToken.sessionID); } catch (error) { eventBus.trigger(events.KEY_SESSION_CLOSED, {data: null, error: 'Error closing session (' + sessionToken.sessionID + ') ' + error.message}); } } function setServerCertificate(/*serverCertificate*/) { /* Not supported */ } function loadKeySession(/*sessionID*/) { /* Not supported */ } function removeKeySession(/*sessionToken*/) { /* Not supported */ } function createEventHandler() { return { handleEvent: function (event) { let sessionToken = null; switch (event.type) { case api.needkey: let initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData; eventBus.trigger(events.NEED_KEY, {key: new NeedKey(initData, 'cenc')}); break; case api.keyerror: sessionToken = findSessionByID(sessions, event.sessionId); if (!sessionToken) { sessionToken = findSessionByID(pendingSessions, event.sessionId); } if (sessionToken) { let code = ProtectionErrors.MEDIA_KEYERR_CODE; let msg = ''; switch (event.errorCode.code) { case 1: code = ProtectionErrors.MEDIA_KEYERR_UNKNOWN_CODE; msg += 'MEDIA_KEYERR_UNKNOWN - ' + ProtectionErrors.MEDIA_KEYERR_UNKNOWN_MESSAGE; break; case 2: code = ProtectionErrors.MEDIA_KEYERR_CLIENT_CODE; msg += 'MEDIA_KEYERR_CLIENT - ' + ProtectionErrors.MEDIA_KEYERR_CLIENT_MESSAGE; break; case 3: code = ProtectionErrors.MEDIA_KEYERR_SERVICE_CODE; msg += 'MEDIA_KEYERR_SERVICE - ' + ProtectionErrors.MEDIA_KEYERR_SERVICE_MESSAGE; break; case 4: code = ProtectionErrors.MEDIA_KEYERR_OUTPUT_CODE; msg += 'MEDIA_KEYERR_OUTPUT - ' + ProtectionErrors.MEDIA_KEYERR_OUTPUT_MESSAGE; break; case 5: code = ProtectionErrors.MEDIA_KEYERR_HARDWARECHANGE_CODE; msg += 'MEDIA_KEYERR_HARDWARECHANGE - ' + ProtectionErrors.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE; break; case 6: code = ProtectionErrors.MEDIA_KEYERR_DOMAIN_CODE; msg += 'MEDIA_KEYERR_DOMAIN - ' + ProtectionErrors.MEDIA_KEYERR_DOMAIN_MESSAGE; break; } msg += ' System Code = ' + event.systemCode; // TODO: Build error string based on key error eventBus.trigger(events.KEY_ERROR, {data: new DashJSError(code, msg, sessionToken)}); } else { logger.error('No session token found for key error'); } break; case api.keyadded: sessionToken = findSessionByID(sessions, event.sessionId); if (!sessionToken) { sessionToken = findSessionByID(pendingSessions, event.sessionId); } if (sessionToken) { logger.debug('DRM: Key added.'); eventBus.trigger(events.KEY_ADDED, {data: sessionToken});//TODO not sure anything is using sessionToken? why there? } else { logger.debug('No session token found for key added'); } break; case api.keymessage: // If this CDM does not support session IDs, we will be limited // to a single session moreSessionsAllowed = (event.sessionId !== null) &amp;&amp; (event.sessionId !== undefined); // SessionIDs supported if (moreSessionsAllowed) { // Attempt to find an uninitialized token with this sessionID sessionToken = findSessionByID(sessions, event.sessionId); if (!sessionToken &amp;&amp; pendingSessions.length &gt; 0) { // This is the first message for our latest session, so set the // sessionID and add it to our list sessionToken = pendingSessions.shift(); sessions.push(sessionToken); sessionToken.sessionID = event.sessionId; eventBus.trigger(events.KEY_SESSION_CREATED, {data: sessionToken}); } } else if (pendingSessions.length &gt; 0) { // SessionIDs not supported sessionToken = pendingSessions.shift(); sessions.push(sessionToken); if (pendingSessions.length !== 0) { errHandler.error(new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_MESSAGE)); } } if (sessionToken) { let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message; // For ClearKey, the spec mandates that you pass this message to the // addKey method, so we always save it to the token since there is no // way to tell which key system is in use sessionToken.keyMessage = message; eventBus.trigger(events.INTERNAL_KEY_MESSAGE, {data: new KeyMessage(sessionToken, message, event.defaultURL)}); } else { logger.warn('No session token found for key message'); } break; } } }; } /** * Helper function to retrieve the stored session token based on a given * sessionID value * * @param {Array} sessionArray - the array of sessions to search * @param {*} sessionID - the sessionID to search for * @returns {*} the session token with the given sessionID */ function findSessionByID(sessionArray, sessionID) { if (!sessionID || !sessionArray) { return null; } else { const len = sessionArray.length; for (let i = 0; i &lt; len; i++) { if (sessionArray[i].sessionID == sessionID) { return sessionArray[i]; } } return null; } } function removeEventListeners() { videoElement.removeEventListener(api.keyerror, eventHandler); videoElement.removeEventListener(api.needkey, eventHandler); videoElement.removeEventListener(api.keymessage, eventHandler); videoElement.removeEventListener(api.keyadded, eventHandler); } instance = { getAllInitData: getAllInitData, requestKeySystemAccess: requestKeySystemAccess, getKeySystem: getKeySystem, selectKeySystem: selectKeySystem, setMediaElement: setMediaElement, createKeySession: createKeySession, updateKeySession: updateKeySession, closeKeySession: closeKeySession, setServerCertificate: setServerCertificate, loadKeySession: loadKeySession, removeKeySession: removeKeySession, stop: reset, reset: reset }; setup(); return instance; } ProtectionModel_01b.__dashjs_factory_name = 'ProtectionModel_01b'; export default dashjs.FactoryMaker.getClassFactory(ProtectionModel_01b); /* jshint ignore:line */ × Search results Close "},"streaming_protection_models_ProtectionModel_3Feb2014.js.html":{"id":"streaming_protection_models_ProtectionModel_3Feb2014.js.html","title":"Source: streaming/protection/models/ProtectionModel_3Feb2014.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/models/ProtectionModel_3Feb2014.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Implementation of the EME APIs as of the 3 Feb 2014 state of the specification. * * Implemented by Internet Explorer 11 (Windows 8.1) * * @implements ProtectionModel * @class */ import ProtectionKeyController from '../controllers/ProtectionKeyController'; import NeedKey from '../vo/NeedKey'; import DashJSError from '../../vo/DashJSError'; import ProtectionErrors from '../errors/ProtectionErrors'; import KeyMessage from '../vo/KeyMessage'; import KeySystemConfiguration from '../vo/KeySystemConfiguration'; import KeySystemAccess from '../vo/KeySystemAccess'; function ProtectionModel_3Feb2014(config) { config = config || {}; const context = this.context; const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module const events = config.events; const debug = config.debug; const api = config.api; let instance, logger, videoElement, keySystem, mediaKeys, keySystemAccess, sessions, eventHandler, protectionKeyController; function setup() { logger = debug.getLogger(instance); videoElement = null; keySystem = null; mediaKeys = null; keySystemAccess = null; sessions = []; protectionKeyController = ProtectionKeyController(context).getInstance(); eventHandler = createEventHandler(); } function reset() { try { for (let i = 0; i &lt; sessions.length; i++) { closeKeySession(sessions[i]); } if (videoElement) { videoElement.removeEventListener(api.needkey, eventHandler); } eventBus.trigger(events.TEARDOWN_COMPLETE); } catch (error) { eventBus.trigger(events.TEARDOWN_COMPLETE, { error: 'Error tearing down key sessions and MediaKeys! -- ' + error.message }); } } function getKeySystem() { return keySystem; } function getAllInitData() { const retVal = []; for (let i = 0; i &lt; sessions.length; i++) { retVal.push(sessions[i].initData); } return retVal; } function requestKeySystemAccess(ksConfigurations) { // Try key systems in order, first one with supported key system configuration // is used let found = false; for (let ksIdx = 0; ksIdx &lt; ksConfigurations.length; ksIdx++) { const systemString = ksConfigurations[ksIdx].ks.systemString; const configs = ksConfigurations[ksIdx].configs; let supportedAudio = null; let supportedVideo = null; // Try key system configs in order, first one with supported audio/video // is used for (let configIdx = 0; configIdx &lt; configs.length; configIdx++) { const audios = configs[configIdx].audioCapabilities; const videos = configs[configIdx].videoCapabilities; // Look for supported audio container/codecs if (audios &amp;&amp; audios.length !== 0) { supportedAudio = []; // Indicates that we have a requested audio config for (let audioIdx = 0; audioIdx &lt; audios.length; audioIdx++) { if (window[api.MediaKeys].isTypeSupported(systemString, audios[audioIdx].contentType)) { supportedAudio.push(audios[audioIdx]); } } } // Look for supported video container/codecs if (videos &amp;&amp; videos.length !== 0) { supportedVideo = []; // Indicates that we have a requested video config for (let videoIdx = 0; videoIdx &lt; videos.length; videoIdx++) { if (window[api.MediaKeys].isTypeSupported(systemString, videos[videoIdx].contentType)) { supportedVideo.push(videos[videoIdx]); } } } // No supported audio or video in this configuration OR we have // requested audio or video configuration that is not supported if ((!supportedAudio &amp;&amp; !supportedVideo) || (supportedAudio &amp;&amp; supportedAudio.length === 0) || (supportedVideo &amp;&amp; supportedVideo.length === 0)) { continue; } // This configuration is supported found = true; const ksConfig = new KeySystemConfiguration(supportedAudio, supportedVideo); const ks = protectionKeyController.getKeySystemBySystemString(systemString); eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: new KeySystemAccess(ks, ksConfig) }); break; } } if (!found) { eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { error: 'Key system access denied! -- No valid audio/video content configurations detected!' }); } } function selectKeySystem(ksAccess) { try { mediaKeys = ksAccess.mediaKeys = new window[api.MediaKeys](ksAccess.keySystem.systemString); keySystem = ksAccess.keySystem; keySystemAccess = ksAccess; if (videoElement) { setMediaKeys(); } eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED); } catch (error) { eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED, { error: 'Error selecting keys system (' + keySystem.systemString + ')! Could not create MediaKeys -- TODO' }); } } function setMediaElement(mediaElement) { if (videoElement === mediaElement) return; // Replacing the previous element if (videoElement) { videoElement.removeEventListener(api.needkey, eventHandler); } videoElement = mediaElement; // Only if we are not detaching from the existing element if (videoElement) { videoElement.addEventListener(api.needkey, eventHandler); if (mediaKeys) { setMediaKeys(); } } } function createKeySession(initData, protData, sessionType, cdmData) { if (!keySystem || !mediaKeys || !keySystemAccess) { throw new Error('Can not create sessions until you have selected a key system'); } // Use the first video capability for the contentType. // TODO: Not sure if there is a way to concatenate all capability data into a RFC6386-compatible format // If player is trying to playback Audio only stream - don't error out. let capabilities = null; if (keySystemAccess.ksConfiguration.videoCapabilities &amp;&amp; keySystemAccess.ksConfiguration.videoCapabilities.length &gt; 0) { capabilities = keySystemAccess.ksConfiguration.videoCapabilities[0]; } if (capabilities === null &amp;&amp; keySystemAccess.ksConfiguration.audioCapabilities &amp;&amp; keySystemAccess.ksConfiguration.audioCapabilities.length &gt; 0) { capabilities = keySystemAccess.ksConfiguration.audioCapabilities[0]; } if (capabilities === null) { throw new Error('Can not create sessions for unknown content types.'); } const contentType = capabilities.contentType; const session = mediaKeys.createSession(contentType, new Uint8Array(initData), cdmData ? new Uint8Array(cdmData) : null); const sessionToken = createSessionToken(session, initData); // Add all event listeners session.addEventListener(api.error, sessionToken); session.addEventListener(api.message, sessionToken); session.addEventListener(api.ready, sessionToken); session.addEventListener(api.close, sessionToken); // Add to our session list sessions.push(sessionToken); logger.debug('DRM: Session created. SessionID = ' + sessionToken.getSessionID()); eventBus.trigger(events.KEY_SESSION_CREATED, { data: sessionToken }); } function updateKeySession(sessionToken, message) { const session = sessionToken.session; if (!protectionKeyController.isClearKey(keySystem)) { // Send our request to the key session session.update(new Uint8Array(message)); } else { // For clearkey, message is a ClearKeyKeySet session.update(new Uint8Array(message.toJWK())); } } /** * Close the given session and release all associated keys. Following * this call, the sessionToken becomes invalid * * @param {Object} sessionToken - the session token */ function closeKeySession(sessionToken) { const session = sessionToken.session; // Remove event listeners session.removeEventListener(api.error, sessionToken); session.removeEventListener(api.message, sessionToken); session.removeEventListener(api.ready, sessionToken); session.removeEventListener(api.close, sessionToken); // Remove from our session list for (let i = 0; i &lt; sessions.length; i++) { if (sessions[i] === sessionToken) { sessions.splice(i, 1); break; } } // Send our request to the key session session[api.release](); } function setServerCertificate(/*serverCertificate*/) { /* Not supported */ } function loadKeySession(/*sessionID*/) { /* Not supported */ } function removeKeySession(/*sessionToken*/) { /* Not supported */ } function createEventHandler() { return { handleEvent: function (event) { switch (event.type) { case api.needkey: if (event.initData) { const initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData; eventBus.trigger(events.NEED_KEY, { key: new NeedKey(initData, 'cenc') }); } break; } } }; } // IE11 does not let you set MediaKeys until it has entered a certain // readyState, so we need this logic to ensure we don't set the keys // too early function setMediaKeys() { let boundDoSetKeys = null; const doSetKeys = function () { videoElement.removeEventListener('loadedmetadata', boundDoSetKeys); videoElement[api.setMediaKeys](mediaKeys); eventBus.trigger(events.VIDEO_ELEMENT_SELECTED); }; if (videoElement.readyState &gt;= 1) { doSetKeys(); } else { boundDoSetKeys = doSetKeys.bind(this); videoElement.addEventListener('loadedmetadata', boundDoSetKeys); } } // Function to create our session token objects which manage the EME // MediaKeySession and session-specific event handler function createSessionToken(keySession, initData) { return { // Implements SessionToken session: keySession, initData: initData, getSessionID: function () { return this.session.sessionId; }, getExpirationTime: function () { return NaN; }, getSessionType: function () { return 'temporary'; }, // This is our main event handler for all desired MediaKeySession events // These events are translated into our API-independent versions of the // same events handleEvent: function (event) { switch (event.type) { case api.error: let errorStr = 'KeyError'; // TODO: Make better string from event eventBus.trigger(events.KEY_ERROR, { data: new DashJSError(ProtectionErrors.MEDIA_KEYERR_CODE, errorStr, this) }); break; case api.message: let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message; eventBus.trigger(events.INTERNAL_KEY_MESSAGE, { data: new KeyMessage(this, message, event.destinationURL) }); break; case api.ready: logger.debug('DRM: Key added.'); eventBus.trigger(events.KEY_ADDED); break; case api.close: logger.debug('DRM: Session closed. SessionID = ' + this.getSessionID()); eventBus.trigger(events.KEY_SESSION_CLOSED, { data: this.getSessionID() }); break; } } }; } instance = { getAllInitData: getAllInitData, requestKeySystemAccess: requestKeySystemAccess, getKeySystem: getKeySystem, selectKeySystem: selectKeySystem, setMediaElement: setMediaElement, createKeySession: createKeySession, updateKeySession: updateKeySession, closeKeySession: closeKeySession, setServerCertificate: setServerCertificate, loadKeySession: loadKeySession, removeKeySession: removeKeySession, stop: reset, reset: reset }; setup(); return instance; } ProtectionModel_3Feb2014.__dashjs_factory_name = 'ProtectionModel_3Feb2014'; export default dashjs.FactoryMaker.getClassFactory(ProtectionModel_3Feb2014); /* jshint ignore:line */ × Search results Close "},"streaming_protection_Protection.js.html":{"id":"streaming_protection_Protection.js.html","title":"Source: streaming/protection/Protection.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/Protection.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import ProtectionController from './controllers/ProtectionController'; import ProtectionKeyController from './controllers/ProtectionKeyController'; import ProtectionEvents from './ProtectionEvents'; import ProtectionErrors from './errors/ProtectionErrors'; import ProtectionModel_21Jan2015 from './models/ProtectionModel_21Jan2015'; import ProtectionModel_3Feb2014 from './models/ProtectionModel_3Feb2014'; import ProtectionModel_01b from './models/ProtectionModel_01b'; const APIS_ProtectionModel_01b = [ // Un-prefixed as per spec { // Video Element generateKeyRequest: 'generateKeyRequest', addKey: 'addKey', cancelKeyRequest: 'cancelKeyRequest', // Events needkey: 'needkey', keyerror: 'keyerror', keyadded: 'keyadded', keymessage: 'keymessage' }, // Webkit-prefixed (early Chrome versions and Chrome with EME disabled in chrome://flags) { // Video Element generateKeyRequest: 'webkitGenerateKeyRequest', addKey: 'webkitAddKey', cancelKeyRequest: 'webkitCancelKeyRequest', // Events needkey: 'webkitneedkey', keyerror: 'webkitkeyerror', keyadded: 'webkitkeyadded', keymessage: 'webkitkeymessage' } ]; const APIS_ProtectionModel_3Feb2014 = [ // Un-prefixed as per spec // Chrome 38-39 (and some earlier versions) with chrome://flags -- Enable Encrypted Media Extensions { // Video Element setMediaKeys: 'setMediaKeys', // MediaKeys MediaKeys: 'MediaKeys', // MediaKeySession release: 'close', // Events needkey: 'needkey', error: 'keyerror', message: 'keymessage', ready: 'keyadded', close: 'keyclose' }, // MS-prefixed (IE11, Windows 8.1) { // Video Element setMediaKeys: 'msSetMediaKeys', // MediaKeys MediaKeys: 'MSMediaKeys', // MediaKeySession release: 'close', // Events needkey: 'msneedkey', error: 'mskeyerror', message: 'mskeymessage', ready: 'mskeyadded', close: 'mskeyclose' } ]; function Protection() { let instance; const context = this.context; /** * Create a ProtectionController and associated ProtectionModel for use with * a single piece of content. * * @param {Object} config * @return {ProtectionController} protection controller * */ function createProtectionSystem(config) { let controller = null; const protectionKeyController = ProtectionKeyController(context).getInstance(); protectionKeyController.setConfig({ debug: config.debug, BASE64: config.BASE64 }); protectionKeyController.initialize(); let protectionModel = getProtectionModel(config); if (!controller &amp;&amp; protectionModel) {//TODO add ability to set external controller if still needed at all? controller = ProtectionController(context).create({ protectionModel: protectionModel, protectionKeyController: protectionKeyController, eventBus: config.eventBus, debug: config.debug, events: config.events, BASE64: config.BASE64, constants: config.constants }); config.capabilities.setEncryptedMediaSupported(true); } return controller; } function getProtectionModel(config) { const debug = config.debug; const logger = debug.getLogger(instance); const eventBus = config.eventBus; const errHandler = config.errHandler; const videoElement = config.videoModel ? config.videoModel.getElement() : null; if ((!videoElement || videoElement.onencrypted !== undefined) &amp;&amp; (!videoElement || videoElement.mediaKeys !== undefined)) { logger.info('EME detected on this user agent! (ProtectionModel_21Jan2015)'); return ProtectionModel_21Jan2015(context).create({ debug: debug, eventBus: eventBus, events: config.events }); } else if (getAPI(videoElement, APIS_ProtectionModel_3Feb2014)) { logger.info('EME detected on this user agent! (ProtectionModel_3Feb2014)'); return ProtectionModel_3Feb2014(context).create({ debug: debug, eventBus: eventBus, events: config.events, api: getAPI(videoElement, APIS_ProtectionModel_3Feb2014) }); } else if (getAPI(videoElement, APIS_ProtectionModel_01b)) { logger.info('EME detected on this user agent! (ProtectionModel_01b)'); return ProtectionModel_01b(context).create({ debug: debug, eventBus: eventBus, errHandler: errHandler, events: config.events, api: getAPI(videoElement, APIS_ProtectionModel_01b) }); } else { logger.warn('No supported version of EME detected on this user agent! - Attempts to play encrypted content will fail!'); return null; } } function getAPI(videoElement, apis) { for (let i = 0; i &lt; apis.length; i++) { const api = apis[i]; // detect if api is supported by browser // check only first function in api -&gt; should be fine if (typeof videoElement[api[Object.keys(api)[0]]] !== 'function') { continue; } return api; } return null; } instance = { createProtectionSystem: createProtectionSystem }; return instance; } Protection.__dashjs_factory_name = 'Protection'; const factory = dashjs.FactoryMaker.getClassFactory(Protection); /* jshint ignore:line */ factory.events = ProtectionEvents; factory.errors = ProtectionErrors; dashjs.FactoryMaker.updateClassFactory(Protection.__dashjs_factory_name, factory); /* jshint ignore:line */ export default factory; × Search results Close "},"streaming_vo_metrics_RepresentationSwitch.js.html":{"id":"streaming_vo_metrics_RepresentationSwitch.js.html","title":"Source: streaming/vo/metrics/RepresentationSwitch.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/RepresentationSwitch.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class * @ignore */ class RepresentationSwitch { /** * @description This Object holds reference to the info at quality switch between two representations. */ constructor() { /** * Time of the switch event. * @public */ this.t = null; /** * The media presentation time of the earliest access unit * (out of all media content components) played out from * the Representation. * * @public */ this.mt = null; /** * Value of Representation@id identifying the switch-to Representation. * @public */ this.to = null; /** * If not present, this metrics concerns the Representation as a whole. * If present, lto indicates the value of SubRepresentation@level within * Representation identifying the switch-to level of the Representation. * * @public */ this.lto = null; } } export default RepresentationSwitch; × Search results Close "},"streaming_vo_metrics_RequestsQueue.js.html":{"id":"streaming_vo_metrics_RequestsQueue.js.html","title":"Source: streaming/vo/metrics/RequestsQueue.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/RequestsQueue.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class * @ignore */ class RequestsQueue { /** * @description This Object holds reference to Fragment Model's request queues */ constructor() { /** * Array of all of the requests that have begun to load * This request may not make it into the executed queue if it is abandon due to ABR rules for example. * @public */ this.loadingRequests = []; /** * Array of the The requests that have completed * @public */ this.executedRequests = []; } } export default RequestsQueue; × Search results Close "},"streaming_vo_metrics_SchedulingInfo.js.html":{"id":"streaming_vo_metrics_SchedulingInfo.js.html","title":"Source: streaming/vo/metrics/SchedulingInfo.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/SchedulingInfo.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class * @ignore */ class SchedulingInfo { /** * @description This Object holds reference to the index handling of the current fragment being loaded or executed. */ constructor() { /** * Type of stream Audio | Video | FragmentedText * @public */ this.mediaType = null; /** * Time of the scheduling event. * @public */ this.t = null; /** * Type of fragment (initialization | media) * @public */ this.type = null; /** * Presentation start time of fragment * @public */ this.startTime = null; /** * Availability start time of fragment * @public */ this.availabilityStartTime = null; /** * Duration of fragment * @public */ this.duration = null; /** * Bit Rate Quality of fragment * @public */ this.quality = null; /** * Range of fragment * @public */ this.range = null; /** * Current state of fragment * @public */ this.state = null; } } export default SchedulingInfo; × Search results Close "},"streaming_protection_vo_SessionToken.js.html":{"id":"streaming_protection_vo_SessionToken.js.html","title":"Source: streaming/protection/vo/SessionToken.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/protection/vo/SessionToken.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * All session identifiers (tokens) returned by ProtectionController as well as * ProtectionModel implementations are guaranteed to contain certain properties * regardless of the proprietary data each ProtectionModel will need to attach. * This interface defines the common APIs for session tokens available for * applications to access. * * @interface SessionToken * @ignore */ class SessionToken {} /** * The initialization data used to create this session * * @instance * @name initData * @memberof SessionToken * @type ArrayBuffer * @readonly */ /** * Returns the unique session ID designated to this session * * @function * @name SessionToken#getSessionID * @return {string} the session ID or the empty string if the implementation * does not support session IDs or the sessionID has not yet been established */ /** * The time, in milliseconds since 01 January, 1970 UTC, after which * the key(s) in the session will no longer be usable to decrypt * media data, or NaN if no such time exists * * @function * @name SessionToken#getExpirationTime * @returns {number} the expiration time or NaN if no expiration time exists * for this session */ /** * Returns a read-only map of key IDs known to the session to the * current status of the associated key. * * @function * @name SessionToken#getKeyStatuses * @returns {maplike&lt;BufferSource,MediaKeyStatus&gt;} the map of keys * in this session and their associated status */ /** * Returns the session type. Session types are defined * {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeySessionType|here} * * @function * @name SessionToken#getSessionType * @returns {string} The session type */ export default SessionToken; × Search results Close "},"streaming_Stream.js.html":{"id":"streaming_Stream.js.html","title":"Source: streaming/Stream.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/Stream.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from './constants/Constants'; import DashConstants from '../dash/constants/DashConstants'; import StreamProcessor from './StreamProcessor'; import FragmentController from './controllers/FragmentController'; import ThumbnailController from './thumbnail/ThumbnailController'; import EventBus from '../core/EventBus'; import Events from '../core/events/Events'; import Debug from '../core/Debug'; import Errors from '../core/errors/Errors'; import FactoryMaker from '../core/FactoryMaker'; import DashJSError from './vo/DashJSError'; import BoxParser from './utils/BoxParser'; import URLUtils from './utils/URLUtils'; function Stream(config) { config = config || {}; const context = this.context; const eventBus = EventBus(context).getInstance(); const urlUtils = URLUtils(context).getInstance(); const manifestModel = config.manifestModel; const mediaPlayerModel = config.mediaPlayerModel; const manifestUpdater = config.manifestUpdater; const adapter = config.adapter; const capabilities = config.capabilities; const errHandler = config.errHandler; const timelineConverter = config.timelineConverter; const dashMetrics = config.dashMetrics; const abrController = config.abrController; const playbackController = config.playbackController; const eventController = config.eventController; const mediaController = config.mediaController; const textController = config.textController; const videoModel = config.videoModel; const settings = config.settings; let instance, logger, streamInfo, streamProcessors, isStreamInitialized, isStreamActivated, isMediaInitialized, hasVideoTrack, hasAudioTrack, updateError, isUpdating, protectionController, fragmentController, thumbnailController, preloaded, boxParser, preloadingScheduled, debug, isEndedEventSignaled, trackChangedEvent; const codecCompatibilityTable = [ { 'codec': 'avc1', 'compatibleCodecs': ['avc3'] }, { 'codec': 'avc3', 'compatibleCodecs': ['avc1'] } ]; function setup() { debug = Debug(context).getInstance(); logger = debug.getLogger(instance); resetInitialSettings(); boxParser = BoxParser(context).getInstance(); fragmentController = FragmentController(context).create({ mediaPlayerModel: mediaPlayerModel, dashMetrics: dashMetrics, errHandler: errHandler, settings: settings, boxParser: boxParser, dashConstants: DashConstants, urlUtils: urlUtils }); registerEvents(); } function registerEvents() { eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance); eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance); eventBus.on(Events.INBAND_EVENTS, onInbandEvents, instance); } function unRegisterEvents() { eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance); eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance); eventBus.off(Events.INBAND_EVENTS, onInbandEvents, instance); } function registerProtectionEvents() { if (protectionController) { eventBus.on(Events.KEY_ERROR, onProtectionError, instance); eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance); eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance); eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance); eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance); eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance); } } function unRegisterProtectionEvents() { if (protectionController) { eventBus.off(Events.KEY_ERROR, onProtectionError, instance); eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance); eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance); eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance); eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance); eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance); } } function initialize(strInfo, prtctnController) { streamInfo = strInfo; if (strInfo) { fragmentController.setStreamId(strInfo.id); } protectionController = prtctnController; registerProtectionEvents(); eventBus.trigger(Events.STREAM_UPDATED, { streamInfo: streamInfo }); } /** * Activates Stream by re-initializing some of its components * @param {MediaSource} mediaSource * @memberof Stream# * @param {SourceBuffer} previousBuffers */ function activate(mediaSource, previousBuffers) { if (!isStreamActivated) { let result; eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance); if (!getPreloaded()) { result = initializeMedia(mediaSource, previousBuffers); } else { initializeAfterPreload(); result = previousBuffers; } isStreamActivated = true; return result; } return previousBuffers; } /** * Partially resets some of the Stream elements * @memberof Stream# * @param {boolean} keepBuffers */ function deactivate(keepBuffers) { let ln = streamProcessors ? streamProcessors.length : 0; const errored = false; for (let i = 0; i &lt; ln; i++) { let fragmentModel = streamProcessors[i].getFragmentModel(); fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration()); streamProcessors[i].reset(errored, keepBuffers); } streamProcessors = []; isStreamActivated = false; isMediaInitialized = false; setPreloaded(false); eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance); } function isActive() { return isStreamActivated; } function setMediaSource(mediaSource) { for (let i = 0; i &lt; streamProcessors.length;) { if (isMediaSupported(streamProcessors[i].getMediaInfo())) { streamProcessors[i].setMediaSource(mediaSource); i++; } else { streamProcessors[i].reset(); streamProcessors.splice(i, 1); } } for (let i = 0; i &lt; streamProcessors.length; i++) { //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state //so do this after the buffers are created above. streamProcessors[i].dischargePreBuffer(); } if (streamProcessors.length === 0) { const msg = 'No streams to play.'; errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg + 'nostreams', manifestModel.getValue())); logger.fatal(msg); } } function resetInitialSettings() { deactivate(); streamInfo = null; isStreamInitialized = false; hasVideoTrack = false; hasAudioTrack = false; updateError = {}; isUpdating = false; preloadingScheduled = false; isEndedEventSignaled = false; } function reset() { if (playbackController) { playbackController.pause(); } if (fragmentController) { fragmentController.reset(); fragmentController = null; } resetInitialSettings(); unRegisterEvents(); unRegisterProtectionEvents(); setPreloaded(false); } function getDuration() { return streamInfo ? streamInfo.duration : NaN; } function getIsEndedEventSignaled() { return isEndedEventSignaled; } function setIsEndedEventSignaled(value) { isEndedEventSignaled = value; } function getStartTime() { return streamInfo ? streamInfo.start : NaN; } function getPreloadingScheduled() { return preloadingScheduled; } function setPreloadingScheduled(value) { preloadingScheduled = value; } function getLiveStartTime() { if (!streamInfo.manifestInfo.isDynamic) return NaN; // Get live start time of the video stream (1st in array of streams) // or audio if no video stream for (let i = 0; i &lt; streamProcessors.length; i++) { if (streamProcessors[i].getType() === Constants.AUDIO || streamProcessors[i].getType() === Constants.VIDEO) { return streamProcessors[i].getLiveStartTime(); } } return NaN; } function getId() { return streamInfo ? streamInfo.id : null; } function getStreamInfo() { return streamInfo; } function getHasAudioTrack() { return hasAudioTrack; } function getHasVideoTrack() { return hasVideoTrack; } function getThumbnailController() { return thumbnailController; } function checkConfig() { if (!videoModel || !abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) { throw new Error(Constants.MISSING_CONFIG_ERROR); } } /** * @param {string} type * @returns {Array} * @memberof Stream# */ function getBitrateListFor(type) { checkConfig(); if (type === Constants.IMAGE) { if (!thumbnailController) { return []; } return thumbnailController.getBitrateList(); } const mediaInfo = getMediaInfo(type); return abrController.getBitrateList(mediaInfo); } function onProtectionError(event) { if (event.error) { errHandler.error(event.error); logger.fatal(event.error.message); reset(); } } function isMediaSupported(mediaInfo) { const type = mediaInfo ? mediaInfo.type : null; let codec, msg; if (type === Constants.MUXED) { msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines'; logger.fatal(msg); errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue())); return false; } if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) { return true; } codec = mediaInfo.codec; logger.debug(type + ' codec: ' + codec); if (!!mediaInfo.contentProtection &amp;&amp; !capabilities.supportsEncryptedMedia()) { errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIAKEYS_ERROR_CODE, Errors.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE)); } else if (!capabilities.supportsCodec(codec)) { msg = type + 'Codec (' + codec + ') is not supported.'; logger.error(msg); return false; } return true; } function onCurrentTrackChanged(e) { if (!streamInfo || e.newMediaInfo.streamInfo.id !== streamInfo.id) return; let mediaInfo = e.newMediaInfo; let manifest = manifestModel.getValue(); adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo); let processor = getProcessorForMediaInfo(mediaInfo); if (!processor) return; let currentTime = playbackController.getTime(); logger.info('Stream - Process track changed at current time ' + currentTime); logger.debug('Stream - Update stream controller'); if (manifest.refreshManifestOnSwitchTrack) { // Applies only for MSS streams logger.debug('Stream - Refreshing manifest for switch track'); trackChangedEvent = e; manifestUpdater.refreshManifest(); } else { processor.selectMediaInfo(mediaInfo); if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) { abrController.updateTopQualityIndex(mediaInfo); processor.switchTrackAsked(); processor.getFragmentModel().abortRequests(); } else { processor.getScheduleController().setSeekTarget(currentTime); processor.setBufferingTime(currentTime); processor.resetIndexHandler(); } } } function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) { let fragmentModel = fragmentController.getModel(getId(), mediaInfo ? mediaInfo.type : null); let streamProcessor = StreamProcessor(context).create({ streamInfo: streamInfo, type: mediaInfo ? mediaInfo.type : null, mimeType: mediaInfo ? mediaInfo.mimeType : null, timelineConverter: timelineConverter, adapter: adapter, manifestModel: manifestModel, mediaPlayerModel: mediaPlayerModel, fragmentModel: fragmentModel, dashMetrics: config.dashMetrics, baseURLController: config.baseURLController, abrController: abrController, playbackController: playbackController, mediaController: mediaController, textController: textController, errHandler: errHandler, settings: settings, boxParser: boxParser }); streamProcessor.initialize(mediaSource, hasVideoTrack); abrController.updateTopQualityIndex(mediaInfo); if (optionalSettings) { streamProcessor.setBuffer(optionalSettings.buffer); streamProcessor.setBufferingTime(optionalSettings.currentTime); streamProcessors[optionalSettings.replaceIdx] = streamProcessor; } else { streamProcessors.push(streamProcessor); } if (optionalSettings &amp;&amp; optionalSettings.ignoreMediaInfo) { return; } if (mediaInfo &amp;&amp; (mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) { let idx; for (let i = 0; i &lt; allMediaForType.length; i++) { if (allMediaForType[i].index === mediaInfo.index) { idx = i; } streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor } streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info } else { streamProcessor.addMediaInfo(mediaInfo, true); } } function initializeMediaForType(type, mediaSource) { const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type); let mediaInfo = null; let initialMediaInfo; if (!allMediaForType || allMediaForType.length === 0) { logger.info('No ' + type + ' data.'); return; } if (type === Constants.VIDEO) { hasVideoTrack = true; } if (type === Constants.AUDIO) { hasAudioTrack = true; } for (let i = 0, ln = allMediaForType.length; i &lt; ln; i++) { mediaInfo = allMediaForType[i]; if (type === Constants.EMBEDDED_TEXT) { textController.addEmbeddedTrack(mediaInfo); } else { if (!isMediaSupported(mediaInfo)) continue; mediaController.addTrack(mediaInfo); } } if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) { return; } if (type === Constants.IMAGE) { thumbnailController = ThumbnailController(context).create({ streamInfo: streamInfo, adapter: adapter, baseURLController: config.baseURLController, timelineConverter: config.timelineConverter, debug: debug, eventBus: eventBus, events: Events, dashConstants: DashConstants }); return; } mediaController.checkInitialMediaSettingsForType(type, streamInfo); initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo); eventBus.trigger(Events.STREAM_INITIALIZING, { streamInfo: streamInfo, mediaInfo: mediaInfo }); // TODO : How to tell index handler live/duration? // TODO : Pass to controller and then pass to each method on handler? createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource); } function addInlineEvents() { if (eventController) { const events = adapter.getEventsFor(streamInfo); eventController.addInlineEvents(events); } } function addInbandEvents(events) { if (eventController) { eventController.addInbandEvents(events); } } function initializeMedia(mediaSource, previousBuffers) { checkConfig(); let element = videoModel.getElement(); addInlineEvents(); isUpdating = true; filterCodecs(Constants.VIDEO); filterCodecs(Constants.AUDIO); if (!element || (element &amp;&amp; (/^VIDEO$/i).test(element.nodeName))) { initializeMediaForType(Constants.VIDEO, mediaSource); } initializeMediaForType(Constants.AUDIO, mediaSource); initializeMediaForType(Constants.TEXT, mediaSource); initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource); initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource); initializeMediaForType(Constants.MUXED, mediaSource); initializeMediaForType(Constants.IMAGE, mediaSource); //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText. const buffers = createBuffers(previousBuffers); isMediaInitialized = true; isUpdating = false; if (streamProcessors.length === 0) { const msg = 'No streams to play.'; errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue())); logger.fatal(msg); } else { checkIfInitializationCompleted(); } return buffers; } function initializeAfterPreload() { isUpdating = true; checkConfig(); filterCodecs(Constants.VIDEO); filterCodecs(Constants.AUDIO); isMediaInitialized = true; isUpdating = false; if (streamProcessors.length === 0) { const msg = 'No streams to play.'; errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue())); logger.debug(msg); } else { checkIfInitializationCompleted(); } } function filterCodecs(type) { const realAdaptation = adapter.getAdaptationForType(streamInfo ? streamInfo.index : null, type, streamInfo); if (!realAdaptation || !Array.isArray(realAdaptation.Representation_asArray)) return; // Filter codecs that are not supported realAdaptation.Representation_asArray = realAdaptation.Representation_asArray.filter((_, i) =&gt; { // keep at least codec from lowest representation if (i === 0) return true; const codec = adapter.getCodec(realAdaptation, i, true); if (!capabilities.supportsCodec(codec)) { logger.error('[Stream] codec not supported: ' + codec); return false; } return true; }); } function checkIfInitializationCompleted() { const ln = streamProcessors.length; const hasError = !!updateError.audio || !!updateError.video; let error = hasError ? new DashJSError(Errors.DATA_UPDATE_FAILED_ERROR_CODE, Errors.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null; for (let i = 0; i &lt; ln; i++) { if (streamProcessors[i].isUpdating() || isUpdating) { return; } } if (!isMediaInitialized) { return; } if (protectionController) { // Need to check if streamProcessors exists because streamProcessors // could be cleared in case an error is detected while initializing DRM keysystem for (let i = 0; i &lt; ln &amp;&amp; streamProcessors[i]; i++) { if (streamProcessors[i].getType() === Constants.AUDIO || streamProcessors[i].getType() === Constants.VIDEO || streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) { protectionController.initializeForMedia(streamProcessors[i].getMediaInfo()); } } } if (error) { errHandler.error(error); } else if (!isStreamInitialized) { isStreamInitialized = true; timelineConverter.setTimeSyncCompleted(true); eventBus.trigger(Events.STREAM_INITIALIZED, { streamInfo: streamInfo, liveStartTime: !preloaded ? getLiveStartTime() : NaN }); } // (Re)start ScheduleController: // - in case stream initialization has been completed after 'play' event (case for SegmentBase streams) // - in case stream is complete but a track switch has been requested for (let i = 0; i &lt; ln &amp;&amp; streamProcessors[i]; i++) { streamProcessors[i].getScheduleController().start(); } } function getMediaInfo(type) { let streamProcessor = null; for (let i = 0; i &lt; streamProcessors.length; i++) { streamProcessor = streamProcessors[i]; if (streamProcessor.getType() === type) { return streamProcessor.getMediaInfo(); } } return null; } function createBuffers(previousBuffers) { const buffers = {}; for (let i = 0, ln = streamProcessors.length; i &lt; ln; i++) { const buffer = streamProcessors[i].createBuffer(previousBuffers); if (buffer) { buffers[streamProcessors[i].getType()] = buffer.getBuffer(); } } return buffers; } function onBufferingCompleted(e) { if (e.streamId !== streamInfo.id) return; let processors = getProcessors(); const ln = processors.length; if (ln === 0) { logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined'); return; } // if there is at least one buffer controller that has not completed buffering yet do nothing for (let i = 0; i &lt; ln; i++) { //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED if (!processors[i].isBufferingCompleted() &amp;&amp; (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) { logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed'); return; } } logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED'); eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, { streamInfo: streamInfo }); } function onDataUpdateCompleted(e) { if (!streamInfo || e.sender.getStreamId() !== streamInfo.id) return; updateError[e.sender.getType()] = e.error; checkIfInitializationCompleted(); } function onInbandEvents(e) { if (!streamInfo || e.sender.getStreamInfo().id !== streamInfo.id) return; addInbandEvents(e.events); } function getProcessorForMediaInfo(mediaInfo) { if (!mediaInfo) { return null; } let processors = getProcessors(); return processors.filter(function (processor) { return (processor.getType() === mediaInfo.type); })[0]; } function getProcessors() { let arr = []; let type, streamProcessor; for (let i = 0; i &lt; streamProcessors.length; i++) { streamProcessor = streamProcessors[i]; type = streamProcessor.getType(); if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) { arr.push(streamProcessor); } } return arr; } function updateData(updatedStreamInfo) { logger.info('Manifest updated... updating data system wide.'); isStreamActivated = false; isUpdating = true; streamInfo = updatedStreamInfo; eventBus.trigger(Events.STREAM_UPDATED, { streamInfo: streamInfo }); if (eventController) { addInlineEvents(); } filterCodecs(Constants.VIDEO); filterCodecs(Constants.AUDIO); for (let i = 0, ln = streamProcessors.length; i &lt; ln; i++) { let streamProcessor = streamProcessors[i]; streamProcessor.updateStreamInfo(streamInfo); let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType()); abrController.updateTopQualityIndex(mediaInfo); streamProcessor.addMediaInfo(mediaInfo, true); } if (trackChangedEvent) { let mediaInfo = trackChangedEvent.newMediaInfo; if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) { let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo); if (!processor) return; processor.switchTrackAsked(); trackChangedEvent = undefined; } } isUpdating = false; checkIfInitializationCompleted(); } function isMediaCodecCompatible(newStream, previousStream = null) { return compareCodecs(newStream, Constants.VIDEO, previousStream) &amp;&amp; compareCodecs(newStream, Constants.AUDIO, previousStream); } function isProtectionCompatible(stream, previousStream = null) { return compareProtectionConfig(stream, Constants.VIDEO, previousStream) &amp;&amp; compareProtectionConfig(stream, Constants.AUDIO, previousStream); } function compareProtectionConfig(stream, type, previousStream = null) { if (!stream) { return false; } const newStreamInfo = stream.getStreamInfo(); const currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo(); if (!newStreamInfo || !currentStreamInfo) { return false; } const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo); const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo); if (!newAdaptation || !currentAdaptation) { // If there is no adaptation for neither the old or the new stream they're compatible return !newAdaptation &amp;&amp; !currentAdaptation; } // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers. return !(!isAdaptationDrmProtected(currentAdaptation) &amp;&amp; isAdaptationDrmProtected(newAdaptation)); } function isAdaptationDrmProtected(adaptation) { if (!adaptation) { // If there is no adaptation for neither the old or the new stream they're compatible return false; } // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers. return !!(adaptation.ContentProtection || (adaptation.Representation &amp;&amp; adaptation.Representation.length &gt; 0 &amp;&amp; adaptation.Representation[0].ContentProtection)); } function compareCodecs(newStream, type, previousStream = null) { if (!newStream || !newStream.hasOwnProperty('getStreamInfo')) { return false; } const newStreamInfo = newStream.getStreamInfo(); const currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo(); if (!newStreamInfo || !currentStreamInfo) { return false; } const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo); const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo); if (!newAdaptation || !currentAdaptation) { // If there is no adaptation for neither the old or the new stream they're compatible return !newAdaptation &amp;&amp; !currentAdaptation; } const sameMimeType = newAdaptation &amp;&amp; currentAdaptation &amp;&amp; newAdaptation.mimeType === currentAdaptation.mimeType; const oldCodecs = currentAdaptation.Representation_asArray.map((representation) =&gt; { return representation.codecs; }); const newCodecs = newAdaptation.Representation_asArray.map((representation) =&gt; { return representation.codecs; }); const codecMatch = newCodecs.some((newCodec) =&gt; { return oldCodecs.indexOf(newCodec) &gt; -1; }); const partialCodecMatch = newCodecs.some((newCodec) =&gt; oldCodecs.some((oldCodec) =&gt; codecRootCompatibleWithCodec(oldCodec, newCodec))); return codecMatch || (partialCodecMatch &amp;&amp; sameMimeType); } // Check if the root of the old codec is the same as the new one, or if it's declared as compatible in the compat table function codecRootCompatibleWithCodec(codec1, codec2) { const codecRoot = codec1.split('.')[0]; const rootCompatible = codec2.indexOf(codecRoot) === 0; let compatTableCodec; for (let i = 0; i &lt; codecCompatibilityTable.length; i++) { if (codecCompatibilityTable[i].codec === codecRoot) { compatTableCodec = codecCompatibilityTable[i]; break; } } if (compatTableCodec) { return rootCompatible || compatTableCodec.compatibleCodecs.some((compatibleCodec) =&gt; codec2.indexOf(compatibleCodec) === 0); } return rootCompatible; } function setPreloaded(value) { preloaded = value; } function getPreloaded() { return preloaded; } function preload(mediaSource, previousBuffers) { if (!getPreloaded()) { addInlineEvents(); initializeMediaForType(Constants.VIDEO, mediaSource); initializeMediaForType(Constants.AUDIO, mediaSource); initializeMediaForType(Constants.TEXT, mediaSource); initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource); initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource); initializeMediaForType(Constants.MUXED, mediaSource); initializeMediaForType(Constants.IMAGE, mediaSource); createBuffers(previousBuffers); eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance); for (let i = 0; i &lt; streamProcessors.length &amp;&amp; streamProcessors[i]; i++) { streamProcessors[i].getScheduleController().start(); } setPreloaded(true); } } instance = { initialize: initialize, activate: activate, deactivate: deactivate, isActive: isActive, getDuration: getDuration, getStartTime: getStartTime, getId: getId, getStreamInfo: getStreamInfo, getHasAudioTrack: getHasAudioTrack, getHasVideoTrack: getHasVideoTrack, preload: preload, getThumbnailController: getThumbnailController, getBitrateListFor: getBitrateListFor, updateData: updateData, reset: reset, getProcessors: getProcessors, setMediaSource: setMediaSource, isMediaCodecCompatible: isMediaCodecCompatible, isProtectionCompatible: isProtectionCompatible, getPreloaded: getPreloaded, getPreloadingScheduled, setPreloadingScheduled, getIsEndedEventSignaled, setIsEndedEventSignaled }; setup(); return instance; } Stream.__dashjs_factory_name = 'Stream'; export default FactoryMaker.getClassFactory(Stream); × Search results Close "},"streaming_controllers_StreamController.js.html":{"id":"streaming_controllers_StreamController.js.html","title":"Source: streaming/controllers/StreamController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/controllers/StreamController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import MetricsConstants from '../constants/MetricsConstants'; import Stream from '../Stream'; import ManifestUpdater from '../ManifestUpdater'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import { PlayList, PlayListTrace } from '../vo/metrics/PlayList'; import Debug from '../../core/Debug'; import InitCache from '../utils/InitCache'; import URLUtils from '../utils/URLUtils'; import MediaPlayerEvents from '../MediaPlayerEvents'; import TimeSyncController from './TimeSyncController'; import MediaSourceController from './MediaSourceController'; import DashJSError from '../vo/DashJSError'; import Errors from '../../core/errors/Errors'; import EventController from './EventController'; const PLAYBACK_ENDED_TIMER_INTERVAL = 200; const PREBUFFERING_CAN_START_INTERVAL = 500; function StreamController() { const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, capabilities, manifestUpdater, manifestLoader, manifestModel, adapter, dashMetrics, mediaSourceController, timeSyncController, baseURLController, abrController, mediaController, eventController, textController, initCache, urlUtils, errHandler, timelineConverter, streams, activeStream, protectionController, protectionData, autoPlay, isStreamSwitchingInProgress, hasMediaError, hasInitialisationError, mediaSource, videoModel, playbackController, mediaPlayerModel, isPaused, initialPlayback, isPeriodSwitchInProgress, playbackEndedTimerInterval, prebufferingCanStartInterval, buffers, preloadingStreams, supportsChangeType, settings, preBufferingCheckInProgress; function setup() { logger = Debug(context).getInstance().getLogger(instance); timeSyncController = TimeSyncController(context).getInstance(); mediaSourceController = MediaSourceController(context).getInstance(); initCache = InitCache(context).getInstance(); urlUtils = URLUtils(context).getInstance(); resetInitialSettings(); } function initialize(autoPl, protData) { checkConfig(); autoPlay = autoPl; protectionData = protData; timelineConverter.initialize(); manifestUpdater = ManifestUpdater(context).create(); manifestUpdater.setConfig({ manifestModel: manifestModel, adapter: adapter, manifestLoader: manifestLoader, errHandler: errHandler, settings: settings }); manifestUpdater.initialize(); eventController = EventController(context).getInstance(); eventController.setConfig({ manifestUpdater: manifestUpdater, playbackController: playbackController }); eventController.start(); registerEvents(); } function registerEvents() { eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this); eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this); eventBus.on(Events.GAP_CAUSED_SEEK_TO_PERIOD_END, onGapCausedPlaybackSeek, this); eventBus.on(Events.PLAYBACK_ERROR, onPlaybackError, this); eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this); eventBus.on(Events.PLAYBACK_PAUSED, onPlaybackPaused, this); eventBus.on(Events.PLAYBACK_ENDED, onEnded, this); eventBus.on(Events.MANIFEST_UPDATED, onManifestUpdated, this); eventBus.on(Events.STREAM_BUFFERING_COMPLETED, onStreamBufferingCompleted, this); eventBus.on(Events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, this); eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncCompleted, this); eventBus.on(MediaPlayerEvents.METRIC_ADDED, onMetricAdded, this); } function unRegisterEvents() { eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this); eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this); eventBus.off(Events.GAP_CAUSED_SEEK_TO_PERIOD_END, onGapCausedPlaybackSeek, this); eventBus.off(Events.PLAYBACK_ERROR, onPlaybackError, this); eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this); eventBus.off(Events.PLAYBACK_PAUSED, onPlaybackPaused, this); eventBus.off(Events.PLAYBACK_ENDED, onEnded, this); eventBus.off(Events.MANIFEST_UPDATED, onManifestUpdated, this); eventBus.off(Events.STREAM_BUFFERING_COMPLETED, onStreamBufferingCompleted, this); eventBus.off(Events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, this); eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncCompleted, this); eventBus.off(MediaPlayerEvents.METRIC_ADDED, onMetricAdded, this); } /* * Called when current playback position is changed. * Used to determine the time current stream is finished and we should switch to the next stream. */ function onPlaybackTimeUpdated(/*e*/) { if (hasVideoTrack()) { const playbackQuality = videoModel.getPlaybackQuality(); if (playbackQuality) { dashMetrics.addDroppedFrames(playbackQuality); } } } function onPlaybackSeeking(e) { const seekingStream = getStreamForTime(e.seekTime); if (seekingStream === activeStream &amp;&amp; preloadingStreams &amp;&amp; preloadingStreams.length &gt; 0) { // Seeking to the current period was requested while preloading the next one, deactivate preloading one preloadingStreams.forEach((s) =&gt; { s.deactivate(true); }); } if (seekingStream &amp;&amp; seekingStream !== activeStream) { // If we're preloading other stream, the active one was deactivated and we need to switch back flushPlaylistMetrics(PlayListTrace.END_OF_PERIOD_STOP_REASON); switchStream(seekingStream, activeStream, e.seekTime); } else { flushPlaylistMetrics(PlayListTrace.USER_REQUEST_STOP_REASON); } createPlaylistMetrics(PlayList.SEEK_START_REASON); } function onGapCausedPlaybackSeek(e) { const nextStream = getNextStream(); flushPlaylistMetrics(PlayListTrace.END_OF_PERIOD_STOP_REASON); switchStream(nextStream, activeStream, e.seekTime); createPlaylistMetrics(PlayList.SEEK_START_REASON); } function onPlaybackStarted( /*e*/) { logger.debug('[onPlaybackStarted]'); if (initialPlayback) { initialPlayback = false; createPlaylistMetrics(PlayList.INITIAL_PLAYOUT_START_REASON); } else { if (isPaused) { isPaused = false; createPlaylistMetrics(PlayList.RESUME_FROM_PAUSE_START_REASON); } } } function onPlaybackPaused(e) { logger.debug('[onPlaybackPaused]'); if (!e.ended) { isPaused = true; flushPlaylistMetrics(PlayListTrace.USER_REQUEST_STOP_REASON); } } function startPlaybackEndedTimerInterval() { if (!playbackEndedTimerInterval) { playbackEndedTimerInterval = setInterval(function () { if (!isStreamSwitchingInProgress &amp;&amp; playbackController.getTimeToStreamEnd() &lt;= 0) { eventBus.trigger(Events.PLAYBACK_ENDED, {'isLast': getActiveStreamInfo().isLast}); } }, PLAYBACK_ENDED_TIMER_INTERVAL); } } function stopPlaybackEndedTimerInterval() { if (playbackEndedTimerInterval) { clearInterval(playbackEndedTimerInterval); playbackEndedTimerInterval = null; } } function startCheckIfPrebufferingCanStartInterval() { if (!prebufferingCanStartInterval) { prebufferingCanStartInterval = setInterval(function () { checkIfPrebufferingCanStart(); }, PREBUFFERING_CAN_START_INTERVAL); } } function stopCheckIfPrebufferingCanStartInterval() { clearInterval(prebufferingCanStartInterval); prebufferingCanStartInterval = null; } function checkIfPrebufferingCanStart() { // In multiperiod situations, we constantly check if the streams have finished buffering so we can immediately start buffering the next stream if (!activeStream || !hasStreamFinishedBuffering(activeStream)) { return; } const upcomingStreams = getNextStreams(activeStream); let i = 0; while (i &lt; upcomingStreams.length) { const stream = upcomingStreams[i]; const previousStream = i === 0 ? activeStream : upcomingStreams[i - 1]; // If the preloading for the current stream is not scheduled, but its predecessor has finished buffering we can start prebuffering this stream if (!stream.getPreloadingScheduled() &amp;&amp; (hasStreamFinishedBuffering(previousStream))) { if (mediaSource) { // We can not start prebuffering if the start of the next period is in the future. This will cause problems when calculating the segmentAvailabilityRange and updating the representations in the RepresentationController // As long as the timeline converter returns an invalid range we do not start the prebuffering const mediaTypes = [Constants.VIDEO, Constants.AUDIO]; let segmentAvailabilityRangeIsOk = true; mediaTypes.forEach((mediaType) =&gt; { const mediaInfo = adapter.getMediaInfoForType(stream.getStreamInfo(), mediaType); const voRepresentations = adapter.getVoRepresentations(mediaInfo); voRepresentations.forEach((voRep) =&gt; { const range = timelineConverter.calcSegmentAvailabilityRange(voRep, true); if (range.end &lt; range.start) { segmentAvailabilityRangeIsOk = false; } }); }); if (segmentAvailabilityRangeIsOk) { onStreamCanLoadNext(stream, previousStream); } } } i += 1; } } function hasStreamFinishedBuffering(stream) { try { if (!stream) { return false; } const streamProcessors = stream.getProcessors().filter((sp) =&gt; { return sp.getType() === Constants.AUDIO || sp.getType() === Constants.VIDEO; }); if (!streamProcessors || streamProcessors.length === 0) { return false; } const unfinishedStreamProcessors = streamProcessors.filter((sp) =&gt; { return !sp.isBufferingCompleted(); }); return unfinishedStreamProcessors &amp;&amp; unfinishedStreamProcessors.length === 0; } catch (e) { return false; } } function onStreamBufferingCompleted() { const isLast = getActiveStreamInfo().isLast; if (mediaSource &amp;&amp; isLast) { logger.info('[onStreamBufferingCompleted] calls signalEndOfStream of mediaSourceController.'); mediaSourceController.signalEndOfStream(mediaSource); } } function canSourceBuffersBeReused(nextStream, previousStream) { try { return (previousStream.isProtectionCompatible(nextStream, previousStream) &amp;&amp; (supportsChangeType || previousStream.isMediaCodecCompatible(nextStream, previousStream)) &amp;&amp; !hasCriticalTexttracks(nextStream)); } catch (e) { return false; } } function onStreamCanLoadNext(nextStream, previousStream = null) { if (mediaSource &amp;&amp; !nextStream.getPreloaded()) { // Seamless period switch allowed only if: // - none of the periods uses contentProtection. // - AND changeType method implemented by browser or periods use the same codec. let seamlessPeriodSwitch = canSourceBuffersBeReused(nextStream, previousStream); if (seamlessPeriodSwitch) { nextStream.setPreloadingScheduled(true); logger.info(`[onStreamCanLoadNext] Preloading next stream with id ${nextStream.getId()}`); isPeriodSwitchInProgress = true; nextStream.preload(mediaSource, buffers); preloadingStreams.push(nextStream); nextStream.getProcessors().forEach(p =&gt; { p.setBufferingTime(nextStream.getStartTime()); }); } } } function hasCriticalTexttracks(stream) { try { // if the upcoming stream has stpp or wvtt texttracks we need to reset the sourcebuffers and can not prebuffer const streamInfo = stream.getStreamInfo(); const as = adapter.getAdaptationForType(streamInfo.index, Constants.FRAGMENTED_TEXT, streamInfo); if (!as) { return false; } return (as.codecs.indexOf('stpp') !== -1) || (as.codecs.indexOf('wvtt') !== -1); } catch (e) { return false; } } function getStreamForTime(time) { if (isNaN(time)) { return null; } let streamDuration = 0; let stream = null; const ln = streams.length; if (ln &gt; 0) { streamDuration += streams[0].getStartTime(); } for (let i = 0; i &lt; ln; i++) { stream = streams[i]; streamDuration = parseFloat((streamDuration + stream.getDuration()).toFixed(5)); if (time &lt; streamDuration) { return stream; } } return null; } /** * Returns a playhead time, in seconds, converted to be relative * to the start of an identified stream/period or null if no such stream * @param {number} time * @param {string} id * @returns {number|null} */ function getTimeRelativeToStreamId(time, id) { let stream = null; let baseStart = 0; let streamStart = 0; let streamDur = null; for (let i = 0; i &lt; streams.length; i++) { stream = streams[i]; streamStart = stream.getStartTime(); streamDur = stream.getDuration(); // use start time, if not undefined or NaN or similar if (Number.isFinite(streamStart)) { baseStart = streamStart; } if (stream.getId() === id) { return time - baseStart; } else { // use duration if not undefined or NaN or similar if (Number.isFinite(streamDur)) { baseStart += streamDur; } } } return null; } function getActiveStreamProcessors() { return activeStream ? activeStream.getProcessors() : []; } function onEnded(e) { if (!activeStream.getIsEndedEventSignaled()) { activeStream.setIsEndedEventSignaled(true); const nextStream = getNextStream(); if (nextStream) { logger.debug(`StreamController onEnded, found next stream with id ${nextStream.getStreamInfo().id}`); switchStream(nextStream, activeStream, NaN); } else { logger.debug('StreamController no next stream found'); activeStream.setIsEndedEventSignaled(false); } flushPlaylistMetrics(nextStream ? PlayListTrace.END_OF_PERIOD_STOP_REASON : PlayListTrace.END_OF_CONTENT_STOP_REASON); isPeriodSwitchInProgress = false; } if (e &amp;&amp; e.isLast) { stopPlaybackEndedTimerInterval(); } } function getNextStream(stream = null) { const refStream = stream ? stream : activeStream ? activeStream : null; if (refStream) { const start = refStream.getStreamInfo().start; const duration = refStream.getStreamInfo().duration; const streamEnd = parseFloat((start + duration).toFixed(5)); let i = 0; let targetIndex = -1; let lastDiff = NaN; while (i &lt; streams.length) { const s = streams[i]; const diff = s.getStreamInfo().start - streamEnd; if (diff &gt;= 0 &amp;&amp; (isNaN(lastDiff) || diff &lt; lastDiff)) { lastDiff = diff; targetIndex = i; } i += 1; } if (targetIndex &gt;= 0) { return streams[targetIndex]; } return null; } return null; } function getNextStreams(stream) { try { const refStream = stream ? stream : activeStream ? activeStream : null; if (refStream) { const start = refStream.getStreamInfo().start; return streams.filter(function (stream) { return (stream.getStreamInfo().start &gt; start); }); } } catch (e) { return []; } } function switchStream(stream, previousStream, seekTime) { if (isStreamSwitchingInProgress || !stream || (previousStream === stream &amp;&amp; stream.isActive())) return; isStreamSwitchingInProgress = true; eventBus.trigger(Events.PERIOD_SWITCH_STARTED, { fromStreamInfo: previousStream ? previousStream.getStreamInfo() : null, toStreamInfo: stream.getStreamInfo() }); let seamlessPeriodSwitch = false; if (previousStream) { seamlessPeriodSwitch = canSourceBuffersBeReused(stream, previousStream); previousStream.deactivate(seamlessPeriodSwitch); } // Determine seek time when switching to new period // - seek at given seek time // - or seek at period start if upcoming period is not prebuffered seekTime = !isNaN(seekTime) ? seekTime : (!seamlessPeriodSwitch &amp;&amp; previousStream ? stream.getStreamInfo().start : NaN); logger.info(`Switch to stream ${stream.getId()}. Seektime is ${seekTime}, current playback time is ${playbackController.getTime()}`); logger.info(`Seamless period switch is set to ${seamlessPeriodSwitch}`); activeStream = stream; preloadingStreams = preloadingStreams.filter((s) =&gt; { return s.getId() !== activeStream.getId(); }); playbackController.initialize(getActiveStreamInfo(), !!previousStream, seekTime); if (videoModel.getElement()) { openMediaSource(seekTime, (previousStream === null), false, seamlessPeriodSwitch); } else { activateStream(seekTime, seamlessPeriodSwitch); } isPeriodSwitchInProgress = false; } function switchToVideoElement(seekTime) { if (activeStream) { playbackController.initialize(getActiveStreamInfo()); openMediaSource(seekTime, false, true, false); } } function openMediaSource(seekTime, sourceInitialized, streamActivated, keepBuffers) { let sourceUrl; function onMediaSourceOpen() { // Manage situations in which a call to reset happens while MediaSource is being opened if (!mediaSource || mediaSource.readyState !== 'open') return; logger.debug('MediaSource is open!'); window.URL.revokeObjectURL(sourceUrl); mediaSource.removeEventListener('sourceopen', onMediaSourceOpen); mediaSource.removeEventListener('webkitsourceopen', onMediaSourceOpen); setMediaDuration(); if (!sourceInitialized) { eventBus.trigger(Events.SOURCE_INITIALIZED); } if (streamActivated) { activeStream.setMediaSource(mediaSource); } else { activateStream(seekTime, keepBuffers); } } if (!mediaSource) { mediaSource = mediaSourceController.createMediaSource(); mediaSource.addEventListener('sourceopen', onMediaSourceOpen, false); mediaSource.addEventListener('webkitsourceopen', onMediaSourceOpen, false); sourceUrl = mediaSourceController.attachMediaSource(mediaSource, videoModel); logger.debug('MediaSource attached to element. Waiting on open...'); } else { if (keepBuffers) { activateStream(seekTime, keepBuffers); if (!sourceInitialized) { eventBus.trigger(Events.SOURCE_INITIALIZED); } } else { mediaSourceController.detachMediaSource(videoModel); mediaSource.addEventListener('sourceopen', onMediaSourceOpen, false); mediaSource.addEventListener('webkitsourceopen', onMediaSourceOpen, false); sourceUrl = mediaSourceController.attachMediaSource(mediaSource, videoModel); logger.debug('MediaSource attached to element. Waiting on open...'); } } } function getActiveStream() { return activeStream; } function activateStream(seekTime, keepBuffers) { buffers = activeStream.activate(mediaSource, keepBuffers ? buffers : undefined); // check if change type is supported by the browser if (buffers) { const keys = Object.keys(buffers); if (keys.length &gt; 0 &amp;&amp; buffers[keys[0]].changeType) { supportsChangeType = true; } } if (!initialPlayback) { if (!isNaN(seekTime)) { // If the streamswitch has been triggered by a seek command there is no need to seek again. Still we need to trigger the seeking event in order for the controllers to adjust the new time if (seekTime === playbackController.getTime()) { eventBus.trigger(Events.SEEK_TARGET, {time: seekTime, streamId: activeStream.getId()}); } else { playbackController.seek(seekTime); } } } if (autoPlay || !initialPlayback) { playbackController.play(); } isStreamSwitchingInProgress = false; eventBus.trigger(Events.PERIOD_SWITCH_COMPLETED, { toStreamInfo: getActiveStreamInfo() }); } function setMediaDuration(duration) { const manifestDuration = duration ? duration : getActiveStreamInfo().manifestInfo.duration; if (manifestDuration &amp;&amp; !isNaN(manifestDuration)) { const mediaDuration = mediaSourceController.setDuration(mediaSource, manifestDuration); logger.debug('Duration successfully set to: ' + mediaDuration); } } function getComposedStream(streamInfo) { for (let i = 0, ln = streams.length; i &lt; ln; i++) { if (streams[i].getId() === streamInfo.id) { return streams[i]; } } return null; } function composeStreams() { try { const streamsInfo = adapter.getStreamsInfo(); if (streamsInfo.length === 0) { throw new Error('There are no streams'); } dashMetrics.updateManifestUpdateInfo({ currentTime: playbackController.getTime(), buffered: videoModel.getBufferRange(), presentationStartTime: streamsInfo[0].start, clientTimeOffset: timelineConverter.getClientTimeOffset() }); // Filter streams that are outdated and not included in the MPD anymore if (streams.length &gt; 0) { streams = streams.filter((stream) =&gt; { const isStillIncluded = streamsInfo.filter((sInfo) =&gt; { return sInfo.id === stream.getId(); }).length &gt; 0; const shouldKeepStream = isStillIncluded || stream.getId() === activeStream.getId(); if (!shouldKeepStream) { logger.debug(`Removing stream ${stream.getId()}`); } return shouldKeepStream; }); } for (let i = 0, ln = streamsInfo.length; i &lt; ln; i++) { // If the Stream object does not exist we probably loaded the manifest the first time or it was // introduced in the updated manifest, so we need to create a new Stream and perform all the initialization operations const streamInfo = streamsInfo[i]; let stream = getComposedStream(streamInfo); if (!stream) { stream = Stream(context).create({ manifestModel: manifestModel, mediaPlayerModel: mediaPlayerModel, dashMetrics: dashMetrics, manifestUpdater: manifestUpdater, adapter: adapter, timelineConverter: timelineConverter, capabilities: capabilities, errHandler: errHandler, baseURLController: baseURLController, abrController: abrController, playbackController: playbackController, eventController: eventController, mediaController: mediaController, textController: textController, videoModel: videoModel, settings: settings }); streams.push(stream); stream.initialize(streamInfo, protectionController); } else { stream.updateData(streamInfo); } dashMetrics.addManifestUpdateStreamInfo(streamInfo); } if (!activeStream) { if (adapter.getIsDynamic() &amp;&amp; streams.length) { // Compute and set live delay const manifestInfo = streamsInfo[0].manifestInfo; const fragmentDuration = getFragmentDurationForLiveDelayCalculation(streamsInfo, manifestInfo); playbackController.computeAndSetLiveDelay(fragmentDuration, manifestInfo.DVRWindowSize, manifestInfo.minBufferTime); } // we need to figure out what the correct starting period is let initialStream = null; const startTimeFromUri = playbackController.getStartTimeFromUriParameters(streamsInfo[0].start, adapter.getIsDynamic()); initialStream = getStreamForTime(startTimeFromUri); // For multiperiod streams we should avoid a switch of streams after the seek to the live edge. So we do a calculation of the expected seek time to find the right stream object. if (!initialStream &amp;&amp; adapter.getIsDynamic() &amp;&amp; streams.length) { logger.debug('Dynamic stream: Trying to find the correct starting period'); initialStream = getInitialStream(); } const startStream = initialStream !== null ? initialStream : streams[0]; switchStream(startStream, null, NaN); startPlaybackEndedTimerInterval(); startCheckIfPrebufferingCanStartInterval(); } eventBus.trigger(Events.STREAMS_COMPOSED); } catch (e) { errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, e.message + 'nostreamscomposed', manifestModel.getValue())); hasInitialisationError = true; reset(); } } function getInitialStream() { try { const liveEdge = timelineConverter.calcPresentationTimeFromWallTime(new Date(), adapter.getRegularPeriods()[0]); const targetDelay = playbackController.getLiveDelay(); const targetTime = liveEdge - targetDelay; return getStreamForTime(targetTime); } catch (e) { return null; } } function getFragmentDurationForLiveDelayCalculation(streamInfos, manifestInfo) { try { let fragmentDuration = NaN; // We use the maxFragmentDuration attribute if present if (manifestInfo &amp;&amp; !isNaN(manifestInfo.maxFragmentDuration) &amp;&amp; isFinite(manifestInfo.maxFragmentDuration)) { return manifestInfo.maxFragmentDuration; } // For single period manifests we can iterate over all AS and use the maximum segment length if (streamInfos &amp;&amp; streamInfos.length === 1) { const streamInfo = streamInfos[0]; const mediaTypes = [Constants.VIDEO, Constants.AUDIO, Constants.FRAGMENTED_TEXT]; const fragmentDurations = mediaTypes .reduce((acc, mediaType) =&gt; { const mediaInfo = adapter.getMediaInfoForType(streamInfo, mediaType); if (mediaInfo) { acc.push(mediaInfo); } return acc; }, []) .reduce((acc, mediaInfo) =&gt; { const voRepresentations = adapter.getVoRepresentations(mediaInfo); if (voRepresentations &amp;&amp; voRepresentations.length &gt; 0) { voRepresentations.forEach((voRepresentation) =&gt; { if (voRepresentation) { acc.push(voRepresentation); } }); } return acc; }, []) .reduce((acc, voRepresentation) =&gt; { const representation = adapter.convertDataToRepresentationInfo(voRepresentation); if (representation &amp;&amp; representation.fragmentDuration &amp;&amp; !isNaN(representation.fragmentDuration)) { acc.push(representation.fragmentDuration); } return acc; }, []); fragmentDuration = Math.max(...fragmentDurations); } return isFinite(fragmentDuration) ? fragmentDuration : NaN; } catch (e) { return NaN; } } function onTimeSyncCompleted( /*e*/) { const manifest = manifestModel.getValue(); //TODO check if we can move this to initialize?? if (protectionController) { eventBus.trigger(Events.PROTECTION_CREATED, { controller: protectionController, manifest: manifest }); protectionController.setMediaElement(videoModel.getElement()); if (protectionData) { protectionController.setProtectionData(protectionData); } } composeStreams(); } function onManifestUpdated(e) { if (!e.error) { //Since streams are not composed yet , need to manually look up useCalculatedLiveEdgeTime to detect if stream //is SegmentTimeline to avoid using time source const manifest = e.manifest; adapter.updatePeriods(manifest); let manifestUTCTimingSources = adapter.getUTCTimingSources(); let allUTCTimingSources = (!adapter.getIsDynamic()) ? manifestUTCTimingSources : manifestUTCTimingSources.concat(mediaPlayerModel.getUTCTimingSources()); const isHTTPS = urlUtils.isHTTPS(e.manifest.url); //If https is detected on manifest then lets apply that protocol to only the default time source(s). In the future we may find the need to apply this to more then just default so left code at this level instead of in MediaPlayer. allUTCTimingSources.forEach(function (item) { if (item.value.replace(/.*?:\\/\\//g, '') === mediaPlayerModel.getDefaultUtcTimingSource().value.replace(/.*?:\\/\\//g, '')) { item.value = item.value.replace(isHTTPS ? new RegExp(/^(http:)?\\/\\//i) : new RegExp(/^(https:)?\\/\\//i), isHTTPS ? 'https://' : 'http://'); logger.debug('Matching default timing source protocol to manifest protocol: ', item.value); } }); baseURLController.initialize(manifest); timeSyncController.setConfig({ dashMetrics: dashMetrics, baseURLController: baseURLController }); timeSyncController.initialize(allUTCTimingSources, settings.get().streaming.useManifestDateHeaderTimeSource); } else { hasInitialisationError = true; reset(); } } function hasVideoTrack() { return activeStream ? activeStream.getHasVideoTrack() : false; } function hasAudioTrack() { return activeStream ? activeStream.getHasAudioTrack() : false; } function flushPlaylistMetrics(reason, time) { time = time || new Date(); getActiveStreamProcessors().forEach(p =&gt; { p.finalisePlayList(time, reason); }); dashMetrics.addPlayList(); } function createPlaylistMetrics(startReason) { dashMetrics.createPlaylistMetrics(playbackController.getTime() * 1000, startReason); } function onPlaybackError(e) { if (!e.error) return; let msg = ''; switch (e.error.code) { case 1: msg = 'MEDIA_ERR_ABORTED'; break; case 2: msg = 'MEDIA_ERR_NETWORK'; break; case 3: msg = 'MEDIA_ERR_DECODE'; break; case 4: msg = 'MEDIA_ERR_SRC_NOT_SUPPORTED'; break; case 5: msg = 'MEDIA_ERR_ENCRYPTED'; break; default: msg = 'UNKNOWN'; break; } hasMediaError = true; if (e.error.message) { msg += ' (' + e.error.message + ')'; } if (e.error.msExtendedCode) { msg += ' (0x' + (e.error.msExtendedCode &gt;&gt;&gt; 0).toString(16).toUpperCase() + ')'; } logger.fatal('Video Element Error: ' + msg); if (e.error) { logger.fatal(e.error); } errHandler.error(new DashJSError(e.error.code, msg)); reset(); } function getActiveStreamInfo() { return activeStream ? activeStream.getStreamInfo() : null; } function getIsStreamSwitchInProgress() { return isStreamSwitchingInProgress; } function getHasMediaOrIntialisationError() { return hasMediaError || hasInitialisationError; } function getStreamById(id) { return streams.filter(function (item) { return item.getId() === id; })[0]; } function checkConfig() { if (!manifestLoader || !manifestLoader.hasOwnProperty('load') || !timelineConverter || !timelineConverter.hasOwnProperty('initialize') || !timelineConverter.hasOwnProperty('reset') || !timelineConverter.hasOwnProperty('getClientTimeOffset') || !manifestModel || !errHandler || !dashMetrics || !playbackController) { throw new Error(Constants.MISSING_CONFIG_ERROR); } } function checkInitialize() { if (!manifestUpdater || !manifestUpdater.hasOwnProperty('setManifest')) { throw new Error('initialize function has to be called previously'); } } function load(url) { checkConfig(); manifestLoader.load(url); } function loadWithManifest(manifest) { checkInitialize(); manifestUpdater.setManifest(manifest); } function onManifestValidityChanged(e) { if (!isNaN(e.newDuration)) { setMediaDuration(e.newDuration); } } function setConfig(config) { if (!config) return; if (config.capabilities) { capabilities = config.capabilities; } if (config.manifestLoader) { manifestLoader = config.manifestLoader; } if (config.manifestModel) { manifestModel = config.manifestModel; } if (config.mediaPlayerModel) { mediaPlayerModel = config.mediaPlayerModel; } if (config.protectionController) { protectionController = config.protectionController; } if (config.adapter) { adapter = config.adapter; } if (config.dashMetrics) { dashMetrics = config.dashMetrics; } if (config.errHandler) { errHandler = config.errHandler; } if (config.timelineConverter) { timelineConverter = config.timelineConverter; } if (config.videoModel) { videoModel = config.videoModel; } if (config.playbackController) { playbackController = config.playbackController; } if (config.abrController) { abrController = config.abrController; } if (config.mediaController) { mediaController = config.mediaController; } if (config.textController) { textController = config.textController; } if (config.settings) { settings = config.settings; } if (config.baseURLController) { baseURLController = config.baseURLController; } } function setProtectionData(protData) { protectionData = protData; } function resetInitialSettings() { streams = []; protectionController = null; isStreamSwitchingInProgress = false; activeStream = null; hasMediaError = false; hasInitialisationError = false; initialPlayback = true; isPaused = false; autoPlay = true; playbackEndedTimerInterval = null; isPeriodSwitchInProgress = false; prebufferingCanStartInterval = null; preBufferingCheckInProgress = false; preloadingStreams = []; } function reset() { checkConfig(); timeSyncController.reset(); flushPlaylistMetrics( hasMediaError || hasInitialisationError ? PlayListTrace.FAILURE_STOP_REASON : PlayListTrace.USER_REQUEST_STOP_REASON ); for (let i = 0, ln = streams ? streams.length : 0; i &lt; ln; i++) { const stream = streams[i]; stream.reset(hasMediaError); } unRegisterEvents(); baseURLController.reset(); manifestUpdater.reset(); eventController.reset(); dashMetrics.clearAllCurrentMetrics(); manifestModel.setValue(null); manifestLoader.reset(); timelineConverter.reset(); initCache.reset(); if (mediaSource) { mediaSourceController.detachMediaSource(videoModel); mediaSource = null; } videoModel = null; if (protectionController) { protectionController.setMediaElement(null); protectionController = null; protectionData = null; if (manifestModel.getValue()) { eventBus.trigger(Events.PROTECTION_DESTROYED, { data: manifestModel.getValue().url }); } } stopPlaybackEndedTimerInterval(); stopCheckIfPrebufferingCanStartInterval(); eventBus.trigger(Events.STREAM_TEARDOWN_COMPLETE); resetInitialSettings(); } function onMetricAdded(e) { if (e.metric === MetricsConstants.DVR_INFO) { //Match media type? How can DVR window be different for media types? //Should we normalize and union the two? const targetMediaType = hasAudioTrack() ? Constants.AUDIO : Constants.VIDEO; if (e.mediaType === targetMediaType) { mediaSourceController.setSeekable(mediaSource, e.value.range.start, e.value.range.end); } } } function getStreams() { return streams; } instance = { initialize, getActiveStreamInfo, hasVideoTrack, hasAudioTrack, switchToVideoElement, getStreamById, getStreamForTime, getTimeRelativeToStreamId, load, loadWithManifest, getActiveStreamProcessors, setConfig, setProtectionData, getIsStreamSwitchInProgress, getHasMediaOrIntialisationError, hasStreamFinishedBuffering, getStreams, getActiveStream, reset }; setup(); return instance; } StreamController.__dashjs_factory_name = 'StreamController'; export default FactoryMaker.getSingletonFactory(StreamController); × Search results Close "},"streaming_StreamProcessor.js.html":{"id":"streaming_StreamProcessor.js.html","title":"Source: streaming/StreamProcessor.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/StreamProcessor.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from './constants/Constants'; import DashConstants from '../dash/constants/DashConstants'; import MetricsConstants from './constants/MetricsConstants'; import FragmentModel from './models/FragmentModel'; import BufferController from './controllers/BufferController'; import TextBufferController from './text/TextBufferController'; import ScheduleController from './controllers/ScheduleController'; import RepresentationController from '../dash/controllers/RepresentationController'; import LiveEdgeFinder from './utils/LiveEdgeFinder'; import FactoryMaker from '../core/FactoryMaker'; import {checkInteger} from './utils/SupervisorTools'; import EventBus from '../core/EventBus'; import Events from '../core/events/Events'; import DashHandler from '../dash/DashHandler'; import Errors from '../core/errors/Errors'; import DashJSError from './vo/DashJSError'; import Debug from '../core/Debug'; import RequestModifier from './utils/RequestModifier'; import URLUtils from '../streaming/utils/URLUtils'; import BoxParser from './utils/BoxParser'; import FragmentRequest from './vo/FragmentRequest'; import {PlayListTrace} from './vo/metrics/PlayList'; function StreamProcessor(config) { config = config || {}; let context = this.context; let eventBus = EventBus(context).getInstance(); let streamInfo = config.streamInfo; let type = config.type; let errHandler = config.errHandler; let mimeType = config.mimeType; let timelineConverter = config.timelineConverter; let adapter = config.adapter; let manifestModel = config.manifestModel; let mediaPlayerModel = config.mediaPlayerModel; let fragmentModel = config.fragmentModel; let abrController = config.abrController; let playbackController = config.playbackController; let mediaController = config.mediaController; let textController = config.textController; let dashMetrics = config.dashMetrics; let settings = config.settings; let boxParser = config.boxParser; let instance, logger, isDynamic, mediaInfo, mediaInfoArr, bufferController, scheduleController, representationController, liveEdgeFinder, indexHandler, bufferingTime, bufferPruned; function setup() { logger = Debug(context).getInstance().getLogger(instance); resetInitialSettings(); eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance, EventBus.EVENT_PRIORITY_HIGH); // High priority to be notified before Stream eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance); eventBus.on(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance); eventBus.on(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance); eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance); eventBus.on(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance); eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance); eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, instance); eventBus.on(Events.SEEK_TARGET, onSeekTarget, instance); } function initialize(mediaSource, hasVideoTrack) { indexHandler = DashHandler(context).create({ streamInfo: streamInfo, type: type, timelineConverter: timelineConverter, dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, baseURLController: config.baseURLController, errHandler: errHandler, settings: settings, boxParser: boxParser, events: Events, eventBus: eventBus, errors: Errors, debug: Debug(context).getInstance(), requestModifier: RequestModifier(context).getInstance(), dashConstants: DashConstants, constants: Constants, urlUtils: URLUtils(context).getInstance() }); // Create live edge finder for dynamic streams isDynamic = streamInfo.manifestInfo.isDynamic; if (isDynamic) { liveEdgeFinder = LiveEdgeFinder(context).create({ timelineConverter: timelineConverter }); } // Create/initialize controllers indexHandler.initialize(isDynamic); abrController.registerStreamType(type, instance); representationController = RepresentationController(context).create({ streamId: streamInfo.id, type: type, abrController: abrController, dashMetrics: dashMetrics, playbackController: playbackController, timelineConverter: timelineConverter, dashConstants: DashConstants, events: Events, eventBus: eventBus, errors: Errors }); bufferController = createBufferControllerForType(type); if (bufferController) { bufferController.initialize(mediaSource); } scheduleController = ScheduleController(context).create({ streamId: streamInfo.id, type: type, mimeType: mimeType, adapter: adapter, dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, fragmentModel: fragmentModel, abrController: abrController, playbackController: playbackController, textController: textController, mediaController: mediaController, bufferController: bufferController, settings: settings }); scheduleController.initialize(hasVideoTrack); bufferingTime = 0; bufferPruned = false; } function resetInitialSettings() { mediaInfoArr = []; mediaInfo = null; bufferingTime = 0; } function reset(errored, keepBuffers) { if (indexHandler) { indexHandler.reset(); } if (bufferController) { bufferController.reset(errored, keepBuffers); bufferController = null; } if (scheduleController) { scheduleController.reset(); scheduleController = null; } if (representationController) { representationController.reset(); representationController = null; } if (liveEdgeFinder) { liveEdgeFinder.reset(); liveEdgeFinder = null; } if (abrController) { abrController.unRegisterStreamType(type); } eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance); eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance); eventBus.off(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance); eventBus.off(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance); eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance); eventBus.off(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance); eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance); eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, instance); eventBus.off(Events.SEEK_TARGET, onSeekTarget, instance); resetInitialSettings(); type = null; streamInfo = null; } function isUpdating() { return representationController ? representationController.isUpdating() : false; } function onDataUpdateCompleted(e) { if (e.sender.getType() !== getType() || e.sender.getStreamId() !== streamInfo.id) return; if (!e.error) { // Update representation if no error scheduleController.setCurrentRepresentation(adapter.convertDataToRepresentationInfo(e.currentRepresentation)); } if (!e.error || e.error.code === Errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE) { // Update has been postponed, update nevertheless DVR info const activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id; if (activeStreamId === streamInfo.id) { addDVRMetric(); } } } function onQualityChanged(e) { if (type !== e.mediaType || streamInfo.id !== e.streamInfo.id) return; let representationInfo = getRepresentationInfo(e.newQuality); scheduleController.setCurrentRepresentation(representationInfo); dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON); dashMetrics.createPlaylistTraceMetrics(representationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate()); } function onBufferLevelUpdated(e) { if (e.streamId !== streamInfo.id || e.mediaType !== type) return; dashMetrics.addBufferLevel(type, new Date(), e.bufferLevel * 1000); const activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id; if (!manifestModel.getValue().doNotUpdateDVRWindowOnBufferUpdated &amp;&amp; streamInfo.id === activeStreamId) { addDVRMetric(); } } function onBufferLevelStateChanged(e) { if (e.streamId !== streamInfo.id || e.mediaType !== type) return; dashMetrics.addBufferState(type, e.state, scheduleController.getBufferTarget()); if (e.state === MetricsConstants.BUFFER_EMPTY &amp;&amp; !playbackController.isSeeking()) { // logger.info('Buffer is empty! Stalling!'); dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON); } } function onBufferCleared(e) { if (e.streamId !== streamInfo.id || e.mediaType !== type) return; // Remove executed requests not buffered anymore fragmentModel.syncExecutedRequestsWithBufferedRange( bufferController.getBuffer().getAllBufferRanges(), streamInfo.duration); // If buffer removed ahead current time (QuotaExceededError or automatic buffer pruning) then adjust current index handler time if (e.from &gt; playbackController.getTime()) { bufferingTime = e.from; bufferPruned = true; } } function addDVRMetric() { const manifestInfo = streamInfo.manifestInfo; const isDynamic = manifestInfo.isDynamic; const range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic); dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range); } function getType() { return type; } function getRepresentationController() { return representationController; } function getBuffer() { return bufferController ? bufferController.getBuffer() : null; } function setBuffer(buffer) { bufferController.setBuffer(buffer); } function getBufferController() { return bufferController; } function getFragmentModel() { return fragmentModel; } function updateStreamInfo(newStreamInfo) { streamInfo = newStreamInfo; if (settings.get().streaming.useAppendWindow) { bufferController.updateAppendWindow(); } } function getStreamInfo() { return streamInfo; } function selectMediaInfo(newMediaInfo) { if (newMediaInfo !== mediaInfo &amp;&amp; (!newMediaInfo || !mediaInfo || (newMediaInfo.type === mediaInfo.type))) { mediaInfo = newMediaInfo; } const newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo); const voRepresentations = adapter.getVoRepresentations(mediaInfo); if (representationController) { const realAdaptation = representationController.getData(); const maxQuality = abrController.getTopQualityIndexFor(type, streamInfo.id); const minIdx = abrController.getMinAllowedIndexFor(type); let quality, averageThroughput; let bitrate = null; if ((realAdaptation === null || (realAdaptation.id != newRealAdaptation.id)) &amp;&amp; type !== Constants.FRAGMENTED_TEXT) { averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type); bitrate = averageThroughput || abrController.getInitialBitrateFor(type); quality = abrController.getQualityForBitrate(mediaInfo, bitrate); } else { quality = abrController.getQualityFor(type); } if (minIdx !== undefined &amp;&amp; quality &lt; minIdx) { quality = minIdx; } if (quality &gt; maxQuality) { quality = maxQuality; } indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null); representationController.updateData(newRealAdaptation, voRepresentations, type, quality); } } function addMediaInfo(newMediaInfo, selectNewMediaInfo) { if (mediaInfoArr.indexOf(newMediaInfo) === -1) { mediaInfoArr.push(newMediaInfo); } if (selectNewMediaInfo) { this.selectMediaInfo(newMediaInfo); } } function getMediaInfoArr() { return mediaInfoArr; } function getMediaInfo() { return mediaInfo; } function getMediaSource() { return bufferController.getMediaSource(); } function setMediaSource(mediaSource) { bufferController.setMediaSource(mediaSource, getMediaInfoArr()); } function dischargePreBuffer() { bufferController.dischargePreBuffer(); } function getScheduleController() { return scheduleController; } /** * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality. * Otherwise, this function will return the current voRepresentation used by the representationController. * @param {number} quality - quality index of the voRepresentaion expected. */ function getRepresentationInfo(quality) { let voRepresentation; if (quality !== undefined) { checkInteger(quality); voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null; } else { voRepresentation = representationController ? representationController.getCurrentRepresentation() : null; } return adapter.convertDataToRepresentationInfo(voRepresentation); } function isBufferingCompleted() { return bufferController ? bufferController.getIsBufferingCompleted() : false; } function getBufferLevel() { return bufferController ? bufferController.getBufferLevel() : 0; } function onInitFragmentNeeded(e) { if (!e.sender || e.mediaType !== type || e.streamId !== streamInfo.id) return; if (adapter.getIsTextTrack(mimeType) &amp;&amp; !textController.isTextEnabled()) return; if (bufferController &amp;&amp; e.representationId) { if (!bufferController.appendInitSegment(e.representationId)) { // Init segment not in cache, send new request const request = indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation()) : null; scheduleController.processInitRequest(request); } } } function onMediaFragmentNeeded(e) { if (!e.sender || e.mediaType !== type || e.streamId !== streamInfo.id) { return; } let request; // Don't schedule next fragments while pruning to avoid buffer inconsistencies if (!bufferController.getIsPruningInProgress()) { request = findNextRequest(e.seekTarget, e.replacement); if (request) { scheduleController.setSeekTarget(NaN); if (!e.replacement) { if (!isNaN(request.startTime + request.duration)) { bufferingTime = request.startTime + request.duration; } request.delayLoadingTime = new Date().getTime() + scheduleController.getTimeToLoadDelay(); scheduleController.setTimeToLoadDelay(0); } } } scheduleController.processMediaRequest(request); } function findNextRequest(seekTarget, requestToReplace) { const representationInfo = getRepresentationInfo(); const hasSeekTarget = !isNaN(seekTarget); const currentTime = playbackController.getNormalizedTime(); let time = hasSeekTarget ? seekTarget : bufferingTime; let bufferIsDivided = false; let request; if (isNaN(time) || (getType() === Constants.FRAGMENTED_TEXT &amp;&amp; !textController.isTextEnabled())) { return null; } /** * This is critical for IE/Safari/EDGE * */ if (bufferController) { let range = bufferController.getRangeAt(time); const playingRange = bufferController.getRangeAt(currentTime); if ((range !== null || playingRange !== null) &amp;&amp; !hasSeekTarget) { if (!range || (playingRange &amp;&amp; playingRange.start != range.start &amp;&amp; playingRange.end != range.end)) { const hasDiscontinuities = bufferController.getBuffer().hasDiscontinuitiesAfter(currentTime); if (hasDiscontinuities &amp;&amp; getType() !== Constants.FRAGMENTED_TEXT) { fragmentModel.removeExecutedRequestsAfterTime(playingRange.end); bufferIsDivided = true; } } } } if (requestToReplace) { time = requestToReplace.startTime + (requestToReplace.duration / 2); request = getFragmentRequest(representationInfo, time, { timeThreshold: 0, ignoreIsFinished: true }); } else { // Use time just whenever is strictly needed const useTime = hasSeekTarget || bufferPruned || bufferIsDivided; request = getFragmentRequest(representationInfo, useTime ? time : undefined, { keepIdx: !useTime }); bufferPruned = false; // Then, check if this request was downloaded or not while (request &amp;&amp; request.action !== FragmentRequest.ACTION_COMPLETE &amp;&amp; fragmentModel.isFragmentLoaded(request)) { // loop until we found not loaded fragment, or no fragment request = getFragmentRequest(representationInfo); } } return request; } function onMediaFragmentLoaded(e) { const chunk = e.chunk; if (chunk.streamId !== streamInfo.id || chunk.mediaInfo.type != type) return; const bytes = chunk.bytes; const quality = chunk.quality; const currentRepresentation = getRepresentationInfo(quality); const voRepresentation = representationController &amp;&amp; currentRepresentation ? representationController.getRepresentationForQuality(currentRepresentation.quality) : null; const eventStreamMedia = adapter.getEventsFor(currentRepresentation.mediaInfo); const eventStreamTrack = adapter.getEventsFor(currentRepresentation, voRepresentation); if (eventStreamMedia &amp;&amp; eventStreamMedia.length &gt; 0 || eventStreamTrack &amp;&amp; eventStreamTrack.length &gt; 0) { const request = fragmentModel.getRequests({ state: FragmentModel.FRAGMENT_MODEL_EXECUTED, quality: quality, index: chunk.index })[0]; const events = handleInbandEvents(bytes, request, eventStreamMedia, eventStreamTrack); eventBus.trigger(Events.INBAND_EVENTS, {sender: instance, events: events}); } } function handleInbandEvents(data, request, mediaInbandEvents, trackInbandEvents) { const fragmentStartTime = Math.max(!request || isNaN(request.startTime) ? 0 : request.startTime, 0); const eventStreams = []; const events = []; /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */ const inbandEvents = mediaInbandEvents.concat(trackInbandEvents); for (let i = 0, ln = inbandEvents.length; i &lt; ln; i++) { eventStreams[inbandEvents[i].schemeIdUri + '/' + inbandEvents[i].value] = inbandEvents[i]; } const isoFile = BoxParser(context).getInstance().parse(data); const eventBoxes = isoFile.getBoxes('emsg'); for (let i = 0, ln = eventBoxes.length; i &lt; ln; i++) { const event = adapter.getEvent(eventBoxes[i], eventStreams, fragmentStartTime); if (event) { events.push(event); } } return events; } function createBuffer(previousBuffers) { return (getBuffer() || bufferController ? bufferController.createBuffer(mediaInfoArr, previousBuffers) : null); } function switchTrackAsked() { scheduleController.switchTrackAsked(); } function createBufferControllerForType(type) { let controller = null; if (!type) { errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + 'not properly defined')); return null; } if (type === Constants.VIDEO || type === Constants.AUDIO) { controller = BufferController(context).create({ streamInfo: streamInfo, type: type, mediaPlayerModel: mediaPlayerModel, manifestModel: manifestModel, fragmentModel: fragmentModel, errHandler: errHandler, mediaController: mediaController, representationController: representationController, adapter: adapter, textController: textController, abrController: abrController, playbackController: playbackController, settings: settings }); } else { controller = TextBufferController(context).create({ streamInfo: streamInfo, type: type, mimeType: mimeType, mediaPlayerModel: mediaPlayerModel, manifestModel: manifestModel, fragmentModel: fragmentModel, errHandler: errHandler, mediaController: mediaController, representationController: representationController, adapter: adapter, textController: textController, abrController: abrController, playbackController: playbackController, settings: settings }); } return controller; } function getLiveStartTime() { if (!isDynamic) return NaN; if (!liveEdgeFinder) return NaN; let liveStartTime = NaN; const currentRepresentationInfo = getRepresentationInfo(); const liveEdge = liveEdgeFinder.getLiveEdge(currentRepresentationInfo); if (isNaN(liveEdge)) { return NaN; } const request = findRequestForLiveEdge(liveEdge, currentRepresentationInfo); if (request) { // When low latency mode is selected but browser doesn't support fetch // start at the beginning of the segment to avoid consuming the whole buffer if (settings.get().streaming.lowLatencyEnabled) { liveStartTime = request.duration &lt; mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay(); } else { liveStartTime = request.startTime; } } return liveStartTime; } function findRequestForLiveEdge(liveEdge, currentRepresentationInfo) { try { let request = null; let liveDelay = playbackController.getLiveDelay(); const dvrWindowSize = !isNaN(streamInfo.manifestInfo.DVRWindowSize) ? streamInfo.manifestInfo.DVRWindowSize : liveDelay; const dvrWindowSafetyMargin = 0.1 * dvrWindowSize; let startTime; // Make sure that we have at least a valid request for the end of the DVR window, otherwise we might try forever if (!isFinite(dvrWindowSize) || getFragmentRequest(currentRepresentationInfo, liveEdge - dvrWindowSize + dvrWindowSafetyMargin, { ignoreIsFinished: true })) { // Try to find a request as close as possible to the targeted live edge while (!request &amp;&amp; liveDelay &lt;= dvrWindowSize) { startTime = liveEdge - liveDelay; request = getFragmentRequest(currentRepresentationInfo, startTime, { ignoreIsFinished: true }); if (!request) { liveDelay += 1; // Increase by one second for each iteration } } } if (request) { playbackController.setLiveDelay(liveDelay, true); } logger.debug('live edge: ' + liveEdge + ', live delay: ' + liveDelay + ', live target: ' + startTime); return request; } catch (e) { return null; } } function onSeekTarget(e) { if ((e.mediaType &amp;&amp; e.mediaType !== type) || e.streamId !== streamInfo.id) return; bufferingTime = e.time; scheduleController.setSeekTarget(e.time); } function setBufferingTime(value) { bufferingTime = value; } function resetIndexHandler() { if (indexHandler) { indexHandler.resetIndex(); } } function getInitRequest(quality) { checkInteger(quality); const representation = representationController ? representationController.getRepresentationForQuality(quality) : null; return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null; } function getFragmentRequest(representationInfo, time, options) { let fragRequest = null; if (indexHandler) { const representation = representationController &amp;&amp; representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null; // if time and options are undefined, it means the next segment is requested // otherwise, the segment at this specific time is requested. if (time !== undefined &amp;&amp; options !== undefined) { fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options); } else { fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation); } } return fragRequest; } function finalisePlayList(time, reason) { dashMetrics.pushPlayListTraceMetrics(time, reason); } instance = { initialize: initialize, isUpdating: isUpdating, getType: getType, getBufferController: getBufferController, getFragmentModel: getFragmentModel, getScheduleController: getScheduleController, getRepresentationController: getRepresentationController, getRepresentationInfo: getRepresentationInfo, getBufferLevel: getBufferLevel, isBufferingCompleted: isBufferingCompleted, createBuffer: createBuffer, updateStreamInfo: updateStreamInfo, getStreamInfo: getStreamInfo, selectMediaInfo: selectMediaInfo, addMediaInfo: addMediaInfo, getLiveStartTime: getLiveStartTime, switchTrackAsked: switchTrackAsked, getMediaInfoArr: getMediaInfoArr, getMediaInfo: getMediaInfo, getMediaSource: getMediaSource, setMediaSource: setMediaSource, dischargePreBuffer: dischargePreBuffer, getBuffer: getBuffer, setBuffer: setBuffer, setBufferingTime: setBufferingTime, resetIndexHandler: resetIndexHandler, getInitRequest: getInitRequest, getFragmentRequest: getFragmentRequest, finalisePlayList: finalisePlayList, reset: reset }; setup(); return instance; } StreamProcessor.__dashjs_factory_name = 'StreamProcessor'; export default FactoryMaker.getClassFactory(StreamProcessor); × Search results Close "},"streaming_vo_metrics_TCPConnection.js.html":{"id":"streaming_vo_metrics_TCPConnection.js.html","title":"Source: streaming/vo/metrics/TCPConnection.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/vo/metrics/TCPConnection.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class * @ignore */ class TCPConnection { /** * @description This Object holds reference to the current tcp connection */ constructor() { /** * Identifier of the TCP connection on which the HTTP request was sent. * @public */ this.tcpid = null; /** * IP Address of the interface over which the client is receiving the TCP data. * @public */ this.dest = null; /** * Real-Time | The time at which the connection was opened (sending time of the initial SYN or connect socket operation). * @public */ this.topen = null; /** * Real-Time | The time at which the connection was closed (sending or reception time of FIN or RST or close socket operation). * @public */ this.tclose = null; /** * Connect time in ms (time from sending the initial SYN to receiving the ACK or completion of the connect socket operation). * @public */ this.tconnect = null; } } export default TCPConnection; × Search results Close "},"streaming_text_TextSourceBuffer.js.html":{"id":"streaming_text_TextSourceBuffer.js.html","title":"Source: streaming/text/TextSourceBuffer.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/text/TextSourceBuffer.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import { HTTPRequest } from '../vo/metrics/HTTPRequest'; import TextTrackInfo from '../vo/TextTrackInfo'; import BoxParser from '../utils/BoxParser'; import CustomTimeRanges from '../utils/CustomTimeRanges'; import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; import TextTracks from './TextTracks'; import EmbeddedTextHtmlRender from './EmbeddedTextHtmlRender'; import ISOBoxer from 'codem-isoboxer'; import cea608parser from '../../../externals/cea608-parser'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import DashJSError from '../vo/DashJSError'; import Errors from '../../core/errors/Errors'; function TextSourceBuffer() { const context = this.context; const eventBus = EventBus(context).getInstance(); let embeddedInitialized = false; let instance, logger, boxParser, errHandler, adapter, manifestModel, mediaController, parser, vttParser, ttmlParser, mediaInfos, textTracks, fragmentedFragmentModel, initializationSegmentReceived, timescale, fragmentedTracks, videoModel, streamController, firstFragmentedSubtitleStart, currFragmentedTrackIdx, embeddedTracks, embeddedTimescale, embeddedLastSequenceNumber, embeddedCea608FieldParsers, embeddedTextHtmlRender, mseTimeOffset; function setup() { logger = Debug(context).getInstance().getLogger(instance); resetInitialSettings(); } function resetFragmented () { fragmentedFragmentModel = null; timescale = NaN; fragmentedTracks = []; firstFragmentedSubtitleStart = null; initializationSegmentReceived = false; } function resetInitialSettings() { resetFragmented(); mediaInfos = []; parser = null; } function initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel) { if (!embeddedInitialized) { initEmbedded(); } textTracks.setConfig({ videoModel: videoModel }); textTracks.initialize(); if (!boxParser) { boxParser = BoxParser(context).getInstance(); } addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel); } function addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel) { const isFragmented = !adapter.getIsTextTrack(mimeType); mediaInfos = mediaInfos.concat(mediaInfoArr); if (isFragmented) { fragmentedFragmentModel = fragmentModel; instance.buffered = CustomTimeRanges(context).create(); fragmentedTracks = mediaController.getTracksFor(Constants.FRAGMENTED_TEXT, streamInfo); const currFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamInfo); for (let i = 0; i &lt; fragmentedTracks.length; i++) { if (fragmentedTracks[i] === currFragTrack) { setCurrentFragmentedTrackIdx(i); break; } } } for (let i = 0; i &lt; mediaInfos.length; i++) { createTextTrackFromMediaInfo(null, mediaInfos[i]); } } function abort() { textTracks.deleteAllTextTracks(); resetFragmented(); boxParser = null; mediaInfos = []; } function reset() { resetInitialSettings(); streamController = null; videoModel = null; textTracks = null; } function onVideoChunkReceived(e) { const chunk = e.chunk; if (chunk.mediaInfo.embeddedCaptions) { append(chunk.bytes, chunk); } } function initEmbedded() { embeddedTracks = []; textTracks = TextTracks(context).getInstance(); textTracks.setConfig({ videoModel: videoModel }); textTracks.initialize(); boxParser = BoxParser(context).getInstance(); currFragmentedTrackIdx = null; embeddedTimescale = 0; embeddedCea608FieldParsers = []; embeddedLastSequenceNumber = null; embeddedInitialized = true; embeddedTextHtmlRender = EmbeddedTextHtmlRender(context).getInstance(); const streamProcessors = streamController.getActiveStreamProcessors(); for (const i in streamProcessors) { if (streamProcessors[i].getType() === 'video') { mseTimeOffset = streamProcessors[i].getRepresentationInfo().MSETimeOffset; break; } } eventBus.on(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this); eventBus.on(Events.BUFFER_CLEARED, onVideoBufferCleared, this); } function resetEmbedded() { eventBus.off(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this); eventBus.off(Events.BUFFER_CLEARED, onVideoBufferCleared, this); if (textTracks) { textTracks.deleteAllTextTracks(); } embeddedInitialized = false; embeddedTracks = []; embeddedCea608FieldParsers = [null, null]; embeddedLastSequenceNumber = null; } function addEmbeddedTrack(mediaInfo) { if (!embeddedInitialized) { initEmbedded(); } if (mediaInfo) { if (mediaInfo.id === Constants.CC1 || mediaInfo.id === Constants.CC3) { for (let i = 0; i &lt; embeddedTracks.length; i++) { if (embeddedTracks[i].id === mediaInfo.id) { return; } } embeddedTracks.push(mediaInfo); } else { logger.warn('Embedded track ' + mediaInfo.id + ' not supported!'); } } } function setConfig(config) { if (!config) { return; } if (config.errHandler) { errHandler = config.errHandler; } if (config.adapter) { adapter = config.adapter; } if (config.manifestModel) { manifestModel = config.manifestModel; } if (config.mediaController) { mediaController = config.mediaController; } if (config.videoModel) { videoModel = config.videoModel; } if (config.streamController) { streamController = config.streamController; } if (config.textTracks) { textTracks = config.textTracks; } if (config.vttParser) { vttParser = config.vttParser; } if (config.ttmlParser) { ttmlParser = config.ttmlParser; } } function getConfig() { const config = { fragmentModel: fragmentedFragmentModel, fragmentedTracks: fragmentedTracks, videoModel: videoModel }; return config; } function setCurrentFragmentedTrackIdx(idx) { currFragmentedTrackIdx = idx; } function createTextTrackFromMediaInfo(captionData, mediaInfo) { const textTrackInfo = new TextTrackInfo(); const trackKindMap = { subtitle: 'subtitles', caption: 'captions' }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural. const getKind = function () { let kind = (mediaInfo.roles.length &gt; 0) ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption; kind = (kind === trackKindMap.caption || kind === trackKindMap.subtitle) ? kind : trackKindMap.caption; return kind; }; const checkTTML = function () { let ttml = false; if (mediaInfo.codec &amp;&amp; mediaInfo.codec.search(Constants.STPP) &gt;= 0) { ttml = true; } if (mediaInfo.mimeType &amp;&amp; mediaInfo.mimeType.search(Constants.TTML) &gt;= 0) { ttml = true; } return ttml; }; textTrackInfo.captionData = captionData; textTrackInfo.lang = mediaInfo.lang; textTrackInfo.labels = mediaInfo.labels; textTrackInfo.id = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optional parameter, use mediaInfo.index textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest textTrackInfo.isTTML = checkTTML(); textTrackInfo.defaultTrack = getIsDefault(mediaInfo); textTrackInfo.isFragmented = !adapter.getIsTextTrack(mediaInfo.mimeType); textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false; textTrackInfo.kind = getKind(); textTrackInfo.roles = mediaInfo.roles; textTrackInfo.accessibility = mediaInfo.accessibility; const totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length; textTracks.addTextTrack(textTrackInfo, totalNrTracks); } function append(bytes, chunk) { let result, sampleList, i, j, k, samplesInfo, ccContent; const mediaInfo = chunk.mediaInfo; const mediaType = mediaInfo.type; const mimeType = mediaInfo.mimeType; const codecType = mediaInfo.codec || mimeType; if (!codecType) { logger.error('No text type defined'); return; } if (mediaType === Constants.FRAGMENTED_TEXT) { if (!initializationSegmentReceived &amp;&amp; chunk.segmentType === 'InitializationSegment') { initializationSegmentReceived = true; timescale = boxParser.getMediaTimescaleFromMoov(bytes); } else { if (!initializationSegmentReceived) { return; } samplesInfo = boxParser.getSamplesInfo(bytes); sampleList = samplesInfo.sampleList; if (firstFragmentedSubtitleStart === null &amp;&amp; sampleList.length &gt; 0) { firstFragmentedSubtitleStart = sampleList[0].cts - chunk.start * timescale; } if (codecType.search(Constants.STPP) &gt;= 0) { parser = parser !== null ? parser : getParser(codecType); for (i = 0; i &lt; sampleList.length; i++) { const sample = sampleList[i]; const sampleStart = sample.cts; const sampleRelStart = sampleStart - firstFragmentedSubtitleStart; this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale); const dataView = new DataView(bytes, sample.offset, sample.subSizes[0]); ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8); const images = []; let subOffset = sample.offset + sample.subSizes[0]; for (j = 1; j &lt; sample.subSizes.length; j++) { const inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]); const raw = String.fromCharCode.apply(null, inData); images.push(raw); subOffset += sample.subSizes[j]; } try { // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset. const manifest = manifestModel.getValue(); const offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0; result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images); textTracks.addCaptions(currFragmentedTrackIdx, firstFragmentedSubtitleStart / timescale, result); } catch (e) { fragmentedFragmentModel.removeExecutedRequestsBeforeTime(); this.remove(); logger.error('TTML parser error: ' + e.message); } } } else { // WebVTT case const captionArray = []; for (i = 0 ; i &lt; sampleList.length; i++) { const sample = sampleList[i]; sample.cts -= firstFragmentedSubtitleStart; this.buffered.add(sample.cts / timescale, (sample.cts + sample.duration) / timescale); const sampleData = bytes.slice(sample.offset, sample.offset + sample.size); // There are boxes inside the sampleData, so we need a ISOBoxer to get at it. const sampleBoxes = ISOBoxer.parseBuffer(sampleData); for (j = 0 ; j &lt; sampleBoxes.boxes.length; j++) { const box1 = sampleBoxes.boxes[j]; logger.debug('VTT box1: ' + box1.type); if (box1.type === 'vtte') { continue; //Empty box } if (box1.type === 'vttc') { logger.debug('VTT vttc boxes.length = ' + box1.boxes.length); for (k = 0 ; k &lt; box1.boxes.length; k++) { const box2 = box1.boxes[k]; logger.debug('VTT box2: ' + box2.type); if (box2.type === 'payl') { const cue_text = box2.cue_text; logger.debug('VTT cue_text = ' + cue_text); const start_time = sample.cts / timescale; const end_time = (sample.cts + sample.duration) / timescale; captionArray.push({ start: start_time, end: end_time, data: cue_text, styles: {} }); logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text); } } } } } if (captionArray.length &gt; 0) { textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray); } } } } else if (mediaType === Constants.TEXT) { const dataView = new DataView(bytes, 0, bytes.byteLength); ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8); try { result = getParser(codecType).parse(ccContent, 0); textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result); } catch (e) { errHandler.error(new DashJSError(Errors.TIMED_TEXT_ERROR_ID_PARSE_CODE, Errors.TIMED_TEXT_ERROR_MESSAGE_PARSE + e.message, ccContent)); } } else if (mediaType === Constants.VIDEO) { //embedded text if (chunk.segmentType === HTTPRequest.INIT_SEGMENT_TYPE) { if (embeddedTimescale === 0) { embeddedTimescale = boxParser.getMediaTimescaleFromMoov(bytes); for (i = 0; i &lt; embeddedTracks.length; i++) { createTextTrackFromMediaInfo(null, embeddedTracks[i]); } } } else { // MediaSegment if (embeddedTimescale === 0) { logger.warn('CEA-608: No timescale for embeddedTextTrack yet'); return; } const makeCueAdderForIndex = function (self, trackIndex) { function newCue(startTime, endTime, captionScreen) { let captionsArray = null; if (videoModel.getTTMLRenderingDiv()) { captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen); } else { const text = captionScreen.getDisplayText(); captionsArray = [{ start: startTime, end: endTime, data: text, styles: {} }]; } if (captionsArray) { textTracks.addCaptions(trackIndex, 0, captionsArray); } } return newCue; }; samplesInfo = boxParser.getSamplesInfo(bytes); const sequenceNumber = samplesInfo.lastSequenceNumber; if (!embeddedCea608FieldParsers[0] &amp;&amp; !embeddedCea608FieldParsers[1]) { // Time to setup the CEA-608 parsing let field, handler, trackIdx; for (i = 0; i &lt; embeddedTracks.length; i++) { if (embeddedTracks[i].id === Constants.CC1) { field = 0; trackIdx = textTracks.getTrackIdxForId(Constants.CC1); } else if (embeddedTracks[i].id === Constants.CC3) { field = 1; trackIdx = textTracks.getTrackIdxForId(Constants.CC3); } if (trackIdx === -1) { logger.warn('CEA-608: data before track is ready.'); return; } handler = makeCueAdderForIndex(this, trackIdx); embeddedCea608FieldParsers[i] = new cea608parser.Cea608Parser(i + 1, { 'newCue': handler }, null); } } if (embeddedTimescale) { if (embeddedLastSequenceNumber !== null &amp;&amp; sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) { for (i = 0; i &lt; embeddedCea608FieldParsers.length; i++) { if (embeddedCea608FieldParsers[i]) { embeddedCea608FieldParsers[i].reset(); } } } const allCcData = extractCea608Data(bytes, samplesInfo.sampleList); for (let fieldNr = 0; fieldNr &lt; embeddedCea608FieldParsers.length; fieldNr++) { const ccData = allCcData.fields[fieldNr]; const fieldParser = embeddedCea608FieldParsers[fieldNr]; if (fieldParser) { for (i = 0; i &lt; ccData.length; i++) { fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]); } } } embeddedLastSequenceNumber = sequenceNumber; } } } } /** * Extract CEA-608 data from a buffer of data. * @param {ArrayBuffer} data * @param {Array} samples cue information * @returns {Object|null} ccData corresponding to one segment. */ function extractCea608Data(data, samples) { if (samples.length === 0) { return null; } const allCcData = { splits: [], fields: [[], []] }; const raw = new DataView(data); for (let i = 0; i &lt; samples.length; i++) { const sample = samples[i]; const cea608Ranges = cea608parser.findCea608Nalus(raw, sample.offset, sample.size); let lastSampleTime = null; let idx = 0; for (let j = 0; j &lt; cea608Ranges.length; j++) { const ccData = cea608parser.extractCea608DataFromRange(raw, cea608Ranges[j]); for (let k = 0; k &lt; 2; k++) { if (ccData[k].length &gt; 0) { if (sample.cts !== lastSampleTime) { idx = 0; } else { idx += 1; } allCcData.fields[k].push([sample.cts + (mseTimeOffset * embeddedTimescale), ccData[k], idx]); lastSampleTime = sample.cts; } } } } // Sort by sampleTime ascending order // If two packets have the same sampleTime, use them in the order // they were received allCcData.fields.forEach(function sortField(field) { field.sort(function (a, b) { if (a[0] === b[0]) { return a[2] - b[2]; } return a[0] - b[0]; }); }); return allCcData; } function getIsDefault(mediaInfo) { //TODO How to tag default. currently same order as listed in manifest. // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet. let isDefault = false; if (embeddedTracks.length &gt; 1 &amp;&amp; mediaInfo.isEmbedded) { isDefault = (mediaInfo.id &amp;&amp; mediaInfo.id === Constants.CC1); // CC1 if both CC1 and CC3 exist } else if (embeddedTracks.length === 1) { if (mediaInfo.id &amp;&amp; typeof mediaInfo.id === 'string' &amp;&amp; mediaInfo.id.substring(0, 2) === 'CC') { // Either CC1 or CC3 isDefault = true; } } else if (embeddedTracks.length === 0) { isDefault = (mediaInfo.index === mediaInfos[0].index); } return isDefault; } function getParser(codecType) { let parser; if (codecType.search(Constants.VTT) &gt;= 0) { parser = vttParser; } else if (codecType.search(Constants.TTML) &gt;= 0 || codecType.search(Constants.STPP) &gt;= 0) { parser = ttmlParser; } return parser; } function remove(start, end) { //if start and end are not defined, remove all if ((start === undefined) &amp;&amp; (start === end)) { start = this.buffered.start(0); end = this.buffered.end(this.buffered.length - 1); } this.buffered.remove(start, end); } function onVideoBufferCleared(e) { embeddedTracks.forEach(function (track) { const trackIdx = textTracks.getTrackIdxForId(track.id); if (trackIdx &gt;= 0) { textTracks.deleteCuesFromTrackIdx(trackIdx, e.from, e.to); } }); } instance = { initialize: initialize, append: append, abort: abort, addEmbeddedTrack: addEmbeddedTrack, resetEmbedded: resetEmbedded, setConfig: setConfig, getConfig: getConfig, setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx, remove: remove, reset: reset }; setup(); return instance; } TextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer'; export default FactoryMaker.getSingletonFactory(TextSourceBuffer); × Search results Close "},"streaming_utils_TTMLParser.js.html":{"id":"streaming_utils_TTMLParser.js.html","title":"Source: streaming/utils/TTMLParser.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/utils/TTMLParser.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import { fromXML, generateISD } from 'imsc'; function TTMLParser() { const context = this.context; const eventBus = EventBus(context).getInstance(); /* * This TTML parser follows \"EBU-TT-D SUBTITLING DISTRIBUTION FORMAT - tech3380\" spec - https://tech.ebu.ch/docs/tech/tech3380.pdf. * */ let instance, logger; let cueCounter = 0; // Used to give every cue a unique ID. function setup() { logger = Debug(context).getInstance().getLogger(instance); } function getCueID() { const id = 'cue_TTML_' + cueCounter; cueCounter++; return id; } /** * Parse the raw data and process it to return the HTML element representing the cue. * Return the region to be processed and controlled (hide/show) by the caption controller. * @param {string} data - raw data received from the TextSourceBuffer * @param {number} offsetTime - offset time to apply to cue time * @param {integer} startTimeSegment - startTime for the current segment * @param {integer} endTimeSegment - endTime for the current segment * @param {Array} images - images array referenced by subs MP4 box */ function parse(data, offsetTime, startTimeSegment, endTimeSegment, images) { let errorMsg = ''; const captionArray = []; let startTime, endTime, i; const content = {}; const embeddedImages = {}; let currentImageId = ''; let accumulated_image_data = ''; let metadataHandler = { onOpenTag: function (ns, name, attrs) { if (name === 'image' &amp;&amp; (ns === 'http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt' || ns === 'http://www.smpte-ra.org/schemas/2052-1/2013/smpte-tt')) { if (!attrs[' imageType'] || attrs[' imageType'].value !== 'PNG') { logger.warn('smpte-tt imageType != PNG. Discarded'); return; } currentImageId = attrs['http://www.w3.org/XML/1998/namespace id'].value; } }, onCloseTag: function () { if (currentImageId) { embeddedImages[currentImageId] = accumulated_image_data.trim(); } accumulated_image_data = ''; currentImageId = ''; }, onText: function (contents) { if (currentImageId) { accumulated_image_data = accumulated_image_data + contents; } } }; if (!data) { errorMsg = 'no ttml data to parse'; throw new Error(errorMsg); } content.data = data; eventBus.trigger(Events.TTML_TO_PARSE, content); const imsc1doc = fromXML(content.data, function (msg) { errorMsg = msg; }, metadataHandler); eventBus.trigger(Events.TTML_PARSED, {ttmlString: content.data, ttmlDoc: imsc1doc}); const mediaTimeEvents = imsc1doc.getMediaTimeEvents(); for (i = 0; i &lt; mediaTimeEvents.length; i++) { let isd = generateISD(imsc1doc, mediaTimeEvents[i], function (error) { errorMsg = error; }); if (isd.contents.some(topLevelContents =&gt; topLevelContents.contents.length)) { //be sure that mediaTimeEvents values are in the mp4 segment time ranges. startTime = (mediaTimeEvents[i] + offsetTime) &lt; startTimeSegment ? startTimeSegment : (mediaTimeEvents[i] + offsetTime); endTime = (mediaTimeEvents[i + 1] + offsetTime) &gt; endTimeSegment ? endTimeSegment : (mediaTimeEvents[i + 1] + offsetTime); if (startTime &lt; endTime) { captionArray.push({ start: startTime, end: endTime, type: 'html', cueID: getCueID(), isd: isd, images: images, embeddedImages: embeddedImages }); } } } if (errorMsg !== '') { logger.error(errorMsg); throw new Error(errorMsg); } return captionArray; } instance = { parse: parse }; setup(); return instance; } TTMLParser.__dashjs_factory_name = 'TTMLParser'; export default FactoryMaker.getSingletonFactory(TTMLParser); × Search results Close "},"streaming_controllers_XlinkController.js.html":{"id":"streaming_controllers_XlinkController.js.html","title":"Source: streaming/controllers/XlinkController.js","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Source: streaming/controllers/XlinkController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import XlinkLoader from '../XlinkLoader'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import X2JS from '../../../externals/xml2json'; import URLUtils from '../utils/URLUtils'; import DashConstants from '../../dash/constants/DashConstants'; const RESOLVE_TYPE_ONLOAD = 'onLoad'; const RESOLVE_TYPE_ONACTUATE = 'onActuate'; const RESOLVE_TO_ZERO = 'urn:mpeg:dash:resolve-to-zero:2013'; function XlinkController(config) { config = config || {}; let context = this.context; let eventBus = EventBus(context).getInstance(); const urlUtils = URLUtils(context).getInstance(); let instance, matchers, iron, manifest, converter, xlinkLoader; function setup() { eventBus.on(Events.XLINK_ELEMENT_LOADED, onXlinkElementLoaded, instance); xlinkLoader = XlinkLoader(context).create({ errHandler: config.errHandler, dashMetrics: config.dashMetrics, mediaPlayerModel: config.mediaPlayerModel, requestModifier: config.requestModifier, settings: config.settings }); } function setMatchers(value) { if (value) { matchers = value; } } function setIron(value) { if (value) { iron = value; } } /** * &lt;p&gt;Triggers the resolution of the xlink.onLoad attributes in the manifest file &lt;/p&gt; * @param {Object} mpd - the manifest */ function resolveManifestOnLoad(mpd) { let elements; // First resolve all periods, so unnecessary requests inside onLoad Periods with Default content are avoided converter = new X2JS({ escapeMode: false, attributePrefix: '', arrayAccessForm: 'property', emptyNodeForm: 'object', stripWhitespaces: false, enableToStringFunc: false, ignoreRoot: true, matchers: matchers }); manifest = mpd; elements = getElementsToResolve(manifest.Period_asArray, manifest, DashConstants.PERIOD, RESOLVE_TYPE_ONLOAD); resolve(elements, DashConstants.PERIOD, RESOLVE_TYPE_ONLOAD); } function reset() { eventBus.off(Events.XLINK_ELEMENT_LOADED, onXlinkElementLoaded, instance); if (xlinkLoader) { xlinkLoader.reset(); xlinkLoader = null; } } function resolve(elements, type, resolveType) { let resolveObject = {}; let element, url; resolveObject.elements = elements; resolveObject.type = type; resolveObject.resolveType = resolveType; // If nothing to resolve, directly call allElementsLoaded if (resolveObject.elements.length === 0) { onXlinkAllElementsLoaded(resolveObject); } for (let i = 0; i &lt; resolveObject.elements.length; i++) { element = resolveObject.elements[i]; if (urlUtils.isHTTPURL(element.url)) { url = element.url; } else { url = element.originalContent.BaseURL + element.url; } xlinkLoader.load(url, element, resolveObject); } } function onXlinkElementLoaded(event) { let element, resolveObject; const openingTag = '&lt;response&gt;'; const closingTag = '&lt;/response&gt;'; let mergedContent = ''; element = event.element; resolveObject = event.resolveObject; // if the element resolved into content parse the content if (element.resolvedContent) { let index = 0; // we add a parent elements so the converter is able to parse multiple elements of the same type which are not wrapped inside a container if (element.resolvedContent.indexOf('&lt;?xml') === 0) { index = element.resolvedContent.indexOf('?&gt;') + 2; //find the closing position of the xml declaration, if it exists. } mergedContent = element.resolvedContent.substr(0,index) + openingTag + element.resolvedContent.substr(index) + closingTag; element.resolvedContent = converter.xml_str2json(mergedContent); } if (isResolvingFinished(resolveObject)) { onXlinkAllElementsLoaded(resolveObject); } } // We got to wait till all elements of the current queue are resolved before merging back function onXlinkAllElementsLoaded (resolveObject) { let elements = []; let i, obj; mergeElementsBack(resolveObject); if (resolveObject.resolveType === RESOLVE_TYPE_ONACTUATE) { eventBus.trigger(Events.XLINK_READY, {manifest: manifest}); } if (resolveObject.resolveType === RESOLVE_TYPE_ONLOAD) { switch (resolveObject.type) { // Start resolving the other elements. We can do Adaptation Set and EventStream in parallel case DashConstants.PERIOD: for (i = 0; i &lt; manifest[DashConstants.PERIOD + '_asArray'].length; i++) { obj = manifest[DashConstants.PERIOD + '_asArray'][i]; if (obj.hasOwnProperty(DashConstants.ADAPTATION_SET + '_asArray')) { elements = elements.concat(getElementsToResolve(obj[DashConstants.ADAPTATION_SET + '_asArray'], obj, DashConstants.ADAPTATION_SET, RESOLVE_TYPE_ONLOAD)); } if (obj.hasOwnProperty(DashConstants.EVENT_STREAM + '_asArray')) { elements = elements.concat(getElementsToResolve(obj[DashConstants.EVENT_STREAM + '_asArray'], obj, DashConstants.EVENT_STREAM, RESOLVE_TYPE_ONLOAD)); } } resolve(elements, DashConstants.ADAPTATION_SET, RESOLVE_TYPE_ONLOAD); break; case DashConstants.ADAPTATION_SET: // TODO: Resolve SegmentList here eventBus.trigger(Events.XLINK_READY, {manifest: manifest}); break; } } } // Returns the elements with the specific resolve Type function getElementsToResolve(elements, parentElement, type, resolveType) { let toResolve = []; let element, i, xlinkObject; // first remove all the resolve-to-zero elements for (i = elements.length - 1; i &gt;= 0; i--) { element = elements[i]; if (element.hasOwnProperty('xlink:href') &amp;&amp; element['xlink:href'] === RESOLVE_TO_ZERO) { elements.splice(i, 1); } } // now get the elements with the right resolve type for (i = 0; i &lt; elements.length; i++) { element = elements[i]; if (element.hasOwnProperty('xlink:href') &amp;&amp; element.hasOwnProperty('xlink:actuate') &amp;&amp; element['xlink:actuate'] === resolveType) { xlinkObject = createXlinkObject(element['xlink:href'], parentElement, type, i, resolveType, element); toResolve.push(xlinkObject); } } return toResolve; } function mergeElementsBack(resolveObject) { let resolvedElements = []; let element, type, obj, i, j, k; // Start merging back from the end because of index shifting. Note that the elements with the same parent have to be ordered by index ascending for (i = resolveObject.elements.length - 1; i &gt;= 0; i --) { element = resolveObject.elements[i]; type = element.type + '_asArray'; // Element couldn't be resolved or is TODO Inappropriate target: Remove all Xlink attributes if (!element.resolvedContent || isInappropriateTarget()) { delete element.originalContent['xlink:actuate']; delete element.originalContent['xlink:href']; resolvedElements.push(element.originalContent); } // Element was successfully resolved else if (element.resolvedContent) { for (j = 0; j &lt; element.resolvedContent[type].length; j++) { //TODO Contains another Xlink attribute with xlink:actuate set to onload. Remove all xLink attributes obj = element.resolvedContent[type][j]; resolvedElements.push(obj); } } // Replace the old elements in the parent with the resolved ones element.parentElement[type].splice(element.index, 1); for (k = 0; k &lt; resolvedElements.length; k++) { element.parentElement[type].splice(element.index + k, 0, resolvedElements[k]); } resolvedElements = []; } if (resolveObject.elements.length &gt; 0) { iron.run(manifest); } } function createXlinkObject(url, parentElement, type, index, resolveType, originalContent) { return { url: url, parentElement: parentElement, type: type, index: index, resolveType: resolveType, originalContent: originalContent, resolvedContent: null, resolved: false }; } // Check if all pending requests are finished function isResolvingFinished(elementsToResolve) { let i, obj; for (i = 0; i &lt; elementsToResolve.elements.length; i++) { obj = elementsToResolve.elements[i]; if (obj.resolved === false) { return false; } } return true; } // TODO : Do some syntax check here if the target is valid or not function isInappropriateTarget() { return false; } instance = { resolveManifestOnLoad: resolveManifestOnLoad, setMatchers: setMatchers, setIron: setIron, reset: reset }; setup(); return instance; } XlinkController.__dashjs_factory_name = 'XlinkController'; export default FactoryMaker.getClassFactory(XlinkController); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Global Members &lt;constant&gt; Entities The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license. Copyright (c) 2013, Dash Industry Forum. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Dash Industry Forum nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Source: offline/utils/OfflineIndexDBManifestParser.js, line 32 &lt;constant&gt; localforage The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license. Copyright (c) 2013, Dash Industry Forum. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Dash Industry Forum nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Source: offline/storage/IndexDBStore.js, line 31 Type Definitions MediaType The media types Type: \"video\" | \"audio\" | \"text\" | \"fragmentedText\" | \"embeddedText\" | \"image\" Source: streaming/MediaPlayer.js, line 83 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Modules Classes Errors MediaPlayerEvents MssErrors OfflineErrors OfflineEvents ProtectionErrors ProtectionEvents Events AST_IN_FUTURE Triggered when playback will not start yet as the MPD's availabilityStartTime is in the future. Check delay property in payload to determine time before playback will start. Source: streaming/MediaPlayerEvents.js, line 44 BUFFER_EMPTY Triggered when the video element's buffer state changes to stalled. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 52 BUFFER_LEVEL_STATE_CHANGED Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. Source: streaming/MediaPlayerEvents.js, line 66 BUFFER_LOADED Triggered when the video element's buffer state changes to loaded. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 59 CAN_PLAY Sent when enough data is available that the media can be played, at least for a couple of frames. This corresponds to the HAVE_ENOUGH_DATA readyState. Source: streaming/MediaPlayerEvents.js, line 233 CAPTION_CONTAINER_RESIZE Triggered when the caption container is resized. Source: streaming/MediaPlayerEvents.js, line 227 CAPTION_RENDERED Triggered when a caption is rendered. Source: streaming/MediaPlayerEvents.js, line 221 ERROR Triggered when there is an error from the element or MSE source buffer. Source: streaming/MediaPlayerEvents.js, line 72 FRAGMENT_LOADING_ABANDONED Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. Source: streaming/MediaPlayerEvents.js, line 94 FRAGMENT_LOADING_COMPLETED Triggered when a fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 77 FRAGMENT_LOADING_PROGRESS Triggered when a partial fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 83 FRAGMENT_LOADING_STARTED Triggered when a fragment download has started. Source: streaming/MediaPlayerEvents.js, line 88 GAP_CAUSED_SEEK_TO_PERIOD_END A gap occured in the timeline which requires a seek to the next period Source: streaming/MediaPlayerEvents.js, line 346 LOG Triggered when module:Debug logger methods are called. Source: streaming/MediaPlayerEvents.js, line 100 MANIFEST_LOADED Triggered when the manifest load is complete Source: streaming/MediaPlayerEvents.js, line 107 MANIFEST_VALIDITY_CHANGED Manifest validity changed - As a result of an MPD validity expiration event. Source: streaming/MediaPlayerEvents.js, line 340 METRIC_ADDED Triggered every time a new metric is added. Source: streaming/MediaPlayerEvents.js, line 125 METRIC_CHANGED Triggered when an individual metric is added, updated or cleared. Source: streaming/MediaPlayerEvents.js, line 119 METRIC_UPDATED Triggered every time a metric is updated. Source: streaming/MediaPlayerEvents.js, line 131 METRICS_CHANGED Triggered anytime there is a change to the overall metrics. Source: streaming/MediaPlayerEvents.js, line 113 PERIOD_SWITCH_COMPLETED Triggered at the stream end of a period. Source: streaming/MediaPlayerEvents.js, line 137 PERIOD_SWITCH_STARTED Triggered when a new period starts. Source: streaming/MediaPlayerEvents.js, line 143 PLAYBACK_ENDED Sent when playback completes. Source: streaming/MediaPlayerEvents.js, line 241 PLAYBACK_ERROR Sent when an error occurs. The element's error attribute contains more information. Source: streaming/MediaPlayerEvents.js, line 247 PLAYBACK_METADATA_LOADED The media's metadata has finished loading; all attributes now contain as much useful information as they're going to. Source: streaming/MediaPlayerEvents.js, line 260 PLAYBACK_NOT_ALLOWED Sent when playback is not allowed (for example if user gesture is needed). Source: streaming/MediaPlayerEvents.js, line 254 PLAYBACK_PAUSED Sent when playback is paused. Source: streaming/MediaPlayerEvents.js, line 267 PLAYBACK_PLAYING Sent when the media begins to play (either for the first time, after having been paused, or after ending and then restarting). Source: streaming/MediaPlayerEvents.js, line 273 PLAYBACK_PROGRESS Sent periodically to inform interested parties of progress downloading the media. Information about the current amount of the media that has been downloaded is available in the media element's buffered attribute. Source: streaming/MediaPlayerEvents.js, line 281 PLAYBACK_RATE_CHANGED Sent when the playback speed changes. Source: streaming/MediaPlayerEvents.js, line 289 PLAYBACK_SEEK_ASKED Sent when a seek operation has been asked. Source: streaming/MediaPlayerEvents.js, line 307 PLAYBACK_SEEKED Sent when a seek operation completes. Source: streaming/MediaPlayerEvents.js, line 295 PLAYBACK_SEEKING Sent when a seek operation begins. Source: streaming/MediaPlayerEvents.js, line 301 PLAYBACK_STALLED Sent when the video element reports stalled Source: streaming/MediaPlayerEvents.js, line 313 PLAYBACK_STARTED Sent when playback of the media starts after having been paused; that is, when playback is resumed after a prior pause event. Source: streaming/MediaPlayerEvents.js, line 319 PLAYBACK_TIME_UPDATED The time indicated by the element's currentTime attribute has changed. Source: streaming/MediaPlayerEvents.js, line 327 PLAYBACK_WAITING Sent when the media playback has stopped because of a temporary lack of data. Source: streaming/MediaPlayerEvents.js, line 333 QUALITY_CHANGE_RENDERED Triggered when the new ABR quality is being rendered on-screen. Source: streaming/MediaPlayerEvents.js, line 155 QUALITY_CHANGE_REQUESTED Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. Source: streaming/MediaPlayerEvents.js, line 149 SOURCE_INITIALIZED Triggered when the source is setup and ready. Source: streaming/MediaPlayerEvents.js, line 167 STREAM_INITIALIZED Triggered when a stream (period) is updated Source: streaming/MediaPlayerEvents.js, line 185 STREAM_INITIALIZING Triggered when a stream (period) is being loaded Source: streaming/MediaPlayerEvents.js, line 173 STREAM_TEARDOWN_COMPLETE Triggered when the player has been reset. Source: streaming/MediaPlayerEvents.js, line 191 STREAM_UPDATED Triggered when a stream (period) is loaded Source: streaming/MediaPlayerEvents.js, line 179 TEXT_TRACK_ADDED Triggered when a text track is added to the video element's TextTrackList Source: streaming/MediaPlayerEvents.js, line 203 TEXT_TRACKS_ADDED Triggered once all text tracks detected in the MPD are added to the video element. Source: streaming/MediaPlayerEvents.js, line 197 TRACK_CHANGE_RENDERED Triggered when the new track is being rendered. Source: streaming/MediaPlayerEvents.js, line 161 TTML_PARSED Triggered when a ttml chunk is parsed. Source: streaming/MediaPlayerEvents.js, line 209 TTML_TO_PARSE Triggered when a ttml chunk has to be parsed. Source: streaming/MediaPlayerEvents.js, line 215 OFFLINE_RECORD_FINISHED Triggered when all record has been downloaded Source: offline/events/OfflineEvents.js, line 28 OFFLINE_RECORD_LOADEDMETADATA Triggered when all mediaInfo has been loaded Source: offline/events/OfflineEvents.js, line 10 OFFLINE_RECORD_STARTED Triggered when a record is initialized and download is started Source: offline/events/OfflineEvents.js, line 16 OFFLINE_RECORD_STOPPED Triggered when the user stop downloading a record Source: offline/events/OfflineEvents.js, line 22 KEY_ADDED Event ID for events delivered when a new key has been added Deprecated: The latest versions of the EME specification no longer use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} is preferred. Source: streaming/protection/ProtectionEvents.js, line 65 KEY_ERROR Event ID for events delivered when an error is encountered by the CDM while processing a license server response message Source: streaming/protection/ProtectionEvents.js, line 75 KEY_MESSAGE Event ID for events delivered when the protection set receives a key message from the CDM Source: streaming/protection/ProtectionEvents.js, line 82 KEY_SESSION_CLOSED Event ID for events delivered when a key session close process has completed Source: streaming/protection/ProtectionEvents.js, line 89 KEY_SESSION_CREATED Event ID for events delivered when a new key sessions creation process has completed Source: streaming/protection/ProtectionEvents.js, line 96 KEY_SESSION_REMOVED Event ID for events delivered when a key session removal process has completed Source: streaming/protection/ProtectionEvents.js, line 103 KEY_STATUSES_CHANGED Event ID for events delivered when the status of one or more decryption keys has changed Source: streaming/protection/ProtectionEvents.js, line 110 KEY_SYSTEM_SELECTED Event ID for events delivered when a key system selection procedure completes Source: streaming/protection/ProtectionEvents.js, line 124 LICENSE_REQUEST_COMPLETE Event ID for events delivered when a license request procedure has completed Source: streaming/protection/ProtectionEvents.js, line 131 PROTECTION_CREATED Event ID for events delivered when the Protection system is detected and created. Source: streaming/protection/ProtectionEvents.js, line 144 PROTECTION_DESTROYED Event ID for events delivered when the Protection system is destroyed. Source: streaming/protection/ProtectionEvents.js, line 150 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Classes Classes Errors MediaPlayerEvents MssErrors OfflineErrors OfflineEvents ProtectionErrors ProtectionEvents Events AST_IN_FUTURE Triggered when playback will not start yet as the MPD's availabilityStartTime is in the future. Check delay property in payload to determine time before playback will start. Source: streaming/MediaPlayerEvents.js, line 44 BUFFER_EMPTY Triggered when the video element's buffer state changes to stalled. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 52 BUFFER_LEVEL_STATE_CHANGED Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. Source: streaming/MediaPlayerEvents.js, line 66 BUFFER_LOADED Triggered when the video element's buffer state changes to loaded. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 59 CAN_PLAY Sent when enough data is available that the media can be played, at least for a couple of frames. This corresponds to the HAVE_ENOUGH_DATA readyState. Source: streaming/MediaPlayerEvents.js, line 233 CAPTION_CONTAINER_RESIZE Triggered when the caption container is resized. Source: streaming/MediaPlayerEvents.js, line 227 CAPTION_RENDERED Triggered when a caption is rendered. Source: streaming/MediaPlayerEvents.js, line 221 ERROR Triggered when there is an error from the element or MSE source buffer. Source: streaming/MediaPlayerEvents.js, line 72 FRAGMENT_LOADING_ABANDONED Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. Source: streaming/MediaPlayerEvents.js, line 94 FRAGMENT_LOADING_COMPLETED Triggered when a fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 77 FRAGMENT_LOADING_PROGRESS Triggered when a partial fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 83 FRAGMENT_LOADING_STARTED Triggered when a fragment download has started. Source: streaming/MediaPlayerEvents.js, line 88 GAP_CAUSED_SEEK_TO_PERIOD_END A gap occured in the timeline which requires a seek to the next period Source: streaming/MediaPlayerEvents.js, line 346 LOG Triggered when module:Debug logger methods are called. Source: streaming/MediaPlayerEvents.js, line 100 MANIFEST_LOADED Triggered when the manifest load is complete Source: streaming/MediaPlayerEvents.js, line 107 MANIFEST_VALIDITY_CHANGED Manifest validity changed - As a result of an MPD validity expiration event. Source: streaming/MediaPlayerEvents.js, line 340 METRIC_ADDED Triggered every time a new metric is added. Source: streaming/MediaPlayerEvents.js, line 125 METRIC_CHANGED Triggered when an individual metric is added, updated or cleared. Source: streaming/MediaPlayerEvents.js, line 119 METRIC_UPDATED Triggered every time a metric is updated. Source: streaming/MediaPlayerEvents.js, line 131 METRICS_CHANGED Triggered anytime there is a change to the overall metrics. Source: streaming/MediaPlayerEvents.js, line 113 PERIOD_SWITCH_COMPLETED Triggered at the stream end of a period. Source: streaming/MediaPlayerEvents.js, line 137 PERIOD_SWITCH_STARTED Triggered when a new period starts. Source: streaming/MediaPlayerEvents.js, line 143 PLAYBACK_ENDED Sent when playback completes. Source: streaming/MediaPlayerEvents.js, line 241 PLAYBACK_ERROR Sent when an error occurs. The element's error attribute contains more information. Source: streaming/MediaPlayerEvents.js, line 247 PLAYBACK_METADATA_LOADED The media's metadata has finished loading; all attributes now contain as much useful information as they're going to. Source: streaming/MediaPlayerEvents.js, line 260 PLAYBACK_NOT_ALLOWED Sent when playback is not allowed (for example if user gesture is needed). Source: streaming/MediaPlayerEvents.js, line 254 PLAYBACK_PAUSED Sent when playback is paused. Source: streaming/MediaPlayerEvents.js, line 267 PLAYBACK_PLAYING Sent when the media begins to play (either for the first time, after having been paused, or after ending and then restarting). Source: streaming/MediaPlayerEvents.js, line 273 PLAYBACK_PROGRESS Sent periodically to inform interested parties of progress downloading the media. Information about the current amount of the media that has been downloaded is available in the media element's buffered attribute. Source: streaming/MediaPlayerEvents.js, line 281 PLAYBACK_RATE_CHANGED Sent when the playback speed changes. Source: streaming/MediaPlayerEvents.js, line 289 PLAYBACK_SEEK_ASKED Sent when a seek operation has been asked. Source: streaming/MediaPlayerEvents.js, line 307 PLAYBACK_SEEKED Sent when a seek operation completes. Source: streaming/MediaPlayerEvents.js, line 295 PLAYBACK_SEEKING Sent when a seek operation begins. Source: streaming/MediaPlayerEvents.js, line 301 PLAYBACK_STALLED Sent when the video element reports stalled Source: streaming/MediaPlayerEvents.js, line 313 PLAYBACK_STARTED Sent when playback of the media starts after having been paused; that is, when playback is resumed after a prior pause event. Source: streaming/MediaPlayerEvents.js, line 319 PLAYBACK_TIME_UPDATED The time indicated by the element's currentTime attribute has changed. Source: streaming/MediaPlayerEvents.js, line 327 PLAYBACK_WAITING Sent when the media playback has stopped because of a temporary lack of data. Source: streaming/MediaPlayerEvents.js, line 333 QUALITY_CHANGE_RENDERED Triggered when the new ABR quality is being rendered on-screen. Source: streaming/MediaPlayerEvents.js, line 155 QUALITY_CHANGE_REQUESTED Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. Source: streaming/MediaPlayerEvents.js, line 149 SOURCE_INITIALIZED Triggered when the source is setup and ready. Source: streaming/MediaPlayerEvents.js, line 167 STREAM_INITIALIZED Triggered when a stream (period) is updated Source: streaming/MediaPlayerEvents.js, line 185 STREAM_INITIALIZING Triggered when a stream (period) is being loaded Source: streaming/MediaPlayerEvents.js, line 173 STREAM_TEARDOWN_COMPLETE Triggered when the player has been reset. Source: streaming/MediaPlayerEvents.js, line 191 STREAM_UPDATED Triggered when a stream (period) is loaded Source: streaming/MediaPlayerEvents.js, line 179 TEXT_TRACK_ADDED Triggered when a text track is added to the video element's TextTrackList Source: streaming/MediaPlayerEvents.js, line 203 TEXT_TRACKS_ADDED Triggered once all text tracks detected in the MPD are added to the video element. Source: streaming/MediaPlayerEvents.js, line 197 TRACK_CHANGE_RENDERED Triggered when the new track is being rendered. Source: streaming/MediaPlayerEvents.js, line 161 TTML_PARSED Triggered when a ttml chunk is parsed. Source: streaming/MediaPlayerEvents.js, line 209 TTML_TO_PARSE Triggered when a ttml chunk has to be parsed. Source: streaming/MediaPlayerEvents.js, line 215 OFFLINE_RECORD_FINISHED Triggered when all record has been downloaded Source: offline/events/OfflineEvents.js, line 28 OFFLINE_RECORD_LOADEDMETADATA Triggered when all mediaInfo has been loaded Source: offline/events/OfflineEvents.js, line 10 OFFLINE_RECORD_STARTED Triggered when a record is initialized and download is started Source: offline/events/OfflineEvents.js, line 16 OFFLINE_RECORD_STOPPED Triggered when the user stop downloading a record Source: offline/events/OfflineEvents.js, line 22 KEY_ADDED Event ID for events delivered when a new key has been added Deprecated: The latest versions of the EME specification no longer use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} is preferred. Source: streaming/protection/ProtectionEvents.js, line 65 KEY_ERROR Event ID for events delivered when an error is encountered by the CDM while processing a license server response message Source: streaming/protection/ProtectionEvents.js, line 75 KEY_MESSAGE Event ID for events delivered when the protection set receives a key message from the CDM Source: streaming/protection/ProtectionEvents.js, line 82 KEY_SESSION_CLOSED Event ID for events delivered when a key session close process has completed Source: streaming/protection/ProtectionEvents.js, line 89 KEY_SESSION_CREATED Event ID for events delivered when a new key sessions creation process has completed Source: streaming/protection/ProtectionEvents.js, line 96 KEY_SESSION_REMOVED Event ID for events delivered when a key session removal process has completed Source: streaming/protection/ProtectionEvents.js, line 103 KEY_STATUSES_CHANGED Event ID for events delivered when the status of one or more decryption keys has changed Source: streaming/protection/ProtectionEvents.js, line 110 KEY_SYSTEM_SELECTED Event ID for events delivered when a key system selection procedure completes Source: streaming/protection/ProtectionEvents.js, line 124 LICENSE_REQUEST_COMPLETE Event ID for events delivered when a license request procedure has completed Source: streaming/protection/ProtectionEvents.js, line 131 PROTECTION_CREATED Event ID for events delivered when the Protection system is detected and created. Source: streaming/protection/ProtectionEvents.js, line 144 PROTECTION_DESTROYED Event ID for events delivered when the Protection system is destroyed. Source: streaming/protection/ProtectionEvents.js, line 150 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Build status (CircleCI): Join #dashjs on Slack! Overview A reference client implementation for the playback of MPEG DASH via JavaScript and compliant browsers. Learn more about DASH IF Reference Client on our wiki. If your intent is to use the player code without contributing back to this project, then use the MASTER branch which holds the approved and stable public releases. If your goal is to improve or extend the code and contribute back to this project, then you should make your changes in, and submit a pull request against, the DEVELOPMENT branch. Read our CONTRIBUTION.md file for a walk-through of the contribution process. All new work should be in the development branch. Master is now reserved for tagged builds. Demo and reference players All these reference builds and minified files are available under both http and https. Samples Multiple dash.js samples covering a wide set of common use cases. Reference players The released pre-built reference players if you want direct access without writing any Javascript. The nightly build of the /dev branch reference player, is pre-release but contains the latest fixes. It is a good place to start if you are debugging playback problems. CDN hosted files The latest minified files have been hosted on a global CDN and are free to use in production: dash.all.min.js dash.all.debug.js In addition, all the releases are available under the following urls. Replace \"vx.x.x\" with the release version, for instance \"v3.1.0\". http://cdn.dashjs.org/vx.x.x/dash.all.min.js http://cdn.dashjs.org/vx.x.x/dash.all.debug.js Documentation Full API Documentation is available describing all public methods, interfaces, properties, and events. For help, join our Slack channel, our email list and read our wiki. If you are migrating from dash.js v2.x to dash.js v3.x please read the migration document found here. Getting Started The standard setup method uses javascript to initialize and provide video details to dash.js. MediaPlayerFactory provides an alternative declarative setup syntax. Standard Setup Create a video element somewhere in your html. For our purposes, make sure the controls attribute is present. &lt;video id=\"videoPlayer\" controls&gt;&lt;/video&gt; Add dash.all.min.js to the end of the body. &lt;body&gt; ... &lt;script src=\"yourPathToDash/dash.all.min.js\"&gt;&lt;/script&gt; &lt;/body&gt; Now comes the good stuff. We need to create a MediaPlayer and initialize it. var url = \"https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd\"; var player = dashjs.MediaPlayer().create(); player.initialize(document.querySelector(\"#videoPlayer\"), url, true); When it is all done, it should look similar to this: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Dash.js Rocks&lt;/title&gt; &lt;style&gt; video { width: 640px; height: 360px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;video id=\"videoPlayer\" controls&gt;&lt;/video&gt; &lt;/div&gt; &lt;script src=\"yourPathToDash/dash.all.min.js\"&gt;&lt;/script&gt; &lt;script&gt; (function(){ var url = \"https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd\"; var player = dashjs.MediaPlayer().create(); player.initialize(document.querySelector(\"#videoPlayer\"), url, true); })(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Module Setup We publish dash.js to npm. Examples of how to use dash.js in different module bundlers can be found in the samples/modules directory. MediaPlayerFactory Setup An alternative way to build a Dash.js player in your web page is to use the MediaPlayerFactory. The MediaPlayerFactory will automatically instantiate and initialize the MediaPlayer module on appropriately tagged video elements. Create a video element somewhere in your html and provide the path to your mpd file as src. Also ensure that your video element has the data-dashjs-player attribute on it. &lt;video data-dashjs-player autoplay src=\"https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd\" controls&gt; &lt;/video&gt; Add dash.all.min.js to the end of the body. &lt;body&gt; ... &lt;script src=\"yourPathToDash/dash.all.min.js\"&gt;&lt;/script&gt; &lt;/body&gt; When it is all done, it should look similar to this: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Dash.js Rocks&lt;/title&gt; &lt;style&gt; video { width: 640px; height: 360px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;video data-dashjs-player autoplay src=\"https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd\" controls&gt; &lt;/video&gt; &lt;/div&gt; &lt;script src=\"yourPathToDash/dash.all.min.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Quick Start for Developers Install Core Dependencies install nodejs install grunt npm install -g grunt-cli Checkout project repository (default branch: development) git clone https://github.com/Dash-Industry-Forum/dash.js.git Install dependencies npm install Build, watch file changes and launch samples page, which has links that point to reference player and to other examples (basic examples, captioning, ads, live, etc). grunt dev Other Grunt Tasks to Build / Run Tests on Commandline. Individual tasks: Quickest build grunt debug Lint grunt lint Run unit tests grunt test Build distribution files (minification included) grunt dist Build distribution files, lint, run unit tests and generate documentation grunt release GruntFile.js default task (equivalent to grunt dist &amp;&amp; grunt test) grunt License dash.js is released under BSD license Tested With × Search results Close "},"Errors.html":{"id":"Errors.html","title":"Class: Errors","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Class: Errors Errors Errors declaration new Errors() Source: core/errors/Errors.js, line 36 Members CAPABILITY_MEDIAKEYS_ERROR_CODE Error code returned when Protected contents are not supported Source: core/errors/Errors.js, line 71 CAPABILITY_MEDIASOURCE_ERROR_CODE Error code returned when MediaSource is not supported by the browser Source: core/errors/Errors.js, line 67 MANIFEST_ERROR_ID_MULTIPLEXED_CODE Error code returned when a 'muxed' media type has been detected in the manifest. This type is not supported Source: core/errors/Errors.js, line 96 MANIFEST_ERROR_ID_NOSTREAMS_CODE Error code returned when no stream (period) has been detected in the manifest Source: core/errors/Errors.js, line 88 MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE Error code returned when a manifest loading error occurs Source: core/errors/Errors.js, line 46 MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE Error code returned when a manifest parsing error occurs Source: core/errors/Errors.js, line 42 MEDIASOURCE_TYPE_UNSUPPORTED_CODE Error code returned when a media source type is not supported Source: core/errors/Errors.js, line 100 SEGMENTS_UPDATE_FAILED_ERROR_CODE Error code returned when the update of segments list has failed Source: core/errors/Errors.js, line 54 TIMED_TEXT_ERROR_ID_PARSE_CODE Error code returned when something wrong has append during subtitles parsing (TTML or VTT) Source: core/errors/Errors.js, line 92 XLINK_LOADER_LOADING_FAILURE_ERROR_CODE Error code returned when a xlink loading error occurs Source: core/errors/Errors.js, line 50 × Search results Close "},"MediaPlayerEvents.html":{"id":"MediaPlayerEvents.html","title":"Class: MediaPlayerEvents","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Class: MediaPlayerEvents MediaPlayerEvents new MediaPlayerEvents() Public facing external events to be used when developing a player that implements dash.js. Implements: EventsBase Source: streaming/MediaPlayerEvents.js, line 37 Events AST_IN_FUTURE Triggered when playback will not start yet as the MPD's availabilityStartTime is in the future. Check delay property in payload to determine time before playback will start. Source: streaming/MediaPlayerEvents.js, line 44 BUFFER_EMPTY Triggered when the video element's buffer state changes to stalled. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 52 BUFFER_LEVEL_STATE_CHANGED Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. Source: streaming/MediaPlayerEvents.js, line 66 BUFFER_LOADED Triggered when the video element's buffer state changes to loaded. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 59 CAN_PLAY Sent when enough data is available that the media can be played, at least for a couple of frames. This corresponds to the HAVE_ENOUGH_DATA readyState. Source: streaming/MediaPlayerEvents.js, line 233 CAPTION_CONTAINER_RESIZE Triggered when the caption container is resized. Source: streaming/MediaPlayerEvents.js, line 227 CAPTION_RENDERED Triggered when a caption is rendered. Source: streaming/MediaPlayerEvents.js, line 221 ERROR Triggered when there is an error from the element or MSE source buffer. Source: streaming/MediaPlayerEvents.js, line 72 FRAGMENT_LOADING_ABANDONED Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. Source: streaming/MediaPlayerEvents.js, line 94 FRAGMENT_LOADING_COMPLETED Triggered when a fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 77 FRAGMENT_LOADING_PROGRESS Triggered when a partial fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 83 FRAGMENT_LOADING_STARTED Triggered when a fragment download has started. Source: streaming/MediaPlayerEvents.js, line 88 GAP_CAUSED_SEEK_TO_PERIOD_END A gap occured in the timeline which requires a seek to the next period Source: streaming/MediaPlayerEvents.js, line 346 LOG Triggered when module:Debug logger methods are called. Source: streaming/MediaPlayerEvents.js, line 100 MANIFEST_LOADED Triggered when the manifest load is complete Source: streaming/MediaPlayerEvents.js, line 107 MANIFEST_VALIDITY_CHANGED Manifest validity changed - As a result of an MPD validity expiration event. Source: streaming/MediaPlayerEvents.js, line 340 METRIC_ADDED Triggered every time a new metric is added. Source: streaming/MediaPlayerEvents.js, line 125 METRIC_CHANGED Triggered when an individual metric is added, updated or cleared. Source: streaming/MediaPlayerEvents.js, line 119 METRIC_UPDATED Triggered every time a metric is updated. Source: streaming/MediaPlayerEvents.js, line 131 METRICS_CHANGED Triggered anytime there is a change to the overall metrics. Source: streaming/MediaPlayerEvents.js, line 113 PERIOD_SWITCH_COMPLETED Triggered at the stream end of a period. Source: streaming/MediaPlayerEvents.js, line 137 PERIOD_SWITCH_STARTED Triggered when a new period starts. Source: streaming/MediaPlayerEvents.js, line 143 PLAYBACK_ENDED Sent when playback completes. Source: streaming/MediaPlayerEvents.js, line 241 PLAYBACK_ERROR Sent when an error occurs. The element's error attribute contains more information. Source: streaming/MediaPlayerEvents.js, line 247 PLAYBACK_METADATA_LOADED The media's metadata has finished loading; all attributes now contain as much useful information as they're going to. Source: streaming/MediaPlayerEvents.js, line 260 PLAYBACK_NOT_ALLOWED Sent when playback is not allowed (for example if user gesture is needed). Source: streaming/MediaPlayerEvents.js, line 254 PLAYBACK_PAUSED Sent when playback is paused. Source: streaming/MediaPlayerEvents.js, line 267 PLAYBACK_PLAYING Sent when the media begins to play (either for the first time, after having been paused, or after ending and then restarting). Source: streaming/MediaPlayerEvents.js, line 273 PLAYBACK_PROGRESS Sent periodically to inform interested parties of progress downloading the media. Information about the current amount of the media that has been downloaded is available in the media element's buffered attribute. Source: streaming/MediaPlayerEvents.js, line 281 PLAYBACK_RATE_CHANGED Sent when the playback speed changes. Source: streaming/MediaPlayerEvents.js, line 289 PLAYBACK_SEEK_ASKED Sent when a seek operation has been asked. Source: streaming/MediaPlayerEvents.js, line 307 PLAYBACK_SEEKED Sent when a seek operation completes. Source: streaming/MediaPlayerEvents.js, line 295 PLAYBACK_SEEKING Sent when a seek operation begins. Source: streaming/MediaPlayerEvents.js, line 301 PLAYBACK_STALLED Sent when the video element reports stalled Source: streaming/MediaPlayerEvents.js, line 313 PLAYBACK_STARTED Sent when playback of the media starts after having been paused; that is, when playback is resumed after a prior pause event. Source: streaming/MediaPlayerEvents.js, line 319 PLAYBACK_TIME_UPDATED The time indicated by the element's currentTime attribute has changed. Source: streaming/MediaPlayerEvents.js, line 327 PLAYBACK_WAITING Sent when the media playback has stopped because of a temporary lack of data. Source: streaming/MediaPlayerEvents.js, line 333 QUALITY_CHANGE_RENDERED Triggered when the new ABR quality is being rendered on-screen. Source: streaming/MediaPlayerEvents.js, line 155 QUALITY_CHANGE_REQUESTED Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. Source: streaming/MediaPlayerEvents.js, line 149 SOURCE_INITIALIZED Triggered when the source is setup and ready. Source: streaming/MediaPlayerEvents.js, line 167 STREAM_INITIALIZED Triggered when a stream (period) is updated Source: streaming/MediaPlayerEvents.js, line 185 STREAM_INITIALIZING Triggered when a stream (period) is being loaded Source: streaming/MediaPlayerEvents.js, line 173 STREAM_TEARDOWN_COMPLETE Triggered when the player has been reset. Source: streaming/MediaPlayerEvents.js, line 191 STREAM_UPDATED Triggered when a stream (period) is loaded Source: streaming/MediaPlayerEvents.js, line 179 TEXT_TRACK_ADDED Triggered when a text track is added to the video element's TextTrackList Source: streaming/MediaPlayerEvents.js, line 203 TEXT_TRACKS_ADDED Triggered once all text tracks detected in the MPD are added to the video element. Source: streaming/MediaPlayerEvents.js, line 197 TRACK_CHANGE_RENDERED Triggered when the new track is being rendered. Source: streaming/MediaPlayerEvents.js, line 161 TTML_PARSED Triggered when a ttml chunk is parsed. Source: streaming/MediaPlayerEvents.js, line 209 TTML_TO_PARSE Triggered when a ttml chunk has to be parsed. Source: streaming/MediaPlayerEvents.js, line 215 × Search results Close "},"module-DashAdapter.html":{"id":"module-DashAdapter.html","title":"Module: DashAdapter","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Module: DashAdapter Source: dash/DashAdapter.js, line 41 Methods getAdaptationForType(periodIndex, type, streamInfo) Returns the AdaptationSet for a given period and a given mediaType. Parameters: Name Type Description periodIndex number type MediaType streamInfo object Source: dash/DashAdapter.js, line 169 Returns: adaptation Type null | object getAllMediaInfoForType(streamInfo, type, externalManifest) Returns the mediaInfo for a given mediaType Parameters: Name Type Description streamInfo object type MediaType externalManifest object Set to null or undefined if no external manifest is to be used Source: dash/DashAdapter.js, line 204 Returns: mediaArr Type Array getAvailabilityStartTime(externalManifest) Returns the availabilityStartTime as specified in the manifest Parameters: Name Type Description externalManifest object Omit this value if no external manifest should be used Source: dash/DashAdapter.js, line 504 Returns: availabilityStartTime Type string getBandwidthForRepresentation(representationId, periodIdx) Returns the bandwidth for a given representation id Parameters: Name Type Description representationId number periodIdx number Source: dash/DashAdapter.js, line 636 Returns: bandwidth Type number getCodec(adaptation, representationId, addResolutionInfo) Returns the codec for a given adaptation set and a given representation id. Parameters: Name Type Description adaptation object representationId number addResolutionInfo boolean Defines whether to include resolution information in the output Source: dash/DashAdapter.js, line 624 Returns: codec Type String getDuration(externalManifest) Returns the duration of the MPD Parameters: Name Type Description externalManifest object Omit this value if no external manifest should be used Source: dash/DashAdapter.js, line 528 Returns: duration Type number getIndexForRepresentation(representationId, periodIdx) Returns the index for a given representation id Parameters: Name Type Description representationId string periodIdx number Source: dash/DashAdapter.js, line 653 Returns: index Type number getIsDynamic(externalManifest) Returns a boolean indicating if the manifest is dynamic or not Parameters: Name Type Description externalManifest object Omit this value if no external manifest should be used Source: dash/DashAdapter.js, line 516 Returns: Type boolean getIsMain(adaptation) Checks if the role of the specified AdaptationSet is set to main Parameters: Name Type Description adaptation object Source: dash/DashAdapter.js, line 154 Returns: Type boolean getLocation(manifest) Returns the location element of the MPD Parameters: Name Type Description manifest object Source: dash/DashAdapter.js, line 564 Returns: location Type String getManifestUpdatePeriod(manifest, latencyOfLastUpdate) Returns the manifest update period used for dynamic manifests Parameters: Name Type Default Description manifest object latencyOfLastUpdate number 0 Source: dash/DashAdapter.js, line 576 Returns: manifestUpdatePeriod Type NaN | number getMaxIndexForBufferType(bufferType, periodIdx) This method returns the current max index based on what is defined in the MPD. Parameters: Name Type Description bufferType string String 'audio' or 'video', periodIdx number Make sure this is the period index not id Source: dash/DashAdapter.js, line 668 Returns: Type number getMediaInfoForType(streamInfo, type) Returns a MediaInfo object for a given media type. Parameters: Name Type Description streamInfo object type MediaType Source: dash/DashAdapter.js, line 129 Returns: mediaInfo Type null | MediaInfo getMpd(externalManifest) Returns an MPD object Parameters: Name Type Description externalManifest object Omit this value if no external manifest should be used Source: dash/DashAdapter.js, line 552 Returns: MPD Type object getRealAdaptation(streamInfo, mediaInfo) Parameters: Name Type Description streamInfo object mediaInfo object Source: dash/DashAdapter.js, line 345 Returns: realAdaptation Type object getRegularPeriods(externalManifest) Returns all periods of the MPD Parameters: Name Type Description externalManifest object Omit this value if no external manifest should be used Source: dash/DashAdapter.js, line 540 Returns: periods Type Array getSuggestedPresentationDelay() Returns the suggestedPresentationDelay as specified in the manifest Source: dash/DashAdapter.js, line 492 Returns: suggestedPresentationDelay Type String getUTCTimingSources() Returns the UTC Timing Sources specified in the manifest Source: dash/DashAdapter.js, line 481 Returns: utcTimingSources Type Array getVoRepresentations(mediaInfo) Returns all voRepresentations for a given mediaInfo Parameters: Name Type Description mediaInfo object Source: dash/DashAdapter.js, line 367 Returns: voReps Type Array × Search results Close "},"module-DashMetrics.html":{"id":"module-DashMetrics.html","title":"Module: DashMetrics","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Module: DashMetrics Source: dash/DashMetrics.js, line 42 Methods getCurrent(metrics, metricName) Parameters: Name Type Description metrics MetricsList metricName string Source: dash/DashMetrics.js, line 224 Returns: Type * getCurrentBufferLevel(type) Parameters: Name Type Description type MediaType Source: dash/DashMetrics.js, line 112 Returns: Type number getCurrentBufferState(type) Parameters: Name Type Description type MediaType Source: dash/DashMetrics.js, line 101 Returns: Type number getCurrentDVRInfo(mediaType) Parameters: Name Type Description mediaType MediaType Source: dash/DashMetrics.js, line 376 Returns: Type * getCurrentHttpRequest(mediaType) Parameters: Name Type Description mediaType MediaType Source: dash/DashMetrics.js, line 162 Returns: Type * getCurrentManifestUpdate() Source: dash/DashMetrics.js, line 289 Returns: Type * getCurrentRepresentationSwitch(mediaType) Parameters: Name Type Description mediaType MediaType Source: dash/DashMetrics.js, line 76 Returns: Type * getCurrentSchedulingInfo(mediaType) Parameters: Name Type Description mediaType MediaType Source: dash/DashMetrics.js, line 259 Returns: Type * getHttpRequests(mediaType) Parameters: Name Type Description mediaType MediaType Source: dash/DashMetrics.js, line 196 Returns: Type * getLatestFragmentRequestHeaderValueByID(type, id) Parameters: Name Type Description type string id string Source: dash/DashMetrics.js, line 428 Returns: Type * getLatestMPDRequestHeaderValueByID(id) Parameters: Name Type Description id string Source: dash/DashMetrics.js, line 401 Returns: Type * × Search results Close "},"module-MediaPlayer.html":{"id":"module-MediaPlayer.html","title":"Module: MediaPlayer","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Module: MediaPlayer The MediaPlayer is the primary dash.js Module and a Facade to build your player around. It will allow you access to all the important dash.js properties/methods via the public API and all the events to build a robust DASH media player. Source: streaming/MediaPlayer.js, line 89 Members &lt;inner, constant&gt; ELEMENT_NOT_ATTACHED_ERROR :string error string thrown when a function is called before the dash.js has received a reference of an HTML5 video element Type: string Source: streaming/MediaPlayer.js, line 106 &lt;inner, constant&gt; MEDIA_PLAYER_NOT_INITIALIZED_ERROR :string error string thrown when a function is called before the dash.js has been fully initialized. Type: string Source: streaming/MediaPlayer.js, line 116 &lt;inner, constant&gt; PLAYBACK_NOT_INITIALIZED_ERROR :string error string thrown when a function is called before the dash.js has been fully initialized Type: string Source: streaming/MediaPlayer.js, line 101 &lt;inner, constant&gt; SOURCE_NOT_ATTACHED_ERROR :string error string thrown when a function is called before the dash.js has received a valid source stream. Type: string Source: streaming/MediaPlayer.js, line 111 &lt;inner, constant&gt; STREAMING_NOT_INITIALIZED_ERROR :string error string thrown when a function is called before the dash.js has been fully initialized Type: string Source: streaming/MediaPlayer.js, line 96 Methods addABRCustomRule(type, rulename, rule) Add a custom ABR Rule Rule will be apply on next stream if a stream is being played Parameters: Name Type Description type string rule type (one of ['qualitySwitchRules','abandonFragmentRules']) rulename string name of rule (used to identify custom rule). If one rule of same name has been added, then existing rule will be updated rule object the rule object instance Source: streaming/MediaPlayer.js, line 961 Throws: BAD_ARGUMENT_ERROR if called with invalid arguments. addUTCTimingSource(schemeIdUri, value) Allows you to set a scheme and server source for UTC live edge detection for dynamic streams. If UTCTiming is defined in the manifest, it will take precedence over any time source manually added. If you have exposed the Date header, use the method clearDefaultUTCTimingSources(). This will allow the date header on the manifest to be used instead of a time server Parameters: Name Type Description schemeIdUri string urn:mpeg:dash:utc:http-head:2014 urn:mpeg:dash:utc:http-xsdate:2014 urn:mpeg:dash:utc:http-iso:2014 urn:mpeg:dash:utc:direct:2014 Some specs referencing early ISO23009-1 drafts incorrectly use 2012 in the URI, rather than 2014. support these for now. urn:mpeg:dash:utc:http-head:2012 urn:mpeg:dash:utc:http-xsdate:2012 urn:mpeg:dash:utc:http-iso:2012 urn:mpeg:dash:utc:direct:2012 value string Path to a time source. Default Value: schemeIdUri:urn:mpeg:dash:utc:http-xsdate:2014 value:http://time.akamai.com/?iso&amp;ms/li&gt; Source: streaming/MediaPlayer.js, line 1014 See: removeUTCTimingSource() attachProtectionController(value) Will override dash.js protection controller. Parameters: Name Type Description value ProtectionController valid protection controller instance. Source: streaming/MediaPlayer.js, line 1631 attachSource(urlOrManifest) Use this method to set a source URL to a valid MPD manifest file OR a previously downloaded and parsed manifest object. Optionally, can also provide protection information Parameters: Name Type Description urlOrManifest string | Object A URL to a valid MPD manifest file, or a parsed manifest object. Source: streaming/MediaPlayer.js, line 1761 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function attachTTMLRenderingDiv(div) Use this method to attach an HTML5 div for dash.js to render rich TTML subtitles. Parameters: Name Type Description div HTMLDivElement An unstyled div placed after the video element. It will be styled to match the video size and overlay z-order. Source: streaming/MediaPlayer.js, line 1377 Throws: ELEMENT_NOT_ATTACHED_ERROR if called before attachView function attachView(element) Use this method to attach an HTML5 VideoElement for dash.js to operate upon. Parameters: Name Type Description element Object An HTMLMediaElement that has already been defined in the DOM (or equivalent stub). Source: streaming/MediaPlayer.js, line 1335 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function clearDefaultUTCTimingSources() Allows you to clear the stored array of time sources. Example use: If you have exposed the Date header, calling this method will allow the date header on the manifest to be used instead of the time server. Example use: Calling this method, assuming there is not an exposed date header on the manifest, will default back to using a binary search to discover the live edge Source: streaming/MediaPlayer.js, line 1043 See: restoreDefaultUTCTimingSources() convertToTimeCode(value) A utility method which converts seconds into TimeCode (i.e. 300 --&gt; 05:00). Parameters: Name Type Description value number A number in seconds to be converted into a formatted time code. Source: streaming/MediaPlayer.js, line 1853 Returns: A formatted time code string. Type string displayCaptionsOnTop(value) This method serves to control captions z-index value. If 'true' is passed, the captions will have the highest z-index and be displayed on top of other html elements. Default value is 'false' (z-index is not set). Parameters: Name Type Description value boolean Source: streaming/MediaPlayer.js, line 1296 duration() Duration of the media's playback, in seconds. Source: streaming/MediaPlayer.js, line 748 Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: The current duration of the media. Type number durationAsUTC() Use this method to get the current duration as an absolute value, the time in seconds since midnight UTC, Jan 1 1970. Note - this property only has meaning for live streams. Source: streaming/MediaPlayer.js, line 797 Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: The current duration as UTC timestamp. Type number enableForcedTextStreaming(enable) Enable/disable text When enabling dash will keep downloading and process fragmented text tracks even if all tracks are in mode \"hidden\" Parameters: Name Type Description enable boolean true to enable text streaming even if all text tracks are hidden. Source: streaming/MediaPlayer.js, line 1237 enableText(enable) Enable/disable text When enabling text, dash will choose the previous selected text track Parameters: Name Type Description enable boolean true to enable text, false otherwise (same as setTextTrack(-1)) Source: streaming/MediaPlayer.js, line 1221 extend(parentNameString, childInstance, override) This method should be used to extend or replace internal dash.js objects. There are two ways to extend dash.js (determined by the override argument): If you set override to true any public method or property in your custom object will override the dash.js parent object's property(ies) and will be used instead but the dash.js parent module will still be created. If you set override to false your object will completely replace the dash.js object. (Note: This is how it was in 1.x of Dash.js with Dijon). When you extend you get access to this.context, this.factory and this.parent to operate with in your custom object. this.context - can be used to pass context for singleton access. this.factory - can be used to call factory.getSingletonInstance(). this.parent - is the reference of the parent object to call other public methods. (this.parent is excluded if you extend with override set to false or option 2) You must call extend before you call initialize Parameters: Name Type Description parentNameString string name of parent module childInstance Object overriding object override boolean replace only some methods (true) or the whole object (false) Source: streaming/MediaPlayer.js, line 1887 See: initialize() formatUTC(time, locales, hour12, withDate) A utility methods which converts UTC timestamp value into a valid time and date string. Parameters: Name Type Default Description time number UTC timestamp to be converted into date and time. locales string a region identifier (i.e. en_US). hour12 boolean 12 vs 24 hour. Set to true for 12 hour time formatting. withDate boolean false default is false. Set to true to append current date to UTC time format. Source: streaming/MediaPlayer.js, line 1836 Returns: A formatted time and date string. Type string getActiveStream() This method returns the active stream Source: streaming/MediaPlayer.js, line 1898 Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function getAutoPlay() Source: streaming/MediaPlayer.js, line 928 Returns: The current autoPlay state. Type boolean getAverageThroughput(type) Returns the average throughput computed in the ABR logic Parameters: Name Type Description type MediaType Source: streaming/MediaPlayer.js, line 1072 Returns: value Type number getBitrateInfoListFor(type) Parameters: Name Type Description type MediaType Source: streaming/MediaPlayer.js, line 1398 Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: Type Array getBufferLength(type) The length of the buffer for a given media type, in seconds. Valid media types are \"video\", \"audio\" and \"fragmentedText\". If no type is passed in, then the minimum of video, audio and fragmentedText buffer length is returned. NaN is returned if an invalid type is requested, the presentation does not contain that type, or if no arguments are passed and the presentation does not include any adaption sets of valid media type. Parameters: Name Type Description type MediaType 'video', 'audio' or 'fragmentedText' Source: streaming/MediaPlayer.js, line 649 Returns: The length of the buffer for the given media type, in seconds, or NaN Type number getCurrentLiveLatency() Source: streaming/MediaPlayer.js, line 938 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function Returns: Current live stream latency in seconds. It is the difference between current time and time position at the playback head. Type number | NaN getCurrentTrackFor(type) Parameters: Name Type Description type MediaType Source: streaming/MediaPlayer.js, line 1465 Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: MediaInfo Type Object | null getDashAdapter() Returns the DashAdapter.js Module. Source: streaming/MediaPlayer.js, line 2213 See: module:DashAdapter Returns: Type Object getDashMetrics() Returns the DashMetrics.js Module. You use this Module to get access to all the public metrics stored in dash.js Source: streaming/MediaPlayer.js, line 1137 See: module:DashMetrics Returns: Type Object getDebug() Use this method to access the dash.js logging class. Source: streaming/MediaPlayer.js, line 434 Returns: Type Debug getDVRSeekOffset(value) This method should only be used with a live stream that has a valid timeShiftBufferLength (DVR Window). NOTE - If you do not need the raw offset value (i.e. media analytics, tracking, etc) consider using the seek() method which will calculate this value for you and set the video element's currentTime property all in one simple call. Parameters: Name Type Description value number A relative time, in seconds, based on the return value of the duration() method is expected. Source: streaming/MediaPlayer.js, line 695 See: seek() Returns: A value that is relative the available range within the timeShiftBufferLength (DVR Window). Type number getDVRWindowSize() The timeShiftBufferLength (DVR Window), in seconds. Source: streaming/MediaPlayer.js, line 676 Returns: The window of allowable play time behind the live point of a live stream. Type number getInitialMediaSettingsFor(type) This method returns media settings that is used to pick the initial track. Format of the settings is following: {lang: langValue, viewpoint: viewpointValue, audioChannelConfiguration: audioChannelConfigurationValue, accessibility: accessibilityValue, role: roleValue} Parameters: Name Type Description type MediaType Source: streaming/MediaPlayer.js, line 1512 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function Returns: Type Object getOfflineController() Detects if Offline is included and returns an instance of OfflineController.js Source: streaming/MediaPlayer.js, line 1117 getPlaybackRate() Returns the current playback rate. Source: streaming/MediaPlayer.js, line 584 Returns: Type number getProtectionController() Detects if Protection is included and returns an instance of ProtectionController.js Source: streaming/MediaPlayer.js, line 1621 getQualityFor(type) Gets the current download quality for media type video, audio or images. For video and audio types the ABR rules update this value before every new download unless setAutoSwitchQualityFor(type, false) is called. For 'image' type, thumbnails, there is no ABR algorithm and quality is set manually. Parameters: Name Type Description type MediaType 'video', 'audio' or 'image' (thumbnails) Source: streaming/MediaPlayer.js, line 841 See: setAutoSwitchQualityFor() setQualityFor() Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: the quality index, 0 corresponding to the lowest bitrate Type number getSelectionModeForInitialTrack() This method returns the track selection mode. Source: streaming/MediaPlayer.js, line 1601 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function Returns: mode Type string getSettings() Get the current settings object being used on the player. Source: streaming/MediaPlayer.js, line 1788 Returns: The settings object being used. Type PlayerSettings getSource() Returns the source string or manifest that was attached by calling attachSource() Source: streaming/MediaPlayer.js, line 1740 Throws: SOURCE_NOT_ATTACHED_ERROR if called before attachSource function Returns: Type string | manifest getStreamsFromManifest(manifest) This method returns the list of all available streams from a given manifest Parameters: Name Type Description manifest Object Source: streaming/MediaPlayer.js, line 1414 Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: list of StreamInfo Type Array getTextDefaultEnabled() Get enabled default state. Source: streaming/MediaPlayer.js, line 1205 Returns: default enable state Type boolean getTextDefaultLanguage() Get default language for text. Deprecated: will be removed in version 3.2.0. Please use getInitialMediaSettingsFor(\"fragmentedText\").lang instead Source: streaming/MediaPlayer.js, line 1172 Returns: the default language if it has been set using setTextDefaultLanguage Type string getTopBitrateInfoFor(type) Gets the top quality BitrateInfo checking portal limit and max allowed. It calls getTopQualityIndexFor internally Parameters: Name Type Description type MediaType 'video' or 'audio' Source: streaming/MediaPlayer.js, line 821 Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: Type BitrateInfo | null getTracksFor(type) This method returns the list of all available tracks for a given media type Parameters: Name Type Description type MediaType Source: streaming/MediaPlayer.js, line 1429 Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: list of MediaInfo Type Array getTracksForTypeFromManifest(type, manifest, streamInfo) This method returns the list of all available tracks for a given media type and streamInfo from a given manifest Parameters: Name Type Description type MediaType manifest Object streamInfo Object Source: streaming/MediaPlayer.js, line 1447 Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: list of MediaInfo Type Array getTrackSwitchModeFor(type) This method returns the current track switch mode. Parameters: Name Type Description type MediaType Source: streaming/MediaPlayer.js, line 1541 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function Returns: mode Type string getTTMLRenderingDiv() Returns instance of Div that was attached by calling attachTTMLRenderingDiv() Source: streaming/MediaPlayer.js, line 1365 Returns: Type Object getVersion() Current version of Dash.js Source: streaming/MediaPlayer.js, line 423 Returns: the current dash.js version string. Type string getVideoElement() Returns instance of Video Element that was attached by calling attachView() Source: streaming/MediaPlayer.js, line 1320 Throws: ELEMENT_NOT_ATTACHED_ERROR if called before attachView function Returns: Type Object getVolume() Returns the current audio volume, from 0.0 (silent) to 1.0 (loudest). Source: streaming/MediaPlayer.js, line 630 Returns: Type number getXHRWithCredentialsForType(type) Gets whether withCredentials on XHR requests for a particular request type is true or false Parameters: Name Type Description type string one of HTTPRequest.*_TYPE Source: streaming/MediaPlayer.js, line 1100 Returns: Type boolean initialize( [view] [, source] [, AutoPlay]) Upon creating the MediaPlayer you must call initialize before you call anything else. There is one exception to this rule. It is crucial to call extend() with all your extensions prior to calling initialize. ALL arguments are optional and there are individual methods to set each argument later on. The args in this method are just for convenience and should only be used for a simple player setup. Parameters: Name Type Argument Description view HTML5MediaElement &lt;optional&gt; Optional arg to set the video element. attachView() source string &lt;optional&gt; Optional arg to set the media source. attachSource() AutoPlay boolean &lt;optional&gt; Optional arg to set auto play. setAutoPlay() Source: streaming/MediaPlayer.js, line 241 See: attachView() attachSource() setAutoPlay() isDynamic() Returns a Boolean that indicates whether the media is in the process of dynamic. Source: streaming/MediaPlayer.js, line 561 Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: Type boolean isMuted() A Boolean that determines whether audio is muted. Source: streaming/MediaPlayer.js, line 606 Returns: Type boolean isPaused() Returns a Boolean that indicates whether the Video Element is paused. Source: streaming/MediaPlayer.js, line 507 Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: Type boolean isReady() The ready state of the MediaPlayer based on both the video element and MPD source being defined. Source: streaming/MediaPlayer.js, line 387 See: attachView() attachSource() Returns: The current ready state of the MediaPlayer Type boolean isSeeking() Returns a Boolean that indicates whether the media is in the process of seeking to a new position. Source: streaming/MediaPlayer.js, line 547 Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: Type boolean isTextEnabled() Return if text is enabled Source: streaming/MediaPlayer.js, line 1252 Returns: return true if text is enabled, false otherwise Type boolean off(type, listener, scope) Use the off method to remove listeners for public events found in MediaPlayer.events. MediaPlayerEvents Parameters: Name Type Description type string MediaPlayerEvents listener function callback method when the event fires. scope Object context of the listener so it can be removed properly. Source: streaming/MediaPlayer.js, line 413 on(type, listener, scope) Use the on method to listen for public events found in MediaPlayer.events. MediaPlayerEvents Parameters: Name Type Description type string MediaPlayerEvents listener function callback method when the event fires. scope Object context of the listener so it can be removed properly. Source: streaming/MediaPlayer.js, line 400 pause() This method will call pause on the native Video Element. Source: streaming/MediaPlayer.js, line 493 Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function play() The play method initiates playback of the media defined by the attachSource() method. This method will call play on the native Video Element. Source: streaming/MediaPlayer.js, line 477 See: attachSource() Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function preload() Causes the player to begin streaming the media as set by the attachSource() method in preparation for playing. It specifically does not require a view to be attached with attachView() to begin preloading. When a view is attached after preloading, the buffered data is transferred to the attached mediaSource buffers. Source: streaming/MediaPlayer.js, line 457 See: attachSource() attachView() Throws: SOURCE_NOT_ATTACHED_ERROR if called before attachSource function provideThumbnail(time, callback) Provide the thumbnail at time position. This can be asynchronous, so you must provide a callback ro retrieve thumbnails informations Parameters: Name Type Description time number A relative time, in seconds, based on the return value of the duration() method is expected callback function A Callback function provided when retrieving thumbnail the given time position. Thumbnail object is null in case there are is not a thumbnails representation or if it doesn't contain a thumbnail for the given time position. Source: streaming/MediaPlayer.js, line 1671 removeABRCustomRule(rulename) Remove a custom ABR Rule Parameters: Name Type Description rulename string name of the rule to be removed Source: streaming/MediaPlayer.js, line 972 removeAllABRCustomRule() Remove all custom rules Source: streaming/MediaPlayer.js, line 981 removeUTCTimingSource(schemeIdUri, value) Allows you to remove a UTC time source. Both schemeIdUri and value need to match the Dash.vo.UTCTiming properties in order for the entry to be removed from the array Parameters: Name Type Description schemeIdUri string see addUTCTimingSource() value string see addUTCTimingSource() Source: streaming/MediaPlayer.js, line 1028 See: clearDefaultUTCTimingSources() Throws: BAD_ARGUMENT_ERROR if called with invalid arguments, schemeIdUri and value are not string type. reset() Sets the MPD source and the video element to null. You can also reset the MediaPlayer by calling attachSource with a new source file. Calling this method is all that is necessary to destroy a MediaPlayer instance. Source: streaming/MediaPlayer.js, line 355 resetSettings() Resets the settings object back to the default. Source: streaming/MediaPlayer.js, line 1821 restoreDefaultUTCTimingSources() Allows you to restore the default time sources after calling clearDefaultUTCTimingSources() Default Value: schemeIdUri:urn:mpeg:dash:utc:http-xsdate:2014 value:http://time.akamai.com/?iso&amp;ms Source: streaming/MediaPlayer.js, line 1060 See: addUTCTimingSource() retrieveManifest(url, callback) Allows application to retrieve a manifest. Manifest loading is asynchro nous and requires the app-provided callback function Parameters: Name Type Description url string url the manifest url callback function A Callback function provided when retrieving manifests Source: streaming/MediaPlayer.js, line 1713 seek(value) Sets the currentTime property of the attached video element. If it is a live stream with a timeShiftBufferLength, then the DVR window offset will be automatically calculated. Parameters: Name Type Description value number A relative time, in seconds, based on the return value of the duration() method is expected Source: streaming/MediaPlayer.js, line 525 See: getDVRSeekOffset() Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function BAD_ARGUMENT_ERROR if called with an invalid argument, not number type or is NaN. setAutoPlay(value) Set to false to prevent stream from auto-playing when the view is attached. Parameters: Name Type Description value boolean Default Value: true Source: streaming/MediaPlayer.js, line 918 See: attachView() Throws: BAD_ARGUMENT_ERROR if called with an invalid argument, not boolean type. setConfig( [config]) Configure media player with customs controllers. Helpful for tests Parameters: Name Type Argument Description config object &lt;optional&gt; controllers configuration Source: streaming/MediaPlayer.js, line 191 setCurrentTrack(track) Parameters: Name Type Description track MediaInfo instance of MediaInfo Source: streaming/MediaPlayer.js, line 1525 Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function setInitialMediaSettingsFor(type, value) This method allows to set media settings that will be used to pick the initial track. Format of the settings is following: {lang: langValue (can be either a string or a regex to match), viewpoint: viewpointValue, audioChannelConfiguration: audioChannelConfigurationValue, accessibility: accessibilityValue, role: roleValue} Parameters: Name Type Description type MediaType value Object Source: streaming/MediaPlayer.js, line 1488 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function setMute(value) Use this method to set the native Video Element's muted state. Takes a Boolean that determines whether audio is muted. true if the audio is muted and false otherwise. Parameters: Name Type Description value boolean Source: streaming/MediaPlayer.js, line 595 Throws: BAD_ARGUMENT_ERROR if called with an invalid argument, not boolean type. setPlaybackRate(value) Use this method to set the native Video Element's playback rate. Parameters: Name Type Description value number Source: streaming/MediaPlayer.js, line 574 setProtectionData(value) Sets Protection Data required to setup the Protection Module (DRM). Protection Data must be set before initializing MediaPlayer or, once initialized, before PROTECTION_CREATED event is fired. Parameters: Name Type Description value ProtectionDataSet object containing property names corresponding to key system name strings and associated values being instances of. Source: streaming/MediaPlayer.js, line 1646 See: initialize() dashjs.Protection.events.PROTECTION_CREATED setQualityFor(type, value) Sets the current quality for media type instead of letting the ABR Heuristics automatically selecting it. This value will be overwritten by the ABR rules unless setAutoSwitchQualityFor(type, false) is called. Parameters: Name Type Description type MediaType 'video', 'audio' or 'image' value number the quality index, 0 corresponding to the lowest bitrate Source: streaming/MediaPlayer.js, line 869 See: setAutoSwitchQualityFor() getQualityFor() Throws: STREAMING_NOT_INITIALIZED_ERROR if called before initializePlayback function setSelectionModeForInitialTrack(mode) This method sets the selection mode for the initial track. This mode defines how the initial track will be selected if no initial media settings are set. If initial media settings are set this parameter will be ignored. Available options are: MediaController.TRACK_SELECTION_MODE_HIGHEST_BITRATE this mode makes the player select the track with a highest bitrate. This mode is a default mode. MediaController.TRACK_SELECTION_MODE_WIDEST_RANGE this mode makes the player select the track with a widest range of bitrates Parameters: Name Type Description mode string Source: streaming/MediaPlayer.js, line 1586 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function setTextDefaultEnabled(enable) Set enabled default state. This is used to enable/disable text when a file is loaded. During playback, use enableText to enable text for the file Parameters: Name Type Description enable boolean true to enable text, false otherwise Source: streaming/MediaPlayer.js, line 1190 setTextDefaultLanguage(lang) Set default language for text. If default language is not one of text tracks, dash will choose the first one. Parameters: Name Type Description lang string default language Deprecated: will be removed in version 3.2.0. Please use setInitialMediaSettingsFor(\"fragmentedText\", { lang: lang }) instead Source: streaming/MediaPlayer.js, line 1156 setTextTrack(idx) Use this method to change the current text track for both external time text files and fragmented text tracks. There is no need to set the track mode on the video object to switch a track when using this method. Parameters: Name Type Description idx number Index of track based on the order of the order the tracks are added Use -1 to disable all tracks. (turn captions off). Use module:MediaPlayer#dashjs.MediaPlayer.events.TEXT_TRACK_ADDED. Source: streaming/MediaPlayer.js, line 1269 See: dashjs.MediaPlayer.events.TEXT_TRACK_ADDED Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function setTrackSwitchModeFor(type, mode) This method sets the current track switch mode. Available options are: MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE (used to forbid clearing the buffered data (prior to current playback position) after track switch. Defers to fastSwitchEnabled for placement of new data. Default for video) MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE (used to clear the buffered data (prior to current playback position) after track switch. Default for audio) Parameters: Name Type Description type MediaType mode string Source: streaming/MediaPlayer.js, line 1564 Throws: MEDIA_PLAYER_NOT_INITIALIZED_ERROR if called before initialize function setVolume(value) A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest). Parameters: Name Type Description value number Source: streaming/MediaPlayer.js, line 617 Throws: BAD_ARGUMENT_ERROR if called with an invalid argument, not number type, or is NaN or not between 0 and 1. setXHRWithCredentialsForType(type, value) Sets whether withCredentials on XHR requests for a particular request type is true or false Parameters: Name Type Description type string one of HTTPRequest.*_TYPE value boolean Default Value: false Source: streaming/MediaPlayer.js, line 1087 time(streamId) Current time of the playhead, in seconds. If called with no arguments then the returned time value is time elapsed since the start point of the first stream, or if it is a live stream, then the time will be based on the return value of the duration() method. However if a stream ID is supplied then time is relative to the start of that stream, or is null if there is no such stream id in the manifest. Parameters: Name Type Description streamId string The ID of a stream that the returned playhead time must be relative to the start of. If undefined, then playhead time is relative to the first stream. Source: streaming/MediaPlayer.js, line 724 Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: The current playhead time of the media, or null. Type number timeAsUTC() Use this method to get the current playhead time as an absolute value, the time in seconds since midnight UTC, Jan 1 1970. Note - this property only has meaning for live streams. If called before play() has begun, it will return a value of NaN. Source: streaming/MediaPlayer.js, line 778 Throws: PLAYBACK_NOT_INITIALIZED_ERROR if called before initializePlayback function Returns: The current playhead time as UTC timestamp. Type number updatePortalSize() Update the video element size variables Should be called on window resize (or any other time player is resized). Fullscreen does trigger a window resize event. Once windowResizeEventCalled = true, abrController.checkPortalSize() will use element size variables rather than querying clientWidth every time. Source: streaming/MediaPlayer.js, line 895 updateSettings(settingsObj) Update the current settings object being used on the player. Anything left unspecified is not modified. This function does not update the entire object, only properties in the passed in object are updated. This means that updateSettings({a: x}) and updateSettings({b: y}) are functionally equivalent to updateSettings({a: x, b: y}). If the default values are required again, @seeresetSettings. Parameters: Name Type Description settingsObj PlayerSettings An object corresponding to the settings definition. Source: streaming/MediaPlayer.js, line 1811 Example player.updateSettings({ streaming: { liveDelayFragmentCount: 8 abr: { maxBitrate: { audio: 100, video: 1000 } } } }); × Search results Close "},"module-OfflineController.html":{"id":"module-OfflineController.html","title":"Module: OfflineController","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Module: OfflineController Provides access to offline stream recording and playback functionality. Source: offline/controllers/OfflineController.js, line 41 Methods &lt;static&gt; loadRecordsFromStorage() Loads records from storage This methods has to be called first, to be sure that all downloads have been loaded Source: offline/controllers/OfflineController.js, line 208 Returns: asynchronously resolved Type Promise createRecord(manifestURL) Create a new content record in storage and download manifest from url Parameters: Name Type Description manifestURL string the content manifest url Source: offline/controllers/OfflineController.js, line 252 Returns: asynchronously resolved with record identifier Type Promise deleteRecord(id) Deletes a record from storage Parameters: Name Type Description id string record identifier Source: offline/controllers/OfflineController.js, line 322 getAllRecords() Get all records from storage Source: offline/controllers/OfflineController.js, line 230 Returns: asynchronously resolved with records Type Promise getRecordProgression(id) Get download progression of a record Parameters: Name Type Description id string record identifier Source: offline/controllers/OfflineController.js, line 337 Returns: percentage progression Type number resetRecords() Reset all records Source: offline/controllers/OfflineController.js, line 350 resumeRecord(id) Resume downloading of the record Parameters: Name Type Description id string record identifier Source: offline/controllers/OfflineController.js, line 308 startRecord(id, mediaInfos) Start downloading the record with selected tracks representations Parameters: Name Type Description id string record identifier mediaInfos Array.&lt;MediaInfo&gt; the selected tracks representations Source: offline/controllers/OfflineController.js, line 280 stopRecord(id) Stop downloading of the record Parameters: Name Type Description id string record identifier Source: offline/controllers/OfflineController.js, line 294 × Search results Close "},"module-ProtectionController.html":{"id":"module-ProtectionController.html","title":"Module: ProtectionController","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Module: ProtectionController Provides access to media protection information and functionality. Each ProtectionController manages a single MediaPlayer.models.ProtectionModel which encapsulates a set of protection information (EME APIs, selected key system, key sessions). The APIs of ProtectionController mostly align with the latest EME APIs. Key system selection is mostly automated when combined with app-overrideable functionality provided in ProtectionKeyController. Source: streaming/protection/controllers/ProtectionController.js, line 45 To Do: ProtectionController does almost all of its tasks automatically after init() is called. Applications might want more control over this process and want to go through each step manually (key system selection, session creation, session maintenance). Methods setMediaElement(element) Associate this protection system with the given HTMLMediaElement. This causes the system to register for needkey/encrypted events from the given element and provides a destination for setting of MediaKeys Parameters: Name Type Description element HTMLMediaElement the media element to which the protection system should be associated Source: streaming/protection/controllers/ProtectionController.js, line 272 setRobustnessLevel(level) Sets the robustness level for video and audio capabilities. Optional to remove Chrome warnings. Possible values are SW_SECURE_CRYPTO, SW_SECURE_DECODE, HW_SECURE_CRYPTO, HW_SECURE_CRYPTO, HW_SECURE_DECODE, HW_SECURE_ALL. Parameters: Name Type Description level string the robustness level Source: streaming/protection/controllers/ProtectionController.js, line 303 setServerCertificate(serverCertificate) Sets a server certificate for use by the CDM when signing key messages intended for a particular license server. This will fire an error event if a key system has not yet been selected. Parameters: Name Type Description serverCertificate ArrayBuffer a CDM-specific license server certificate Source: streaming/protection/controllers/ProtectionController.js, line 257 Fires: ProtectionController#event:ServerCertificateUpdated setSessionType(value) Sets the session type to use when creating key sessions. Either \"temporary\" or \"persistent-license\". Default is \"temporary\". Parameters: Name Type Description value string the session type Source: streaming/protection/controllers/ProtectionController.js, line 291 stop() Stop method is called when current playback is stopped/resetted. Source: streaming/protection/controllers/ProtectionController.js, line 328 × Search results Close "},"module-Settings.html":{"id":"module-Settings.html","title":"Module: Settings","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Module: Settings Define the configuration parameters of Dash.js MediaPlayer. Source: core/Settings.js, line 37 See: PlayerSettings for further information about the supported configuration properties Type Definitions AbrSettings Type: Object Properties: Name Type Argument Default Description movingAverageMethod string &lt;optional&gt; \"slidingWindow\" Sets the moving average method used for smoothing throughput estimates. Valid methods are \"slidingWindow\" and \"ewma\". The call has no effect if an invalid method is passed. The sliding window moving average method computes the average throughput using the last four segments downloaded. If the stream is live (as opposed to VOD), then only the last three segments are used. If wide variations in throughput are detected, the number of segments can be dynamically increased to avoid oscillations. The exponentially weighted moving average (EWMA) method computes the average using exponential smoothing. Two separate estimates are maintained, a fast one with a three-second half life and a slow one with an eight-second half life. The throughput estimate at any time is the minimum of the fast and slow estimates. This allows a fast reaction to a bandwidth drop and prevents oscillations on bandwidth spikes. ABRStrategy string &lt;optional&gt; \"abrDynamic\" Returns the current ABR strategy being used: \"abrDynamic\", \"abrBola\" or \"abrThroughput\". bandwidthSafetyFactor number &lt;optional&gt; 0.9 Standard ABR throughput rules multiply the throughput by this value. It should be between 0 and 1, with lower values giving less rebuffering (but also lower quality). useDefaultABRRules boolean &lt;optional&gt; true Should the default ABR rules be used, or the custom ones added. useBufferOccupancyABR boolean &lt;optional&gt; false Whether to use the BOLA abr rule. useDeadTimeLatency boolean &lt;optional&gt; true If true, only the download portion will be considered part of the download bitrate and latency will be regarded as static. If false, the reciprocal of the whole transfer time will be used. limitBitrateByPortal boolean &lt;optional&gt; false If true, the size of the video portal will limit the max chosen video resolution. usePixelRatioInLimitBitrateByPortal boolean &lt;optional&gt; false Sets whether to take into account the device's pixel ratio when defining the portal dimensions. Useful on, for example, retina displays. maxBitrate module:Settings~AudioVideoSettings &lt;optional&gt; {audio: -1, video: -1} The maximum bitrate that the ABR algorithms will choose. Use NaN for no limit. minBitrate module:Settings~AudioVideoSettings &lt;optional&gt; {audio: -1, video: -1} The minimum bitrate that the ABR algorithms will choose. Use NaN for no limit. maxRepresentationRatio module:Settings~AudioVideoSettings &lt;optional&gt; {audio: 1, video: 1} When switching multi-bitrate content (auto or manual mode) this property specifies the maximum representation allowed, as a proportion of the size of the representation set. You can set or remove this cap at anytime before or during playback. To clear this setting you set the value to 1. If both this and maxAllowedBitrate are defined, maxAllowedBitrate is evaluated first, then maxAllowedRepresentation, i.e. the lowest value from executing these rules is used. This feature is typically used to reserve higher representations for playback only when connected over a fast connection. initialBitrate module:Settings~AudioVideoSettings &lt;optional&gt; {audio: -1, video: -1} Explicitly set the starting bitrate for audio or video initialRepresentationRatio module:Settings~AudioVideoSettings &lt;optional&gt; {audio: -1, video: -1} Explicitly set the initial representation ratio. If initalBitrate is specified, this is ignored. autoSwitchBitrate module:Settings~AudioVideoSettings &lt;optional&gt; {audio: true, video: true} Indicates whether the player should enable ABR algorithms to switch the bitrate. Source: core/Settings.js, line 158 AudioVideoSettings Type: Object Properties: Name Type Argument Description audio number | boolean &lt;optional&gt; Configuration for audio media type of tracks. video number | boolean &lt;optional&gt; Configuration for video media type of tracks. Source: core/Settings.js, line 346 CachingInfoSettings Type: Object Properties: Name Type Argument Description enable boolean &lt;optional&gt; Enable or disable the caching feature. ttl number &lt;optional&gt; Time to live. A value defined in milliseconds representing how log to cache the settings for. Source: core/Settings.js, line 340 CmcdSettings Type: Object Properties: Name Type Argument Default Description enable boolean &lt;optional&gt; false Enable or disable the CMCD reporting. sid string &lt;optional&gt; GUID identifying the current playback session. Should be in UUID format. If not specified a UUID will be automatically generated. cid string &lt;optional&gt; A unique string to identify the current content. If not specified it will be a hash of the MPD url. did string &lt;optional&gt; dash.js-cmcd-default-id A unique string identifying the current device. Source: core/Settings.js, line 364 DebugSettings Type: Object Properties: Name Type Argument Default Description logLevel number &lt;optional&gt; dashjs.Debug.LOG_LEVEL_WARNING Sets up the log level. The levels are cumulative. For example, if you set the log level to dashjs.Debug.LOG_LEVEL_WARNING all warnings, errors and fatals will be logged. Possible values. dashjs.Debug.LOG_LEVEL_NONE No message is written in the browser console. dashjs.Debug.LOG_LEVEL_FATAL Log fatal errors. An error is considered fatal when it causes playback to fail completely. dashjs.Debug.LOG_LEVEL_ERROR Log error messages. dashjs.Debug.LOG_LEVEL_WARNING Log warning messages. dashjs.Debug.LOG_LEVEL_INFO Log info messages. dashjs.Debug.LOG_LEVEL_DEBUG Log debug messages. Source: core/Settings.js, line 131 PlayerSettings Type: Object Properties: Name Type Argument Description debug module:Settings~DebugSettings &lt;optional&gt; Debug related settings streaming module:Settings~StreamingSettings &lt;optional&gt; Streaming related settings Source: core/Settings.js, line 43 Example // Full settings object settings = { debug: { logLevel: Debug.LOG_LEVEL_WARNING }, streaming: { metricsMaxListDepth: 1000, abandonLoadTimeout: 10000, liveDelayFragmentCount: NaN, liveDelay: null, scheduleWhilePaused: true, fastSwitchEnabled: false, flushBufferAtTrackSwitch: false, bufferPruningInterval: 10, bufferToKeep: 20, jumpGaps: true, jumpLargeGaps: true, smallGapLimit: 1.5, stableBufferTime: 12, bufferTimeAtTopQuality: 30, bufferTimeAtTopQualityLongForm: 60, longFormContentDurationThreshold: 600, wallclockTimeUpdateInterval: 50, lowLatencyEnabled: false, keepProtectionMediaKeys: false, useManifestDateHeaderTimeSource: true, useSuggestedPresentationDelay: true, useAppendWindow: true, manifestUpdateRetryInterval: 100, liveCatchUpMinDrift: 0.02, liveCatchUpMaxDrift: 0, liveCatchUpPlaybackRate: 0.5, lastBitrateCachingInfo: { enabled: true, ttl: 360000 }, lastMediaSettingsCachingInfo: { enabled: true, ttl: 360000 }, cacheLoadThresholds: { video: 50, audio: 5 }, retryIntervals: { MPD: 500, XLinkExpansion: 500, InitializationSegment: 1000, IndexSegment: 1000, MediaSegment: 1000, BitstreamSwitchingSegment: 1000, other: 1000, lowLatencyReductionFactor: 10 }, retryAttempts: { MPD: 3, XLinkExpansion: 1, InitializationSegment: 3, IndexSegment: 3, MediaSegment: 3, BitstreamSwitchingSegment: 3, other: 3, lowLatencyMultiplyFactor: 5 }, abr: { movingAverageMethod: Constants.MOVING_AVERAGE_SLIDING_WINDOW, ABRStrategy: Constants.ABR_STRATEGY_DYNAMIC, bandwidthSafetyFactor: 0.9, useDefaultABRRules: true, useBufferOccupancyABR: false, useDeadTimeLatency: true, limitBitrateByPortal: false, usePixelRatioInLimitBitrateByPortal: false, maxBitrate: { audio: -1, video: -1 }, minBitrate: { audio: -1, video: -1 }, maxRepresentationRatio: { audio: 1, video: 1 }, initialBitrate: { audio: -1, video: -1 }, initialRepresentationRatio: { audio: -1, video: -1 }, autoSwitchBitrate: { audio: true, video: true } }, cmcd: { enabled: false, sid: null, cid: null, did: null } } } RequestTypeSettings Type: Object Properties: Name Type Argument Description MPD number &lt;optional&gt; Manifest type of requests XLinkExpansion number &lt;optional&gt; XLink expansion type of requests InitializationSegment number &lt;optional&gt; Request to retrieve an initialization segment IndexSegment number &lt;optional&gt; Request to retrieve an index segment (SegmentBase) MediaSegment number &lt;optional&gt; Request to retrieve a media segment (video/audio/image/text chunk) BitstreamSwitchingSegment number &lt;optional&gt; Bitrate stream switching type of request other number &lt;optional&gt; Other type of request Source: core/Settings.js, line 352 StreamingSettings Type: Object Properties: Name Type Argument Default Description metricsMaxListDepth number &lt;optional&gt; 1000 Maximum list depth of metrics. abandonLoadTimeout number &lt;optional&gt; 10000 A timeout value in seconds, which during the ABRController will block switch-up events. This will only take effect after an abandoned fragment event occurs. liveDelayFragmentCount number &lt;optional&gt; NaN Changing this value will lower or increase live stream latency. The detected segment duration will be multiplied by this value to define a time in seconds to delay a live stream from the live edge. Lowering this value will lower latency but may decrease the player's ability to build a stable buffer. liveDelay number &lt;optional&gt; Equivalent in seconds of setLiveDelayFragmentCount Lowering this value will lower latency but may decrease the player's ability to build a stable buffer. This value should be less than the manifest duration by a couple of segment durations to avoid playback issues If set, this parameter will take precedence over setLiveDelayFragmentCount and manifest info scheduleWhilePaused boolean &lt;optional&gt; true Set to true if you would like dash.js to keep downloading fragments in the background when the video element is paused. fastSwitchEnabled boolean &lt;optional&gt; false When enabled, after an ABR up-switch in quality, instead of requesting and appending the next fragment at the end of the current buffer range it is requested and appended closer to the current time When enabled, The maximum time to render a higher quality is current time + (1.5 * fragment duration). Note, When ABR down-switch is detected, we appended the lower quality at the end of the buffer range to preserve the higher quality media for as long as possible. If enabled, it should be noted there are a few cases when the client will not replace inside buffer range but rather just append at the end. 1. When the buffer level is less than one fragment duration 2. The client is in an Abandonment State due to recent fragment abandonment event. Known issues: In IE11 with auto switching off, if a user switches to a quality they can not download in time the fragment may be appended in the same range as the playhead or even in the past, in IE11 it may cause a stutter or stall in playback. flushBufferAtTrackSwitch boolean &lt;optional&gt; false When enabled, after a track switch and in case buffer is being replaced (see MEdiaPlayer.setTrackSwitchModeFor(MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE)), the video element is flushed (seek at current playback time) once a segment of the new track is appended in buffer in order to force video decoder to play new track. This can be required on some devices like GoogleCast devices to make track switching functional. Otherwise track switching will be effective only once after previous buffered track is fully consumed. calcSegmentAvailabilityRangeFromTimeline boolean &lt;optional&gt; true Enable calculation of the DVR window for SegmentTimeline manifests based on the entries in bufferPruningInterval number &lt;optional&gt; 10 The interval of pruning buffer in sconds. bufferToKeep number &lt;optional&gt; 20 This value influences the buffer pruning logic. Allows you to modify the buffer that is kept in source buffer in seconds. 0|-----------bufferToPrune-----------|-----bufferToKeep-----|currentTime| jumpGaps boolean &lt;optional&gt; true Sets whether player should jump small gaps (discontinuities) in the buffer. jumpLargeGaps boolean &lt;optional&gt; true Sets whether player should jump large gaps (discontinuities) in the buffer. smallGapLimit number &lt;optional&gt; 1.8 Time in seconds for a gap to be considered small. stableBufferTime number &lt;optional&gt; 12 The time that the internal buffer target will be set to post startup/seeks (NOT top quality). When the time is set higher than the default you will have to wait longer to see automatic bitrate switches but will have a larger buffer which will increase stability. bufferTimeAtTopQuality number &lt;optional&gt; 30 The time that the internal buffer target will be set to once playing the top quality. If there are multiple bitrates in your adaptation, and the media is playing at the highest bitrate, then we try to build a larger buffer at the top quality to increase stability and to maintain media quality. bufferTimeAtTopQualityLongForm number &lt;optional&gt; 60 The time that the internal buffer target will be set to once playing the top quality for long form content. longFormContentDurationThreshold number &lt;optional&gt; 600 The threshold which defines if the media is considered long form content. This will directly affect the buffer targets when playing back at the top quality. wallclockTimeUpdateInterval number &lt;optional&gt; 50 How frequently the wallclockTimeUpdated internal event is triggered (in milliseconds). lowLatencyEnabled boolean &lt;optional&gt; false Enable or disable low latency mode keepProtectionMediaKeys boolean &lt;optional&gt; false Set the value for the ProtectionController and MediaKeys life cycle. If true, the ProtectionController and then created MediaKeys and MediaKeySessions will be preserved during the MediaPlayer lifetime. useManifestDateHeaderTimeSource boolean &lt;optional&gt; true Allows you to enable the use of the Date Header, if exposed with CORS, as a timing source for live edge detection. The use of the date header will happen only after the other timing source that take precedence fail or are omitted as described. useSuggestedPresentationDelay boolean &lt;optional&gt; true Set to true if you would like to override the default live delay and honor the SuggestedPresentationDelay attribute in by the manifest. useAppendWindow boolean &lt;optional&gt; true Specifies if the appendWindow attributes of the MSE SourceBuffers should be set according to content duration from manifest. manifestUpdateRetryInterval number &lt;optional&gt; 100 For live streams, set the interval-frequency in milliseconds at which dash.js will check if the current manifest is still processed before downloading the next manifest once the minimumUpdatePeriod time has liveCatchUpMinDrift number &lt;optional&gt; 0.02 Use this method to set the minimum latency deviation allowed before activating catch-up mechanism. In low latency mode, when the difference between the measured latency and the target one, as an absolute number, is higher than the one sets with this method, then dash.js increases/decreases playback rate until target latency is reached. LowLatencyMinDrift should be provided in seconds, and it uses values between 0.0 and 0.5. Note: Catch-up mechanism is only applied when playing low latency live streams. liveCatchUpMaxDrift number &lt;optional&gt; 0 Use this method to set the maximum latency deviation allowed before dash.js to do a seeking to live position. In low latency mode, when the difference between the measured latency and the target one, as an absolute number, is higher than the one sets with this method, then dash.js does a seek to live edge position minus the target live delay. LowLatencyMaxDriftBeforeSeeking should be provided in seconds. If 0, then seeking operations won't be used for fixing latency deviations. Note: Catch-up mechanism is only applied when playing low latency live streams. liveCatchUpPlaybackRate number &lt;optional&gt; 0.5 Use this parameter to set the maximum catch up rate, as a percentage, for low latency live streams. In low latency mode, when measured latency is higher/lower than the target one, dash.js increases/decreases playback rate respectively up to (+/-) the percentage defined with this method until target is reached. Valid values for catch up rate are in range 0-0.5 (0-50%). Set it to 0 to turn off live catch up feature. Note: Catch-up mechanism is only applied when playing low latency live streams. liveCatchupLatencyThreshold number &lt;optional&gt; NaN Use this parameter to set the maximum threshold for which live catch up is applied. For instance, if this value is set to 8 seconds, then live catchup is only applied if the current live latency is equal or below 8 seconds. The reason behind this parameter is to avoid an increase of the playback rate if the user seeks within the DVR window. If no value is specified this will be twice the maximum live delay. The maximum live delay is either specified in the manifest as part of a ServiceDescriptor or calculated the following: maximumLiveDelay = targetDelay + liveCatchupMinDrift Note: Catch-up mechanism is only applied when playing low latency live streams. lastBitrateCachingInfo module:Settings~CachingInfoSettings &lt;optional&gt; {enabled: true, ttl: 360000} Set to false if you would like to disable the last known bit rate from being stored during playback and used to set the initial bit rate for subsequent playback within the expiration window. The default expiration is one hour, defined in milliseconds. If expired, the default initial bit rate (closest to 1000 kbps) will be used for that session and a new bit rate will be stored during that session. lastMediaSettingsCachingInfo module:Settings~CachingInfoSettings &lt;optional&gt; {enabled: true, ttl: 360000} Set to false if you would like to disable the last known lang for audio (or camera angle for video) from being stored during playback and used to set the initial settings for subsequent playback within the expiration window. The default expiration is one hour, defined in milliseconds. If expired, the default settings will be used for that session and a new settings will be stored during that session. cacheLoadThresholds module:Settings~AudioVideoSettings &lt;optional&gt; {video: 50, audio: 5} For a given media type, the threshold which defines if the response to a fragment request is coming from browser cache or not. retryIntervals module:Settings~RequestTypeSettings &lt;optional&gt; Time in milliseconds of which to reload a failed file load attempt. For low latency mode these values are divided by lowLatencyReductionFactor. retryAttempts module:Settings~RequestTypeSettings &lt;optional&gt; Total number of retry attempts that will occur on a file load before it fails. For low latency mode these values are multiplied by lowLatencyMultiplyFactor. abr module:Settings~AbrSettings Adaptive Bitrate algorithm related settings. cmcd module:Settings~CmcdSettings Settings related to Common Media Client Data reporting. Source: core/Settings.js, line 203 × Search results Close "},"MssErrors.html":{"id":"MssErrors.html","title":"Class: MssErrors","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Class: MssErrors MssErrors new MssErrors() Source: mss/errors/MssErrors.js, line 36 Members MSS_NO_TFRF_CODE Error code returned when no tfrf box is detected in MSS live stream Source: mss/errors/MssErrors.js, line 42 MSS_UNSUPPORTED_CODEC_CODE Error code returned when one of the codecs defined in the manifest is not supported Source: mss/errors/MssErrors.js, line 47 × Search results Close "},"OfflineErrors.html":{"id":"OfflineErrors.html","title":"Class: OfflineErrors","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Class: OfflineErrors OfflineErrors Offline Errors declaration new OfflineErrors() Source: offline/errors/OfflineErrors.js, line 36 Members OFFLINE_ERROR Error code returned when an error occurs in offline module Source: offline/errors/OfflineErrors.js, line 44 × Search results Close "},"OfflineEvents.html":{"id":"OfflineEvents.html","title":"Class: OfflineEvents","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Class: OfflineEvents OfflineEvents These are offline events that should be sent to the player level. new OfflineEvents() Source: offline/events/OfflineEvents.js, line 6 Events OFFLINE_RECORD_FINISHED Triggered when all record has been downloaded Source: offline/events/OfflineEvents.js, line 28 OFFLINE_RECORD_LOADEDMETADATA Triggered when all mediaInfo has been loaded Source: offline/events/OfflineEvents.js, line 10 OFFLINE_RECORD_STARTED Triggered when a record is initialized and download is started Source: offline/events/OfflineEvents.js, line 16 OFFLINE_RECORD_STOPPED Triggered when the user stop downloading a record Source: offline/events/OfflineEvents.js, line 22 × Search results Close "},"ProtectionErrors.html":{"id":"ProtectionErrors.html","title":"Class: ProtectionErrors","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Class: ProtectionErrors ProtectionErrors new ProtectionErrors() Source: streaming/protection/errors/ProtectionErrors.js, line 35 Members KEY_SESSION_CREATED_ERROR_CODE Error code returned when key session has not been successfully created Source: streaming/protection/errors/ProtectionErrors.js, line 95 KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE Error code returned when license validity has expired Source: streaming/protection/errors/ProtectionErrors.js, line 83 KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE Error code returned when key system access is denied Source: streaming/protection/errors/ProtectionErrors.js, line 91 MEDIA_KEY_MESSAGE_ERROR_CODE Error code returned when an error occured in keymessage event for ProtectionModel_01b Source: streaming/protection/errors/ProtectionErrors.js, line 71 MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE Error code returned when license request failed after a keymessage event has been triggered Source: streaming/protection/errors/ProtectionErrors.js, line 99 MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE Error code returned when challenge is invalid in keymessage event (event triggered by CDM) Source: streaming/protection/errors/ProtectionErrors.js, line 75 MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE Error code returned when no licenser url is defined Source: streaming/protection/errors/ProtectionErrors.js, line 87 MEDIA_KEYERR_CLIENT_CODE Error code returned by keyerror api for ProtectionModel_01b Source: streaming/protection/errors/ProtectionErrors.js, line 50 MEDIA_KEYERR_CODE Generid key Error code Source: streaming/protection/errors/ProtectionErrors.js, line 42 MEDIA_KEYERR_DOMAIN_CODE Error code returned by keyerror api for ProtectionModel_01b Source: streaming/protection/errors/ProtectionErrors.js, line 66 MEDIA_KEYERR_HARDWARECHANGE_CODE Error code returned by keyerror api for ProtectionModel_01b Source: streaming/protection/errors/ProtectionErrors.js, line 62 MEDIA_KEYERR_OUTPUT_CODE Error code returned by keyerror api for ProtectionModel_01b Source: streaming/protection/errors/ProtectionErrors.js, line 58 MEDIA_KEYERR_SERVICE_CODE Error code returned by keyerror api for ProtectionModel_01b Source: streaming/protection/errors/ProtectionErrors.js, line 54 MEDIA_KEYERR_UNKNOWN_CODE Error code returned by keyerror api for ProtectionModel_01b Source: streaming/protection/errors/ProtectionErrors.js, line 46 SERVER_CERTIFICATE_UPDATED_ERROR_CODE Error code returned when License server certificate has not been successfully updated Source: streaming/protection/errors/ProtectionErrors.js, line 79 × Search results Close "},"ProtectionEvents.html":{"id":"ProtectionEvents.html","title":"Class: ProtectionEvents","body":" Dash JS Modules DashAdapterDashMetricsMediaPlayerOfflineControllerProtectionControllerSettings Classes ErrorsMediaPlayerEventsMssErrorsOfflineErrorsOfflineEventsProtectionErrorsProtectionEvents Events MediaPlayerEvents#event:AST_IN_FUTUREMediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:CAPTION_CONTAINER_RESIZEMediaPlayerEvents#event:CAPTION_RENDEREDMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:GAP_CAUSED_SEEK_TO_PERIOD_ENDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STALLEDMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZINGMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:STREAM_UPDATEDMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDMediaPlayerEvents#event:TTML_TO_PARSEOfflineEvents#event:OFFLINE_RECORD_FINISHEDOfflineEvents#event:OFFLINE_RECORD_LOADEDMETADATAOfflineEvents#event:OFFLINE_RECORD_STARTEDOfflineEvents#event:OFFLINE_RECORD_STOPPEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Global Entitieslocalforage Class: ProtectionEvents ProtectionEvents new ProtectionEvents() Public facing external events to be used when including protection package. All public events will be aggregated into the MediaPlayerEvents Class and can be accessed via MediaPlayer.events. public_ is the prefix that we use to move event names to MediaPlayerEvents. Source: streaming/protection/ProtectionEvents.js, line 35 Events KEY_ADDED Event ID for events delivered when a new key has been added Deprecated: The latest versions of the EME specification no longer use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} is preferred. Source: streaming/protection/ProtectionEvents.js, line 65 KEY_ERROR Event ID for events delivered when an error is encountered by the CDM while processing a license server response message Source: streaming/protection/ProtectionEvents.js, line 75 KEY_MESSAGE Event ID for events delivered when the protection set receives a key message from the CDM Source: streaming/protection/ProtectionEvents.js, line 82 KEY_SESSION_CLOSED Event ID for events delivered when a key session close process has completed Source: streaming/protection/ProtectionEvents.js, line 89 KEY_SESSION_CREATED Event ID for events delivered when a new key sessions creation process has completed Source: streaming/protection/ProtectionEvents.js, line 96 KEY_SESSION_REMOVED Event ID for events delivered when a key session removal process has completed Source: streaming/protection/ProtectionEvents.js, line 103 KEY_STATUSES_CHANGED Event ID for events delivered when the status of one or more decryption keys has changed Source: streaming/protection/ProtectionEvents.js, line 110 KEY_SYSTEM_SELECTED Event ID for events delivered when a key system selection procedure completes Source: streaming/protection/ProtectionEvents.js, line 124 LICENSE_REQUEST_COMPLETE Event ID for events delivered when a license request procedure has completed Source: streaming/protection/ProtectionEvents.js, line 131 PROTECTION_CREATED Event ID for events delivered when the Protection system is detected and created. Source: streaming/protection/ProtectionEvents.js, line 144 PROTECTION_DESTROYED Event ID for events delivered when the Protection system is destroyed. Source: streaming/protection/ProtectionEvents.js, line 150 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
